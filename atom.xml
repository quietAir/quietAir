<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QuietAir</title>
  
  <subtitle>沉静的空气，环绕身边，让时间失衡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://quietair.gitee.io/"/>
  <updated>2021-06-13T13:10:37.556Z</updated>
  <id>https://quietair.gitee.io/</id>
  
  <author>
    <name>QuietAir</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot+MyBatis+Thymeleaf 简单的增删改查实例 带分页功能</title>
    <link href="https://quietair.gitee.io/springboot_mybatis_thymeleaf/"/>
    <id>https://quietair.gitee.io/springboot_mybatis_thymeleaf/</id>
    <published>2020-08-23T15:47:11.000Z</published>
    <updated>2021-06-13T13:10:37.556Z</updated>
    
    <content type="html"><![CDATA[<p><strong>项目开发环境</strong></p><p>开发工具：IDEA<br>框架：springboot、mybatis<br>模板引擎：thymeleaf<br>数据库：MySQL<br>构建工具：Maven<br>可视化工具：Navicat for MySQL</p><a id="more"></a><p><strong>访问地址</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/curd/listCategory</span><br></pre></td></tr></table></figure><h2 id="1-数据库设计"><a href="#1-数据库设计" class="headerlink" title="1.数据库设计"></a>1.数据库设计</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> demo;</span><br><span class="line"><span class="keyword">use</span> demo;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> category_ (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">30</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=UTF8;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application.properties文件配置</span></span><br><span class="line"><span class="comment">#thymeleaf 配置</span></span><br><span class="line"><span class="meta">spring.thymeleaf.mode</span>=<span class="string">HTML5</span></span><br><span class="line"><span class="meta">spring.thymeleaf.encoding</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="meta">spring.thymeleaf.servlet.content-type</span>=<span class="string">text/html</span></span><br><span class="line"><span class="comment">#缓存设置为false, 这样修改之后马上生效，便于调试</span></span><br><span class="line"><span class="meta">spring.thymeleaf.cache</span>=<span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.servlet.context-path</span>=<span class="string">/curd</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://localhost:3306/demo?characterEncoding=UTF-8&amp;useSSL=false&amp;useJDBCCompliantTimezoneShift=true\</span></span><br><span class="line">  <span class="meta">&amp;useLegacyDatetimeCode</span>=<span class="string">false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">123456</span></span><br></pre></td></tr></table></figure><h2 id="2-导入项目所需的依赖"><a href="#2-导入项目所需的依赖" class="headerlink" title="2.导入项目所需的依赖"></a>2.导入项目所需的依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- pom.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- servlet依赖. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tomcat的支持.--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span> <span class="comment">&lt;!-- 这个需要为 true 热部署才有效 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mybatis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mysql --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- pageHelper --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-项目目录结构"><a href="#3-项目目录结构" class="headerlink" title="3.项目目录结构"></a>3.项目目录结构</h2><p><img src="/images/SpringBoot_MyBatis_Thymeleaf/image-2" alt="image-20210611225102129"></p><h2 id="4-前端代码"><a href="#4-前端代码" class="headerlink" title="4.前端代码"></a>4.前端代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 主页面listCategory.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width:500px;margin:20px auto;text-align: center"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">"center"</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">cellpadding</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>name<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"c:$&#123;page.list&#125;"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;c.id&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;c.name&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/editCategory(id=$&#123;c.id&#125;)&#125;"</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/deleteCategory(id=$&#123;c.id&#125;)&#125;"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/listCategory(start=0)&#125;"</span>&gt;</span>[首  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/listCategory(start=$&#123;page.pageNum-1&#125;)&#125;"</span>&gt;</span>[上一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/listCategory(start=$&#123;page.pageNum+1&#125;)&#125;"</span>&gt;</span>[下一页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/listCategory(start=$&#123;page.pages&#125;)&#125;"</span>&gt;</span>[末  页]<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">"@&#123;/editCategory(id=0)&#125;"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改添加二合一页面editCategory.html  --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin:0px auto; width:500px"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">"$&#123;category!=null&#125;?updateCategory:addCategory"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"name"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">th:value</span>=<span class="string">"$&#123;category!=null&#125;?$&#123;category.name&#125;"</span>/&gt;</span> <span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">th:if</span>=<span class="string">"$&#123;category!=null&#125;"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">th:value</span>=<span class="string">"$&#123;category.id&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">th:text</span>=<span class="string">"$&#123;category!=null&#125;?'修改':'添加'"</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-后端代码"><a href="#5-后端代码" class="headerlink" title="5.后端代码"></a>5.后端代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  实体类</span></span><br><span class="line"><span class="comment"> *  Category.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Category</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Category</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Category</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.pojo.Category;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CategoryMapper.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CategoryMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from category_"</span>)</span><br><span class="line">    <span class="function">List&lt;Category&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from category_ where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Category <span class="title">getOne</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(&#123;<span class="string">"insert into category_ (name) values (#&#123;name&#125;)"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">save</span><span class="params">(Category category)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update category_ set name = #&#123;name&#125; where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Category category)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from category_ where id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页配置</span></span><br><span class="line"><span class="comment"> * PageHelperConfig.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageHelperConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageHelper <span class="title">pageHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PageHelper pageHelper = <span class="keyword">new</span> PageHelper();</span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">"offsetAsPageNum"</span>,<span class="string">"true"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"rowBoundsWithCount"</span>,<span class="string">"true"</span>);</span><br><span class="line">        properties.setProperty(<span class="string">"reasonable"</span>,<span class="string">"true"</span>);</span><br><span class="line">        pageHelper.setProperties(properties);</span><br><span class="line">        <span class="keyword">return</span> pageHelper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.mapper.CategoryMapper;</span><br><span class="line"><span class="keyword">import</span> com.example.pojo.Category;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageHelper;</span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageInfo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CurdController.java</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurdController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> CategoryMapper CategoryMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/listCategory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">listCategory</span><span class="params">(Model m, @RequestParam(value = <span class="string">"start"</span>,defaultValue =</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="string">"0"</span>)</span> <span class="keyword">int</span> start ,@<span class="title">RequestParam</span><span class="params">(value = <span class="string">"size"</span>,defaultValue = <span class="string">"5"</span>)</span> <span class="keyword">int</span> size)<span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PageHelper.startPage(start,size,<span class="string">"id desc"</span>);</span><br><span class="line">        List&lt;Category&gt; all = CategoryMapper.findAll();</span><br><span class="line">        PageInfo&lt;Category&gt; page = <span class="keyword">new</span> PageInfo&lt;&gt;(all);</span><br><span class="line">        m.addAttribute(<span class="string">"page"</span>,page);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"listCategory"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/addCategory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">saveCategory</span><span class="params">(Category category)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CategoryMapper.save(category);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:listCategory"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/updateCategory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateCategory</span><span class="params">(Category category)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CategoryMapper.update(category);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:listCategory"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/deleteCategory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteCategory</span><span class="params">(Category category)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        CategoryMapper.delete(category.getId());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:listCategory"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/editCategory"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">editCategory</span><span class="params">(<span class="keyword">int</span> id , Model m)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id!=<span class="number">0</span>) &#123;</span><br><span class="line">            m.addAttribute(<span class="string">"category"</span>, CategoryMapper.getOne(id));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m.addAttribute(<span class="string">"category"</span>,<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"editCategory"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-项目截图"><a href="#6-项目截图" class="headerlink" title="6.项目截图"></a>6.项目截图</h2><p><img src="/images/SpringBoot_MyBatis_Thymeleaf/image-1" alt="image-20210611223327732"></p><p><img src="/images/SpringBoot_MyBatis_Thymeleaf/image-3" alt="image-20210611233038082"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;项目开发环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发工具：IDEA&lt;br&gt;框架：springboot、mybatis&lt;br&gt;模板引擎：thymeleaf&lt;br&gt;数据库：MySQL&lt;br&gt;构建工具：Maven&lt;br&gt;可视化工具：Navicat for MySQL&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
      <category term="MyBatis" scheme="https://quietair.gitee.io/tags/MyBatis/"/>
    
      <category term="Thymeleaf" scheme="https://quietair.gitee.io/tags/Thymeleaf/"/>
    
  </entry>
  
  <entry>
    <title>Thymeleaf内置工具</title>
    <link href="https://quietair.gitee.io/thymeleaf/"/>
    <id>https://quietair.gitee.io/thymeleaf/</id>
    <published>2020-07-28T14:14:35.000Z</published>
    <updated>2021-06-05T14:29:53.690Z</updated>
    
    <content type="html"><![CDATA[<p>Thymeleaf是一个现代服务器侧 Java 模板引擎，用于 Web 和独立环境。</p><p>Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板- HTML 可正确显示在浏览器中，也可以作为静态原型工作，从而在开发团队中实现更强的合作。</p><a id="more"></a><table><thead><tr><th><strong>内置工具类说明:</strong></th><th></th></tr></thead><tbody><tr><td>Execution Info</td><td>获取页面模板的处理信息</td></tr><tr><td>Messages</td><td>在变量表达式中获取外部消息的方法，与使用＃{…}语法获取的方法相同</td></tr><tr><td>URIs/URLs</td><td>转义部分URL / URI的方法</td></tr><tr><td>Conversions</td><td>用于执行已配置的转换服务的方法</td></tr><tr><td>Dates</td><td>时间操作和时间格式化等</td></tr><tr><td>Calendars</td><td>用于更复杂时间的格式化</td></tr><tr><td>Numbers</td><td>格式化数字对象的方法</td></tr><tr><td>Strings</td><td>字符串工具类</td></tr><tr><td>Objects</td><td>一般对象类，通常用来判断非空</td></tr><tr><td>Booleans</td><td>常用的布尔方法</td></tr><tr><td>Arrays</td><td>数组工具类</td></tr><tr><td>Lists</td><td>List 工具类</td></tr><tr><td>Sets</td><td>Set 工具类</td></tr><tr><td>Maps</td><td>常用Map方法</td></tr><tr><td>Aggregates</td><td>在数组或集合上创建聚合的方法</td></tr><tr><td>IDs</td><td>处理可能重复的id属性的方法</td></tr></tbody></table><h2 id="1-Execution-Info"><a href="#1-Execution-Info" class="headerlink" title="1.Execution Info"></a>1.Execution Info</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#execInfo.templateName&#125;</span><br><span class="line">$&#123;#execInfo.templateMode&#125;</span><br><span class="line">$&#123;#execInfo.processedTemplateName&#125;</span><br><span class="line">$&#123;#execInfo.processedTemplateMode&#125;</span><br><span class="line">$&#123;#execInfo.templateNames&#125;</span><br><span class="line">$&#123;#execInfo.templateModes&#125;</span><br><span class="line">$&#123;#execInfo.templateStack&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Messages"><a href="#2-Messages" class="headerlink" title="2.Messages"></a>2.Messages</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#messages.msg('msgKey')&#125;</span><br><span class="line">$&#123;#messages.msg('msgKey', param1)&#125;</span><br><span class="line">$&#123;#messages.msg('msgKey', param1, param2)&#125;</span><br><span class="line">$&#123;#messages.msg('msgKey', param1, param2, param3)&#125;</span><br><span class="line">$&#123;#messages.msgWithParams('msgKey', new Object[] &#123;param1, param2, param3, param4&#125;)&#125;</span><br><span class="line">$&#123;#messages.arrayMsg(messageKeyArray)&#125;</span><br><span class="line">$&#123;#messages.listMsg(messageKeyList)&#125;</span><br><span class="line">$&#123;#messages.setMsg(messageKeySet)&#125;</span><br><span class="line">$&#123;#messages.msgOrNull('msgKey')&#125;</span><br><span class="line">$&#123;#messages.msgOrNull('msgKey', param1)&#125;</span><br><span class="line">$&#123;#messages.msgOrNull('msgKey', param1, param2)&#125;</span><br><span class="line">$&#123;#messages.msgOrNull('msgKey', param1, param2, param3)&#125;</span><br><span class="line">$&#123;#messages.msgOrNullWithParams('msgKey', new Object[] &#123;param1, param2, param3, param4&#125;)&#125;</span><br><span class="line">$&#123;#messages.arrayMsgOrNull(messageKeyArray)&#125;</span><br><span class="line">$&#123;#messages.listMsgOrNull(messageKeyList)&#125;</span><br><span class="line">$&#123;#messages.setMsgOrNull(messageKeySet)&#125;</span><br></pre></td></tr></table></figure><h2 id="3-URIs-URLs"><a href="#3-URIs-URLs" class="headerlink" title="3.URIs/URLs"></a>3.URIs/URLs</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#uris.escapePath(uri)&#125;</span><br><span class="line">$&#123;#uris.escapePath(uri, encoding)&#125;</span><br><span class="line">$&#123;#uris.unescapePath(uri)&#125;</span><br><span class="line">$&#123;#uris.unescapePath(uri, encoding)&#125;</span><br><span class="line">$&#123;#uris.escapePathSegment(uri)&#125;</span><br><span class="line">$&#123;#uris.escapePathSegment(uri, encoding)&#125;</span><br><span class="line">$&#123;#uris.unescapePathSegment(uri)&#125;</span><br><span class="line">$&#123;#uris.unescapePathSegment(uri, encoding)&#125;</span><br><span class="line">$&#123;#uris.escapeFragmentId(uri)&#125;</span><br><span class="line">$&#123;#uris.escapeFragmentId(uri, encoding)&#125;</span><br><span class="line">$&#123;#uris.unescapeFragmentId(uri)&#125;</span><br><span class="line">$&#123;#uris.unescapeFragmentId(uri, encoding)&#125;</span><br><span class="line">$&#123;#uris.escapeQueryParam(uri)&#125;</span><br><span class="line">$&#123;#uris.escapeQueryParam(uri, encoding)&#125;</span><br><span class="line">$&#123;#uris.unescapeQueryParam(uri)&#125;</span><br><span class="line">$&#123;#uris.unescapeQueryParam(uri, encoding)&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Conversions"><a href="#4-Conversions" class="headerlink" title="4.Conversions"></a>4.Conversions</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#conversions.convert(object, 'java.util.TimeZone')&#125;</span><br><span class="line">$&#123;#conversions.convert(object, targetClass)&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Dates"><a href="#5-Dates" class="headerlink" title="5.Dates"></a>5.Dates</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#dates.format(date)&#125;</span><br><span class="line">$&#123;#dates.arrayFormat(datesArray)&#125;</span><br><span class="line">$&#123;#dates.listFormat(datesList)&#125;</span><br><span class="line">$&#123;#dates.setFormat(datesSet)&#125;</span><br><span class="line">$&#123;#dates.formatISO(date)&#125;</span><br><span class="line">$&#123;#dates.arrayFormatISO(datesArray)&#125;</span><br><span class="line">$&#123;#dates.listFormatISO(datesList)&#125;</span><br><span class="line">$&#123;#dates.setFormatISO(datesSet)&#125;</span><br><span class="line">$&#123;#dates.format(date, 'dd/MMM/yyyy HH:mm')&#125;</span><br><span class="line">$&#123;#dates.arrayFormat(datesArray, 'dd/MMM/yyyy HH:mm')&#125;</span><br><span class="line">$&#123;#dates.listFormat(datesList, 'dd/MMM/yyyy HH:mm')&#125;</span><br><span class="line">$&#123;#dates.setFormat(datesSet, 'dd/MMM/yyyy HH:mm')&#125;</span><br><span class="line">$&#123;#dates.day(date)&#125;                   </span><br><span class="line">$&#123;#dates.month(date)&#125;                 </span><br><span class="line">$&#123;#dates.monthName(date)&#125;             </span><br><span class="line">$&#123;#dates.monthNameShort(date)&#125;        </span><br><span class="line">$&#123;#dates.year(date)&#125;                  </span><br><span class="line">$&#123;#dates.dayOfWeek(date)&#125;             </span><br><span class="line">$&#123;#dates.dayOfWeekName(date)&#125;         </span><br><span class="line">$&#123;#dates.dayOfWeekNameShort(date)&#125;    </span><br><span class="line">$&#123;#dates.hour(date)&#125;                  </span><br><span class="line">$&#123;#dates.minute(date)&#125;                </span><br><span class="line">$&#123;#dates.second(date)&#125;                </span><br><span class="line">$&#123;#dates.millisecond(date)&#125;           </span><br><span class="line">$&#123;#dates.create(year,month,day)&#125;</span><br><span class="line">$&#123;#dates.create(year,month,day,hour,minute)&#125;</span><br><span class="line">$&#123;#dates.create(year,month,day,hour,minute,second)&#125;</span><br><span class="line">$&#123;#dates.create(year,month,day,hour,minute,second,millisecond)&#125;</span><br><span class="line">$&#123;#dates.createNow()&#125;</span><br><span class="line">$&#123;#dates.createNowForTimeZone()&#125;</span><br><span class="line">$&#123;#dates.createToday()&#125;</span><br><span class="line">$&#123;#dates.createTodayForTimeZone()&#125;</span><br></pre></td></tr></table></figure><h2 id="6-Calendars"><a href="#6-Calendars" class="headerlink" title="6.Calendars"></a>6.Calendars</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#calendars.format(cal)&#125;</span><br><span class="line">$&#123;#calendars.arrayFormat(calArray)&#125;</span><br><span class="line">$&#123;#calendars.listFormat(calList)&#125;</span><br><span class="line">$&#123;#calendars.setFormat(calSet)&#125;</span><br><span class="line">$&#123;#calendars.formatISO(cal)&#125;</span><br><span class="line">$&#123;#calendars.arrayFormatISO(calArray)&#125;</span><br><span class="line">$&#123;#calendars.listFormatISO(calList)&#125;</span><br><span class="line">$&#123;#calendars.setFormatISO(calSet)&#125;</span><br><span class="line">$&#123;#calendars.format(cal, 'dd/MMM/yyyy HH:mm')&#125;</span><br><span class="line">$&#123;#calendars.arrayFormat(calArray, 'dd/MMM/yyyy HH:mm')&#125;</span><br><span class="line">$&#123;#calendars.listFormat(calList, 'dd/MMM/yyyy HH:mm')&#125;</span><br><span class="line">$&#123;#calendars.setFormat(calSet, 'dd/MMM/yyyy HH:mm')&#125;</span><br><span class="line">$&#123;#calendars.day(date)&#125;               </span><br><span class="line">$&#123;#calendars.month(date)&#125;             </span><br><span class="line">$&#123;#calendars.monthName(date)&#125;         </span><br><span class="line">$&#123;#calendars.monthNameShort(date)&#125;    </span><br><span class="line">$&#123;#calendars.year(date)&#125;              </span><br><span class="line">$&#123;#calendars.dayOfWeek(date)&#125;         </span><br><span class="line">$&#123;#calendars.dayOfWeekName(date)&#125;     </span><br><span class="line">$&#123;#calendars.dayOfWeekNameShort(date)&#125;</span><br><span class="line">$&#123;#calendars.hour(date)&#125;              </span><br><span class="line">$&#123;#calendars.minute(date)&#125;            </span><br><span class="line">$&#123;#calendars.second(date)&#125;            </span><br><span class="line">$&#123;#calendars.millisecond(date)&#125;       </span><br><span class="line">$&#123;#calendars.create(year,month,day)&#125;</span><br><span class="line">$&#123;#calendars.create(year,month,day,hour,minute)&#125;</span><br><span class="line">$&#123;#calendars.create(year,month,day,hour,minute,second)&#125;</span><br><span class="line">$&#123;#calendars.create(year,month,day,hour,minute,second,millisecond)&#125;</span><br><span class="line">$&#123;#calendars.createForTimeZone(year,month,day,timeZone)&#125;</span><br><span class="line">$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,timeZone)&#125;</span><br><span class="line">$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,second,timeZone)&#125;</span><br><span class="line">$&#123;#calendars.createForTimeZone(year,month,day,hour,minute,second,millisecond,timeZone)&#125;</span><br><span class="line">$&#123;#calendars.createNow()&#125;</span><br><span class="line">$&#123;#calendars.createNowForTimeZone()&#125;</span><br><span class="line">$&#123;#calendars.createToday()&#125;</span><br><span class="line">$&#123;#calendars.createTodayForTimeZone()&#125;</span><br></pre></td></tr></table></figure><h2 id="7-Numbers"><a href="#7-Numbers" class="headerlink" title="7.Numbers"></a>7.Numbers</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#numbers.formatInteger(num,3)&#125;</span><br><span class="line">$&#123;#numbers.arrayFormatInteger(numArray,3)&#125;</span><br><span class="line">$&#123;#numbers.listFormatInteger(numList,3)&#125;</span><br><span class="line">$&#123;#numbers.setFormatInteger(numSet,3)&#125;</span><br><span class="line">$&#123;#numbers.formatInteger(num,3,'POINT')&#125;</span><br><span class="line">$&#123;#numbers.arrayFormatInteger(numArray,3,'POINT')&#125;</span><br><span class="line">$&#123;#numbers.listFormatInteger(numList,3,'POINT')&#125;</span><br><span class="line">$&#123;#numbers.setFormatInteger(numSet,3,'POINT')&#125;</span><br><span class="line">$&#123;#numbers.formatDecimal(num,3,2)&#125;</span><br><span class="line">$&#123;#numbers.arrayFormatDecimal(numArray,3,2)&#125;</span><br><span class="line">$&#123;#numbers.listFormatDecimal(numList,3,2)&#125;</span><br><span class="line">$&#123;#numbers.setFormatDecimal(numSet,3,2)&#125;</span><br><span class="line">$&#123;#numbers.formatDecimal(num,3,2,'COMMA')&#125;</span><br><span class="line">$&#123;#numbers.arrayFormatDecimal(numArray,3,2,'COMMA')&#125;</span><br><span class="line">$&#123;#numbers.listFormatDecimal(numList,3,2,'COMMA')&#125;</span><br><span class="line">$&#123;#numbers.setFormatDecimal(numSet,3,2,'COMMA')&#125;</span><br><span class="line">$&#123;#numbers.formatDecimal(num,3,'POINT',2,'COMMA')&#125;</span><br><span class="line">$&#123;#numbers.arrayFormatDecimal(numArray,3,'POINT',2,'COMMA')&#125;</span><br><span class="line">$&#123;#numbers.listFormatDecimal(numList,3,'POINT',2,'COMMA')&#125;</span><br><span class="line">$&#123;#numbers.setFormatDecimal(numSet,3,'POINT',2,'COMMA')&#125;</span><br><span class="line">$&#123;#numbers.formatCurrency(num)&#125;</span><br><span class="line">$&#123;#numbers.arrayFormatCurrency(numArray)&#125;</span><br><span class="line">$&#123;#numbers.listFormatCurrency(numList)&#125;</span><br><span class="line">$&#123;#numbers.setFormatCurrency(numSet)&#125;</span><br><span class="line">$&#123;#numbers.formatPercent(num)&#125;</span><br><span class="line">$&#123;#numbers.arrayFormatPercent(numArray)&#125;</span><br><span class="line">$&#123;#numbers.listFormatPercent(numList)&#125;</span><br><span class="line">$&#123;#numbers.setFormatPercent(numSet)&#125;</span><br><span class="line">$&#123;#numbers.formatPercent(num, 3, 2)&#125;</span><br><span class="line">$&#123;#numbers.arrayFormatPercent(numArray, 3, 2)&#125;</span><br><span class="line">$&#123;#numbers.listFormatPercent(numList, 3, 2)&#125;</span><br><span class="line">$&#123;#numbers.setFormatPercent(numSet, 3, 2)&#125;</span><br><span class="line">$&#123;#numbers.sequence(from,to)&#125;</span><br><span class="line">$&#123;#numbers.sequence(from,to,step)&#125;</span><br></pre></td></tr></table></figure><h2 id="8-Strings"><a href="#8-Strings" class="headerlink" title="8.Strings"></a>8.Strings</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#strings.toString(obj)&#125;                          </span><br><span class="line">$&#123;#strings.isEmpty(name)&#125;</span><br><span class="line">$&#123;#strings.arrayIsEmpty(nameArr)&#125;</span><br><span class="line">$&#123;#strings.listIsEmpty(nameList)&#125;</span><br><span class="line">$&#123;#strings.setIsEmpty(nameSet)&#125;</span><br><span class="line">$&#123;#strings.defaultString(text,default)&#125;</span><br><span class="line">$&#123;#strings.arrayDefaultString(textArr,default)&#125;</span><br><span class="line">$&#123;#strings.listDefaultString(textList,default)&#125;</span><br><span class="line">$&#123;#strings.setDefaultString(textSet,default)&#125;</span><br><span class="line">$&#123;#strings.contains(name,'ez')&#125;                    </span><br><span class="line">$&#123;#strings.containsIgnoreCase(name,'ez')&#125;          </span><br><span class="line">$&#123;#strings.startsWith(name,'Don')&#125;                 </span><br><span class="line">$&#123;#strings.endsWith(name,endingFragment)&#125;          </span><br><span class="line">$&#123;#strings.indexOf(name,frag)&#125;                     </span><br><span class="line">$&#123;#strings.substring(name,3,5)&#125;                    </span><br><span class="line">$&#123;#strings.substringAfter(name,prefix)&#125;            </span><br><span class="line">$&#123;#strings.substringBefore(name,suffix)&#125;           </span><br><span class="line">$&#123;#strings.replace(name,'las','ler')&#125;              </span><br><span class="line">$&#123;#strings.prepend(str,prefix)&#125;                    </span><br><span class="line">$&#123;#strings.append(str,suffix)&#125;                     </span><br><span class="line">$&#123;#strings.toUpperCase(name)&#125;                      </span><br><span class="line">$&#123;#strings.toLowerCase(name)&#125;                      </span><br><span class="line">$&#123;#strings.arrayJoin(namesArray,',')&#125;</span><br><span class="line">$&#123;#strings.listJoin(namesList,',')&#125;</span><br><span class="line">$&#123;#strings.setJoin(namesSet,',')&#125;</span><br><span class="line">$&#123;#strings.arraySplit(namesStr,',')&#125;               </span><br><span class="line">$&#123;#strings.listSplit(namesStr,',')&#125;                </span><br><span class="line">$&#123;#strings.setSplit(namesStr,',')&#125;                 </span><br><span class="line">$&#123;#strings.trim(str)&#125;                              </span><br><span class="line">$&#123;#strings.length(str)&#125;                            </span><br><span class="line">$&#123;#strings.abbreviate(str,10)&#125;                     </span><br><span class="line">$&#123;#strings.capitalize(str)&#125;                        </span><br><span class="line">$&#123;#strings.unCapitalize(str)&#125;                      </span><br><span class="line">$&#123;#strings.capitalizeWords(str)&#125;                   </span><br><span class="line">$&#123;#strings.capitalizeWords(str,delimiters)&#125;        </span><br><span class="line">$&#123;#strings.escapeXml(str)&#125;                         </span><br><span class="line">$&#123;#strings.escapeJava(str)&#125;                        </span><br><span class="line">$&#123;#strings.escapeJavaScript(str)&#125;                  </span><br><span class="line">$&#123;#strings.unescapeJava(str)&#125;                      </span><br><span class="line">$&#123;#strings.unescapeJavaScript(str)&#125;                </span><br><span class="line">$&#123;#strings.equals(first, second)&#125;</span><br><span class="line">$&#123;#strings.equalsIgnoreCase(first, second)&#125;</span><br><span class="line">$&#123;#strings.concat(values...)&#125;</span><br><span class="line">$&#123;#strings.concatReplaceNulls(nullValue, values...)&#125;</span><br><span class="line">$&#123;#strings.randomAlphanumeric(count)&#125;</span><br></pre></td></tr></table></figure><h2 id="9-Objects"><a href="#9-Objects" class="headerlink" title="9.Objects"></a>9.Objects</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#objects.nullSafe(obj,default)&#125;</span><br><span class="line">$&#123;#objects.arrayNullSafe(objArray,default)&#125;</span><br><span class="line">$&#123;#objects.listNullSafe(objList,default)&#125;</span><br><span class="line">$&#123;#objects.setNullSafe(objSet,default)&#125;</span><br></pre></td></tr></table></figure><h2 id="10-Booleans"><a href="#10-Booleans" class="headerlink" title="10.Booleans"></a>10.Booleans</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#bools.isTrue(obj)&#125;</span><br><span class="line">$&#123;#bools.arrayIsTrue(objArray)&#125;</span><br><span class="line">$&#123;#bools.listIsTrue(objList)&#125;</span><br><span class="line">$&#123;#bools.setIsTrue(objSet)&#125;</span><br><span class="line">$&#123;#bools.isFalse(cond)&#125;</span><br><span class="line">$&#123;#bools.arrayIsFalse(condArray)&#125;</span><br><span class="line">$&#123;#bools.listIsFalse(condList)&#125;</span><br><span class="line">$&#123;#bools.setIsFalse(condSet)&#125;</span><br><span class="line">$&#123;#bools.arrayAnd(condArray)&#125;</span><br><span class="line">$&#123;#bools.listAnd(condList)&#125;</span><br><span class="line">$&#123;#bools.setAnd(condSet)&#125;</span><br><span class="line">$&#123;#bools.arrayOr(condArray)&#125;</span><br><span class="line">$&#123;#bools.listOr(condList)&#125;</span><br><span class="line">$&#123;#bools.setOr(condSet)&#125;</span><br></pre></td></tr></table></figure><h2 id="11-Arrays"><a href="#11-Arrays" class="headerlink" title="11.Arrays"></a>11.Arrays</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#arrays.toArray(object)&#125;</span><br><span class="line">$&#123;#arrays.toStringArray(object)&#125;</span><br><span class="line">$&#123;#arrays.toIntegerArray(object)&#125;</span><br><span class="line">$&#123;#arrays.toLongArray(object)&#125;</span><br><span class="line">$&#123;#arrays.toDoubleArray(object)&#125;</span><br><span class="line">$&#123;#arrays.toFloatArray(object)&#125;</span><br><span class="line">$&#123;#arrays.toBooleanArray(object)&#125;</span><br><span class="line">$&#123;#arrays.length(array)&#125;</span><br><span class="line">$&#123;#arrays.isEmpty(array)&#125;</span><br><span class="line">$&#123;#arrays.contains(array, element)&#125;</span><br><span class="line">$&#123;#arrays.containsAll(array, elements)&#125;</span><br></pre></td></tr></table></figure><h2 id="12-Lists"><a href="#12-Lists" class="headerlink" title="12.Lists"></a>12.Lists</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#lists.toList(object)&#125;</span><br><span class="line">$&#123;#lists.size(list)&#125;</span><br><span class="line">$&#123;#lists.isEmpty(list)&#125;</span><br><span class="line">$&#123;#lists.contains(list, element)&#125;</span><br><span class="line">$&#123;#lists.containsAll(list, elements)&#125;</span><br><span class="line">$&#123;#lists.sort(list)&#125;</span><br><span class="line">$&#123;#lists.sort(list, comparator)&#125;</span><br><span class="line">$&#123;#sets.toSet(object)&#125;</span><br></pre></td></tr></table></figure><h2 id="13-Sets"><a href="#13-Sets" class="headerlink" title="13.Sets"></a>13.Sets</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#sets.size(set)&#125;</span><br><span class="line">$&#123;#sets.isEmpty(set)&#125;</span><br><span class="line">$&#123;#sets.contains(set, element)&#125;</span><br><span class="line">$&#123;#sets.containsAll(set, elements)&#125;</span><br></pre></td></tr></table></figure><h2 id="14-Maps"><a href="#14-Maps" class="headerlink" title="14.Maps"></a>14.Maps</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#maps.size(map)&#125;</span><br><span class="line">$&#123;#maps.isEmpty(map)&#125;</span><br><span class="line">$&#123;#maps.containsKey(map, key)&#125;</span><br><span class="line">$&#123;#maps.containsAllKeys(map, keys)&#125;</span><br><span class="line">$&#123;#maps.containsValue(map, value)&#125;</span><br><span class="line">$&#123;#maps.containsAllValues(map, value)&#125;</span><br></pre></td></tr></table></figure><h2 id="15-Aggregates"><a href="#15-Aggregates" class="headerlink" title="15.Aggregates"></a>15.Aggregates</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#aggregates.sum(array)&#125;</span><br><span class="line">$&#123;#aggregates.sum(collection)&#125;</span><br><span class="line">$&#123;#aggregates.avg(array)&#125;</span><br><span class="line">$&#123;#aggregates.avg(collection)&#125;</span><br></pre></td></tr></table></figure><h2 id="16-IDs"><a href="#16-IDs" class="headerlink" title="16.IDs"></a>16.IDs</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;#ids.seq('someId')&#125;</span><br><span class="line">$&#123;#ids.next('someId')&#125;</span><br><span class="line">$&#123;#ids.prev('someId')&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Thymeleaf是一个现代服务器侧 Java 模板引擎，用于 Web 和独立环境。&lt;/p&gt;
&lt;p&gt;Thymeleaf 的主要目标是为您的开发工作流程带来优雅的自然模板- HTML 可正确显示在浏览器中，也可以作为静态原型工作，从而在开发团队中实现更强的合作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://quietair.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Thymeleaf" scheme="https://quietair.gitee.io/tags/Thymeleaf/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(二十)之Storm、Yarn、机器学习、云计算</title>
    <link href="https://quietair.gitee.io/Java_heart_stormOrYarnYun/"/>
    <id>https://quietair.gitee.io/Java_heart_stormOrYarnYun/</id>
    <published>2020-06-20T06:38:58.000Z</published>
    <updated>2020-06-20T06:54:59.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Storm 是一个免费并开源的分布式实时计算系统。利用 Storm 可以很容易做到可靠地处理无限的数据流，像 Hadoop 批量处理大数据一样，Storm 可以实时处理数据。 </p><a id="more"></a><h2 id="2-集群架构"><a href="#2-集群架构" class="headerlink" title="2. 集群架构"></a>2. 集群架构</h2><p><img src="/images/Java_heart_stormOrYarnYun/clip_image003.gif" alt="img"> </p><h3 id="2-1-Nimbus（master-代码分发给-Supervisor）"><a href="#2-1-Nimbus（master-代码分发给-Supervisor）" class="headerlink" title="2.1. Nimbus（master-代码分发给 Supervisor）"></a>2.1. Nimbus（master-代码分发给 Supervisor）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Storm 集群的 Master 节点，负责分发用户代码，指派给具体的 Supervisor 节点上的 Worker 节点，去运行 Topology 对应的组件（Spout/Bolt）的 Task。 </p><h3 id="2-2-Supervisor（slave-管理-Worker-进程的启动和终止）"><a href="#2-2-Supervisor（slave-管理-Worker-进程的启动和终止）" class="headerlink" title="2.2. Supervisor（slave-管理 Worker 进程的启动和终止）"></a>2.2. Supervisor（slave-管理 Worker 进程的启动和终止）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Storm 集群的从节点，负责管理运行在 Supervisor 节点上的每一个 Worker 进程的启动和终止。通过 Storm 的配置文件中的 supervisor.slots.ports 配置项，可以指定在一个 Supervisor 上最大允许多少个 Slot，每个 Slot 通过端口号来唯一标识，一个端口号对应一个 Worker 进程（如果该Worker 进程被启动）。</p><h3 id="2-3-Worker（具体处理组件逻辑的进程）"><a href="#2-3-Worker（具体处理组件逻辑的进程）" class="headerlink" title="2.3. Worker（具体处理组件逻辑的进程）"></a>2.3. Worker（具体处理组件逻辑的进程）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;运行具体处理组件逻辑的进程。Worker 运行的任务类型只有两种，一种是 Spout 任务，一种是Bolt 任务。 </p><h3 id="2-4-Task"><a href="#2-4-Task" class="headerlink" title="2.4. Task"></a>2.4. Task</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;worker中每一个spout/bolt的线程称为一个task. 在storm0.8之后，task不再与物理线程对应，不同 spout/bolt 的 task 可能会共享一个物理线程，该线程称为 executor。 </p><h3 id="2-5-ZooKeeper"><a href="#2-5-ZooKeeper" class="headerlink" title="2.5. ZooKeeper"></a>2.5. ZooKeeper</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用来协调 Nimbus 和 Supervisor，如果 Supervisor 因故障出现问题而无法运行 Topology，Nimbus 会第一时间感知到，并重新分配 Topology 到其它可用的 Supervisor 上运行 </p><h2 id="3-编程模型（spout-gt-tuple-gt-bolt）"><a href="#3-编程模型（spout-gt-tuple-gt-bolt）" class="headerlink" title="3. 编程模型（spout -&gt; tuple -&gt; bolt）"></a>3. 编程模型（spout -&gt; tuple -&gt; bolt）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;strom 在运行中可分为 spout 与 bolt 两个组件，其中，数据源从 spout 开始，数据以 tuple 的方式发送到 bolt，多个 bolt 可以串连起来，一个 bolt 也可以接入多个 spot/bolt.运行时原理如下图： </p><p><img src="/images/Java_heart_stormOrYarnYun/clip_image005.gif" alt="img"> </p><h3 id="3-1-Topology"><a href="#3-1-Topology" class="headerlink" title="3.1. Topology"></a>3.1. Topology</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Storm 中运行的一个实时应用程序的名称。将 Spout、 Bolt 整合起来的拓扑图。定义了 Spout 和 Bolt 的结合关系、并发数量、配置等等。 </p><h3 id="3-2-Spout"><a href="#3-2-Spout" class="headerlink" title="3.2. Spout"></a>3.2. Spout</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在一个 topology 中获取源数据流的组件。通常情况下 spout 会从外部数据源中读取数据，然后转换为 topology 内部的源数据。</p><h3 id="3-3-Bolt"><a href="#3-3-Bolt" class="headerlink" title="3.3. Bolt"></a>3.3. Bolt</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;接受数据然后执行处理的组件,用户可以在其中执行自己想要的操作。 </p><h3 id="3-4-Tuple"><a href="#3-4-Tuple" class="headerlink" title="3.4. Tuple"></a>3.4. Tuple</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一次消息传递的基本单元，理解为一组消息就是一个 Tuple。 </p><h3 id="3-5-Stream"><a href="#3-5-Stream" class="headerlink" title="3.5. Stream"></a>3.5. Stream</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Tuple 的集合。表示数据的流向。 </p><h2 id="4-Topology-运行"><a href="#4-Topology-运行" class="headerlink" title="4. Topology 运行"></a>4. Topology 运行</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Storm 中,一个实时应用的计算任务被打包作为 Topology 发布，这同 Hadoop MapReduce 任务相似。但是有一点不同的是:在 Hadoop 中，MapReduce 任务最终会执行完成后结束；而在 Storm 中，Topology 任务一旦提交后永远不会结束，除非你显示去停止任务。计算任务Topology 是由不同的 Spouts 和 Bolts，通过数据流（Stream）连接起来的图｡一个 Storm 在集群上运行一个 Topology 时，主要通过以下 3 个实体来完成 Topology 的执行工作： </p><ol><li>Worker（进程） </li><li>Executor（线程） </li><li>Task</li></ol><p><img src="/images/Java_heart_stormOrYarnYun/clip_image007.gif" alt="img"> </p><h3 id="4-1-Worker-1-个-worker-进程执行的是-1-个-topology-的子集"><a href="#4-1-Worker-1-个-worker-进程执行的是-1-个-topology-的子集" class="headerlink" title="4.1. Worker(1 个 worker 进程执行的是 1 个 topology 的子集)"></a>4.1. Worker(1 个 worker 进程执行的是 1 个 topology 的子集)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;1 个 worker 进程执行的是 1 个 topology 的子集（注：不会出现 1 个 worker 为多个 topology 服务）。1 个 worker 进程会启动 1 个或多个 executor 线程来执行 1 个 topology 的 component(spout 或 bolt)。因此，1 个运行中的 topology 就是由集群中多台物理机上的多个 worker 进程组成的。</p><h3 id="4-2-Executor-executor-是-1-个被-worker-进程启动的单独线程"><a href="#4-2-Executor-executor-是-1-个被-worker-进程启动的单独线程" class="headerlink" title="4.2. Executor(executor 是 1 个被 worker 进程启动的单独线程)"></a>4.2. Executor(executor 是 1 个被 worker 进程启动的单独线程)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;executor 是 1 个被 worker 进程启动的单独线程。每个 executor 只会运行 1 个 topology 的 1 个 component(spout 或 bolt)的 task（注：task 可以是 1 个或多个，storm 默认是 1 个 component 只生成 1 个 task，executor 线程里会在每次循环里顺序调用所有 task 实例）。 </p><h3 id="4-3-Task-最终运行-spout-或-bolt-中代码的单元"><a href="#4-3-Task-最终运行-spout-或-bolt-中代码的单元" class="headerlink" title="4.3. Task(最终运行 spout 或 bolt 中代码的单元)"></a>4.3. Task(最终运行 spout 或 bolt 中代码的单元)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是最终运行 spout 或 bolt 中代码的单元（注：1 个 task 即为 spout 或 bolt 的 1 个实例， executor 线程在执行期间会调用该 task 的 nextTuple 或 execute 方法）。topology 启动后，1 个 component(spout 或 bolt)的 task 数目是固定不变的，但该 component 使用的 executor 线程数可以动态调整（例如：1 个 executor 线程可以执行该 component 的 1 个或多个 task 实例）。这意味着，对于 1 个 component 存在这样的条件：#threads&lt;=#tasks（即：线程数小于等于 task 数目）。默认情况下 task 的数目等于 executor 线程数目，即 1 个 executor 线程只运行 1 个 task。 </p><p><img src="/images/Java_heart_stormOrYarnYun/clip_image009.gif" alt="img"> </p><h2 id="5-Storm-Streaming-Grouping"><a href="#5-Storm-Streaming-Grouping" class="headerlink" title="5. Storm Streaming Grouping"></a>5. Storm Streaming Grouping</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Storm 中最重要的抽象，应该就是 Stream grouping 了，它能够控制 Spot/Bolt 对应的 Task 以什么样的方式来分发 Tuple，将 Tuple 发射到目的 Spot/Bolt 对应的 Task. </p><p><img src="/images/Java_heart_stormOrYarnYun/clip_image011.gif" alt="img"> </p><p>目前，Storm Streaming Grouping 支持如下几种类型：</p><h3 id="5-1-huffle-Grouping"><a href="#5-1-huffle-Grouping" class="headerlink" title="5.1. huffle Grouping"></a>5.1. huffle Grouping</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;随机分组，尽量均匀分布到下游 Bolt 中将流分组定义为混排。这种混排分组意味着来自 Spout 的输入将混排，或随机分发给此 Bolt 中的任务。shuffle grouping 对各个 task 的 tuple 分配的比较均匀。 </p><h3 id="5-2-Fields-Grouping"><a href="#5-2-Fields-Grouping" class="headerlink" title="5.2. Fields Grouping"></a>5.2. Fields Grouping</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;按字段分组，按数据中 field 值进行分组；相同 field 值的 Tuple 被发送到相同的 Task 这种 grouping 机制保证相同 field 值的 tuple 会去同一个 task。 </p><h3 id="5-3-All-grouping-：广播"><a href="#5-3-All-grouping-：广播" class="headerlink" title="5.3. All grouping ：广播"></a>5.3. All grouping ：广播</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;广播发送， 对于每一个 tuple 将会复制到每一个 bolt 中处理。 </p><h3 id="5-4-Global-grouping"><a href="#5-4-Global-grouping" class="headerlink" title="5.4. Global grouping"></a>5.4. Global grouping</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;全局分组，Tuple 被分配到一个 Bolt 中的一个 Task，实现事务性的 Topology。Stream 中的所有的 tuple 都会发送给同一个 bolt 任务处理，所有的 tuple 将会发送给拥有最小 task_id 的 bolt 任务处理。 </p><h3 id="5-5-None-grouping-：不分组"><a href="#5-5-None-grouping-：不分组" class="headerlink" title="5.5. None grouping ：不分组"></a>5.5. None grouping ：不分组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;不关注并行处理负载均衡策略时使用该方式，目前等同于 shuffle grouping,另外 storm 将会把 bolt 任务和他的上游提供数据的任务安排在同一个线程下。 </p><h3 id="5-6-Direct-grouping-：直接分组-指定分组"><a href="#5-6-Direct-grouping-：直接分组-指定分组" class="headerlink" title="5.6. Direct grouping ：直接分组 指定分组"></a>5.6. Direct grouping ：直接分组 指定分组</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;由 tuple 的发射单元直接决定 tuple 将发射给那个 bolt，一般情况下是由接收 tuple 的 bolt 决定接收哪个 bolt 发射的 Tuple。这是一种比较特别的分组方法，用这种分组意味着消息的发送者指定由消息接收者的哪个 task 处理这个消息。 只有被声明为 Direct Stream 的消息流可以声明这种分组方法。而且这种消息 tuple 必须使用 emitDirect 方法来发射。消息处理者可以通过TopologyContext 来获取处理它的消息的 taskid (OutputCollector.emit 方法也会返回 taskid)。</p><h1 id="YARN"><a href="#YARN" class="headerlink" title="YARN"></a>YARN</h1><h2 id="6-概念"><a href="#6-概念" class="headerlink" title="6. 概念"></a>6. 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;YARN 是一个资源管理、任务调度的框架，主要包含三大模块：ResourceManager（RM）、NodeManager（NM）、ApplicationMaster（AM）。其中，ResourceManager 负责所有资源的监控、分配和管理；ApplicationMaster 负责每一个具体应用程序的调度和协调； NodeManager 负责每一个节点的维护。对于所有的applications，RM拥有绝对的控制权和对资源的分配权。而每个 AM 则会和 RM 协商资源，同时和 NodeManager 通信来执行和监控 task。几个模块之间的关系如图所示。 </p><p><img src="/images/Java_heart_stormOrYarnYun/clip_image013.gif" alt="img"> </p><h2 id="7-ResourceManager"><a href="#7-ResourceManager" class="headerlink" title="7. ResourceManager"></a>7. ResourceManager</h2><ol><li><p>ResourceManager 负责整个集群的资源管理和分配，是一个全局的资源管理系统。 </p></li><li><p>NodeManager 以心跳的方式向 ResourceManager 汇报资源使用情况（目前主要是 CPU 和内存的使用情况）。RM 只接受 NM 的资源回报信息，对于具体的资源处理则交给 NM 自己处理。 </p></li><li><p>YARN Scheduler 根据 application 的请求为其分配资源，不负责 application job 的监控、追踪、运行状态反馈、启动等工作。</p></li></ol><h2 id="8-NodeManager"><a href="#8-NodeManager" class="headerlink" title="8. NodeManager"></a>8. NodeManager</h2><ol><li><p>NodeManager 是每个节点上的资源和任务管理器，它是管理这台机器的代理，负责该节点程序的运行，以及该节点资源的管理和监控。YARN集群每个节点都运行一个NodeManager。 </p></li><li><p>NodeManager 定时向 ResourceManager 汇报本节点资源（CPU、内存）的使用情况和 Container 的运行状态。当 ResourceManager 宕机时 NodeManager 自动连接 RM 备用节点。 </p></li><li><p>NodeManager 接收并处理来自 ApplicationMaster 的 Container 启动、停止等各种请求。</p></li></ol><h2 id="9-ApplicationMaster"><a href="#9-ApplicationMaster" class="headerlink" title="9. ApplicationMaster"></a>9. ApplicationMaster</h2><p>用户提交的每个应用程序均包含一个ApplicationMaster，它可以运行在ResourceManager以外的机器上。 </p><ol><li><p>负责与 RM 调度器协商以获取资源（用 Container 表示）。 </p></li><li><p>将得到的任务进一步分配给内部的任务(资源的二次分配)。 </p></li><li><p>与 NM 通信以启动/停止任务。 </p></li><li><p>监控所有任务运行状态，并在任务运行失败时重新为任务申请资源以重启任务。 </p></li><li><p>当前 YARN 自带了两个 ApplicationMaster 实现，一个是用于演示 AM 编写方法的实例程序 DistributedShell，它可以申请一定数目的 Container 以并行运行一个 Shell 命令或者 Shell 脚本；另一个是运行 MapReduce 应用程序的 AM—MRAppMaster。 </p></li></ol><p>注：RM 只负责监控 AM，并在 AM 运行失败时候启动它。RM 不负责 AM 内部任务的容错，任务的容错由 AM 完成。 </p><h2 id="10-YARN-运行流程"><a href="#10-YARN-运行流程" class="headerlink" title="10. YARN 运行流程"></a>10. YARN 运行流程</h2><p><img src="/images/Java_heart_stormOrYarnYun/clip_image015.gif" alt="img"> </p><ol><li><p>client 向 RM 提交应用程序，其中包括启动该应用的 ApplicationMaster 的必须信息，例如 ApplicationMaster 程序、启动 ApplicationMaster 的命令、用户程序等。</p></li><li><p>ResourceManager 启动一个 container 用于运行 ApplicationMaster。 </p></li><li><p>启动中的ApplicationMaster向ResourceManager注册自己，启动成功后与RM保持心跳。 </p></li><li><p>ApplicationMaster 向 ResourceManager 发送请求，申请相应数目的 container。 </p></li><li><p>ResourceManager 返回 ApplicationMaster 的申请的 containers 信息。申请成功的 container，由 ApplicationMaster 进行初始化。container 的启动信息初始化后，AM 与对应的 NodeManager 通信，要求 NM 启动 container。AM 与 NM 保持心跳，从而对 NM 上运行的任务进行监控和管理。 </p></li><li><p>container 运行期间，ApplicationMaster 对 container 进行监控。container 通过 RPC 协议向对应的 AM 汇报自己的进度和状态等信息。 </p></li><li><p>应用运行期间，client 直接与 AM 通信获取应用的状态、进度更新等信息。 </p></li><li><p>应用运行结束后，ApplicationMaster 向 ResourceManager 注销自己，并允许属于它的 container 被收回。 </p></li></ol><h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><ul><li>决策树 </li><li>随机森林算法</li><li>逻辑回归</li><li>朴素贝叶斯</li><li>最近邻算法</li><li>均值算法 </li><li>Adaboost 算法</li><li>神经网络</li><li>马尔可夫</li></ul><p>参考：<a href="http://www.cyzone.cn/a/20170422/310196.html" target="_blank" rel="noopener">http://www.cyzone.cn/a/20170422/310196.html</a></p><h1 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h1><h2 id="11-SaaS"><a href="#11-SaaS" class="headerlink" title="11. SaaS"></a>11. SaaS</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;SaaS 是 Software-as-a-Service（软件即服务） </p><h2 id="12-PaaS"><a href="#12-PaaS" class="headerlink" title="12. PaaS"></a>12. PaaS</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;PaaS 是 Platform-as-a-Service 的缩写，意思是平台即服务。 把服务器平台作为一种服务提供的商业模式。通过网络进行程序提供的服务称之为 SaaS(Software as a Service)，而云计算时代相应的服务器平台或者开发环境作为服务进行提供就成为了 PaaS(Platform as a Service)。 </p><h2 id="13-IaaS"><a href="#13-IaaS" class="headerlink" title="13. IaaS"></a>13. IaaS</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;IaaS（Infrastructure as a Service），即基础设施即服务。提供给消费者的服务是对所有设施的利用，包括处理、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。</p><p><img src="/images/Java_heart_stormOrYarnYun/clip_image016.jpg" alt="img"> </p><h2 id="14-Docker"><a href="#14-Docker" class="headerlink" title="14. Docker"></a>14. Docker</h2><h3 id="14-1-概念"><a href="#14-1-概念" class="headerlink" title="14.1. 概念"></a>14.1. 概念</h3><table><thead><tr><th>Docker 镜像  (Images)</th><th>Docker 镜像是用于创建 Docker 容器的模板。</th></tr></thead><tbody><tr><td>Docker 容器  (Container)</td><td>容器是独立运行的一个或一组应用。</td></tr><tr><td>Docker 客户端  (Client)</td><td>Docker 客户端通过命令行或者其他工具使用 Docker API 与 Docker 的守护进程通信。</td></tr><tr><td>Docker 主机  (Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td>Docker 仓库  (Registry)</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。   Docker Hub 提供了庞大的镜像集合供使用。</td></tr><tr><td>Docker   Machine</td><td>Docker Machine 是一个简化 Docker 安装的命令行工具，通过一个简单的命令行即可在相  应的平台上安装 Docker，比如 VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr></tbody></table><p>&nbsp;&nbsp;&nbsp;&nbsp;Docker 的出现一定是因为目前的后端在开发和运维阶段确实需要一种虚拟化技术解决开发环境和生产环境环境一致的问题，通过 Docker 我们可以将程序运行的环境也纳入到版本控制中，排除因为环境造成不同运行结果的可能。但是上述需求虽然推动了虚拟化技术的产生，但是如果没有合适的底层技术支撑，那么我们仍然得不到一个完美的产品。本文剩下的内容会介绍几种 Docker 使用的核心技术，如果我们了解它们的使用方法和原理，就能清楚 Docker 的实现原理。Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。Docker 容器通过 Docker 镜像来创建。 </p><p><img src="/images/Java_heart_stormOrYarnYun/clip_image018.gif" alt="img"> </p><h3 id="14-2-Namespaces"><a href="#14-2-Namespaces" class="headerlink" title="14.2. Namespaces"></a>14.2. Namespaces</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;命名空间（namespaces）<u>是 Linux 为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法</u>。在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Linux 的命名空间机制提供了以下七种不同的命名空间，包括 <strong>CLONE_NEWCGROUP、CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER 和 CLONE_NEWUTS</strong>，通过这七个选项我们能在创建新的进程时设置新进程应该在哪些资源上与宿主机器进行隔离。</p><h3 id="14-3-进程-CLONE-NEWPID-实现的进程隔离"><a href="#14-3-进程-CLONE-NEWPID-实现的进程隔离" class="headerlink" title="14.3. 进程(CLONE_NEWPID 实现的进程隔离)"></a>14.3. 进程(CLONE_NEWPID 实现的进程隔离)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>docker 创建新进程时传入 CLONE_NEWPID 实现的进程隔离</u>，也就是使用 Linux 的命名空间实现进程的隔离，Docker 容器内部的任意进程都对宿主机器的进程一无所知。当我们每次运行 docker run 或者 docker start 时，都会在创建一个用于设置进程间隔离的 Spec，同时会设置进程相关的命名空间，还会设置与用户、网络、IPC 以及 UTS 相关的命名空间，所有命名空间相关的设置 Spec 最后都会作为 Create 函数的入参在创建新的容器时进行设置。 </p><h3 id="14-4-Libnetwork-与网络隔离"><a href="#14-4-Libnetwork-与网络隔离" class="headerlink" title="14.4. Libnetwork 与网络隔离"></a>14.4. Libnetwork 与网络隔离</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果 Docker 的容器通过 Linux 的命名空间完成了与宿主机进程的网络隔离，但是却有没有办法通过宿主机的网络与整个互联网相连，就会产生很多限制，所以 Docker 虽然可以通过命名空间创建一个隔离的网络环境，但是 Docker 中的服务仍然需要与外界相连才能发挥作用。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>Docker 整个网络部分的功能都是通过 Docker 拆分出来的 libnetwork 实现的</u>，它提供了一个连接不同容器的实现，同时也能够为应用给出一个能够提供一致的编程接口和网络层抽象的容器网络模型。 libnetwork 中最重要的概念，容器网络模型由以下的几个主要组件组成，分别是 Sandbox、 Endpoint 和 Network。在容器网络模型中，每一个容器内部都包含一个 Sandbox，其中存储着当前容器的网络栈配置，包括容器的接口、路由表和 DNS 设置，<u>Linux 使用网络命名空间实现这个 Sandbox，每一个 Sandbox 中都可能会有一个或多个 Endpoint，在 Linux 上就是一个虚拟的网卡 veth，Sandbox 通过 Endpoint 加入到对应的网络中，这里的网络可能就是我们在上面提到的 Linux 网桥或者 VLAN。</u> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;每一个使用 docker run 启动的容器其实都具有单独的网络命名空间，Docker 为我们提供了四种不同的网络模式，<u>Host、Container、None 和 Bridge 模式</u>。 </p><p><img src="/images/Java_heart_stormOrYarnYun/clip_image020.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在这一部分，我们将介绍 Docker 默认的网络设置模式：网桥模式。在这种模式下，除了分配隔离的网络命名空间之外，Docker 还会为所有的容器设置 IP 地址。当 Docker 服务器在主机上启动之后会创建新的虚拟网桥 docker0，随后在该主机上启动的全部服务在默认情况下都与该网桥相连。在默认情况下，每一个容器在创建时都会创建一对虚拟网卡，两个虚拟网卡组成了数据的通道，其中一个会放在创建的容器中，会加入到名为 docker0 网桥中。</p><p><img src="/images/Java_heart_stormOrYarnYun/clip_image022.gif" alt="img"> </p><h3 id="14-5-资源隔离与-CGroups"><a href="#14-5-资源隔离与-CGroups" class="headerlink" title="14.5. 资源隔离与 CGroups"></a>14.5. 资源隔离与 CGroups</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Control Groups（简称 CGroups）能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。每一个 CGroup 都是一组被相同的标准和参数限制的进程，不同的 CGroup 之间是有层级关系的，也就是说它们之间可以从父类继承一些用于限制资源使用的标准和参数。 </p><h3 id="14-6-镜像与-UnionFS"><a href="#14-6-镜像与-UnionFS" class="headerlink" title="14.6. 镜像与 UnionFS"></a>14.6. 镜像与 UnionFS</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Linux 的命名空间和控制组分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离，但是在 Docker 中还有另一个非常重要的问题需要解决 - 也就是镜像。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Docker 镜像其实本质就是一个压缩包，我们可以使用命令将一个 Docker 镜像中的文件导出，你可以看到这个<u>镜像中的目录结构与 Linux 操作系统的根目录中的内容并没有太多的区别，可以说 Docker 镜像就是一个文件。</u> </p><h3 id="14-7-存储驱动"><a href="#14-7-存储驱动" class="headerlink" title="14.7. 存储驱动"></a>14.7. 存储驱动</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Docker 使用了一系列不同的存储驱动管理镜像内的文件系统并运行容器，这些存储驱动与 Docker 卷（volume）有些不同，存储引擎管理着能够在多个容器之间共享的存储。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;当镜像被 docker run 命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;UnionFS 其实是一种为 Linux 操作系统设计的用于把多个文件系统『联合』到同一个挂载点的文件系统服务。而 AUFS 即 Advanced UnionFS 其实就是 UnionFS 的升级版，它能够提供更优秀的性能和效率。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;AUFS 只是 Docker 使用的存储驱动的一种，除了 AUFS 之外，Docker 还支持了不同的存储驱动，包括 aufs、devicemapper、overlay2、zfs 和 vfs 等等，在最新的 Docker 中，overlay2 取代了 aufs 成为了推荐的存储驱动，但是在没有 overlay2 驱动的机器上仍然会使用 aufs 作为 Docker 的默认驱动。 </p><h2 id="15-Openstack"><a href="#15-Openstack" class="headerlink" title="15. Openstack"></a>15. Openstack</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;OpenStack是一个<a href="https://baike.baidu.com/item/开源/20720669" target="_blank" rel="noopener">开源</a>的云计算管理平台项目，是一系列软件开源项目的组合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;参考：<a href="https://docs.openstack.org/ussuri/" target="_blank" rel="noopener">https://docs.openstack.org/ussuri/</a></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Storm&quot;&gt;&lt;a href=&quot;#Storm&quot; class=&quot;headerlink&quot; title=&quot;Storm&quot;&gt;&lt;/a&gt;Storm&lt;/h1&gt;&lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Storm 是一个免费并开源的分布式实时计算系统。利用 Storm 可以很容易做到可靠地处理无限的数据流，像 Hadoop 批量处理大数据一样，Storm 可以实时处理数据。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Storm" scheme="https://quietair.gitee.io/tags/Storm/"/>
    
      <category term="Yarn" scheme="https://quietair.gitee.io/tags/Yarn/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(十九)之Hadoop、Spark</title>
    <link href="https://quietair.gitee.io/Java_heart_HadoopandSpark/"/>
    <id>https://quietair.gitee.io/Java_heart_HadoopandSpark/</id>
    <published>2020-06-13T04:05:35.000Z</published>
    <updated>2020-06-13T04:24:07.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;就是一个大数据解决方案。它提供了一套分布式系统基础架构。 核心内容包含 hdfs 和 mapreduce。hadoop2.0 以后引入 yarn。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;hdfs 是提供数据存储的，mapreduce 是方便数据计算的。</p><a id="more"></a><ol><li><p>hdfs 又对应 namenode 和 datanode. namenode 负责保存元数据的基本信息， datanode 直接存放数据本身；</p></li><li><p>mapreduce 对应 jobtracker 和 tasktracker. jobtracker 负责分发任务，tasktracker 负责执行具体任务； </p></li><li><p>对应到 master/slave 架构，namenode 和 jobtracker 就应该对应到 master, datanode 和 tasktracker 就应该对应到 slave. </p></li></ol><h2 id="2-HDFS"><a href="#2-HDFS" class="headerlink" title="2. HDFS"></a>2. HDFS</h2><h3 id="2-1-Client"><a href="#2-1-Client" class="headerlink" title="2.1. Client"></a>2.1. Client</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Client（代表用 户） 通过与 NameNode 和 DataNode 交互访问 HDFS 中 的文件。 Client 提供了一个类似 POSIX 的文件系统接口供用户调用。</p><h3 id="2-2-NameNode"><a href="#2-2-NameNode" class="headerlink" title="2.2. NameNode"></a>2.2. NameNode</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;整个 Hadoop 集群中只有一个 NameNode。 它是整个系统的“ 总管”， 负责管理 HDFS 的目录树和相关的文件元数据信息。 这些信息是以“ fsimage”（ HDFS 元数据镜像文件）和 “ editlog”（HDFS 文件改动日志）两个文件形式存放在本地磁盘，当 HDFS 重启时重新构造出来的。此外， NameNode 还负责监控各个 DataNode 的健康状态， 一旦发现某个 DataNode 宕掉，则将该 DataNode 移出 HDFS 并重新备份其上面的数据。 </p><h3 id="2-3-Secondary-NameNode"><a href="#2-3-Secondary-NameNode" class="headerlink" title="2.3. Secondary NameNode"></a>2.3. Secondary NameNode</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Secondary NameNode 最重要的任务并不是为 NameNode 元数据进行热备份， 而是定期合并 fsimage 和 edits 日志， 并传输给 NameNode。 这里需要注意的是，为了减小 NameNode 压力， NameNode 自己并不会合并 fsimage 和 edits， 并将文件存储到磁盘上， 而是交由Secondary NameNode 完成。</p><h3 id="2-4-DataNode"><a href="#2-4-DataNode" class="headerlink" title="2.4. DataNode"></a>2.4. DataNode</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一般而言， 每个 Slave 节点上安装一个 DataNode， 它负责实际的数据存储， 并将数据信息定期汇报给 NameNode。 DataNode 以固定大小的 block 为基本单位组织文件内容， 默认情况下 block 大小为 64MB。 当用户上传一个大的文件到 HDFS 上时， 该文件会被切分成若干个 block， 分别存储到不同的 DataNode ； 同时，为了保证数据可靠， 会将同一个 block 以流水线方式写到若干个（默认是 3，该参数可配置）不同的 DataNode 上。 这种文件切割后存储的过程是对用户透明的。</p><h2 id="3-MapReduce"><a href="#3-MapReduce" class="headerlink" title="3. MapReduce"></a>3. MapReduce</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;同 HDFS 一样，Hadoop MapReduce 也采用了 Master/Slave（M/S）架构，具体如图所示。它主要由以下几个组件组成：Client、JobTracker、TaskTracker 和 Task。 下面分别对这几个组件进行介绍。 </p><p><img src="/images/Java_heart_HadoopandSpark/clip_image001.jpg" alt="img"> </p><h3 id="3-1-Client"><a href="#3-1-Client" class="headerlink" title="3.1.  Client"></a>3.1.  Client</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用户编写的 MapReduce 程序通过 Client 提交到 JobTracker 端； 同时， 用户可通过 Client 提供的一些接口查看作业运行状态。 在 Hadoop 内部用“作业”（Job） 表示 MapReduce 程序。 一个 MapReduce 程序可对应若干个作业，而每个作业会被分解成若干个 Map/Reduce 任务（Task）。 </p><h3 id="3-2-JobTracker"><a href="#3-2-JobTracker" class="headerlink" title="3.2.  JobTracker"></a>3.2.  JobTracker</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;JobTracker 主要负责资源监控和作业调度。JobTracker 监控所有 TaskTracker 与作业的健康状况，一旦发现失败情况后，其会将相应的任务转移到其他节点；同时 JobTracker 会跟踪任务的执行进度、资源使用量等信息，并将这些信息告诉任务调度器，而调度器会在资源出现空闲时，选择合适的任务使用这些资源。在 Hadoop 中，任务调度器是一个可插拔的模块，用户可以根据自己的需要设计相应的调度器。 </p><h3 id="3-3-TaskTracker"><a href="#3-3-TaskTracker" class="headerlink" title="3.3. TaskTracker"></a>3.3. TaskTracker</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;TaskTracker 会周期性地通过 Heartbeat 将本节点上资源的使用情况和任务的运行进度汇报给 JobTracker， 同时接收 JobTracker 发送过来的命令并执行相应的操作（如启动新任务、 杀死任务等）。TaskTracker 使用“slot” 等量划分本节点上的资源量。“slot” 代表计算资源（CPU、内存等）。一个 Task 获取到一个 slot 后才有机会运行，而 Hadoop 调度器的作用就是将各个TaskTracker 上的空闲 slot 分配给 Task 使用。 slot 分为 Map slot 和 Reduce slot 两种，分别供 MapTask 和 Reduce Task 使用。 TaskTracker 通过 slot 数目（可配置参数）限定 Task 的并发度。 </p><h3 id="3-4-Task"><a href="#3-4-Task" class="headerlink" title="3.4.  Task"></a>3.4.  Task</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Task 分为 Map Task 和 Reduce Task 两种， 均由 TaskTracker 启动。 HDFS 以固定大小的 block 为基本单位存储数据， 而对于 MapReduce 而言， 其处理单位是 split。split 与 block 的对应关系如图所示。 split 是一个逻辑概念， 它只包含一些元数据信息， 比如数据起始位置、数据长度、数据所在节点等。它的划分方法完全由用户自己决定。 但需要注意的是，split 的多少决定了 Map Task 的数目 ，因为每个 split 会交由一个 Map Task 处理。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Map Task 执行过程如图所示。 由该图可知，Map Task 先将对应的 split 迭代解析成一个个 key/value 对，依次调用用户自定义的 map() 函数进行处理，最终将临时结果存放到本地磁盘上，其中临时数据被分成若干个 partition，每个 partition 将被一个 Reduce Task 处理。 </p><p><img src="/images/Java_heart_HadoopandSpark/clip_image003.gif" alt="img"> </p><h3 id="3-5-Reduce-Task-执行过程"><a href="#3-5-Reduce-Task-执行过程" class="headerlink" title="3.5. Reduce Task 执行过程"></a>3.5. Reduce Task 执行过程</h3><p>该过程分为三个阶段 </p><ol><li><p>从远程节点上读取 MapTask 中间结果（称为“Shuffle 阶段”）； </p></li><li><p>按照 key 对 key/value 对进行排序（称为“ Sort 阶段”）； </p></li><li><p>依次读取&lt;key, value list&gt;，调用用户自定义的 reduce() 函数处理，并将最终结果存到 HDFS 上（称为“ Reduce 阶段”）。 </p></li></ol><h2 id="4-Hadoop-MapReduce-作业的生命周期"><a href="#4-Hadoop-MapReduce-作业的生命周期" class="headerlink" title="4. Hadoop MapReduce 作业的生命周期"></a>4. Hadoop MapReduce 作业的生命周期</h2><p><strong>1、作业提交与初始化</strong> </p><ol><li>用户提交作业后， 首先由 JobClient 实例将作业相关信息， 比如将程序 jar 包、作业配置文件、 分片元信息文件等上传到分布式文件系统（ 一般为 HDFS）上，其中，分片元信息文件记录了每个输入分片的逻辑位置信息。 然后 JobClient 通过 RPC 通知 JobTracker。 JobTracker 收到新作业提交请求后， 由 作业调度模块对作业进行初始化：为作业创建一个JobInProgress 对象以跟踪作业运行状况， 而 JobInProgress 则会为每个 Task 创建一个TaskInProgress 对象以跟踪每个任务的运行状态， TaskInProgress 可能需要管理多个“ Task 运行尝试”（ 称为“ Task Attempt”）。 </li></ol><p><strong>2、任务调度与监控。</strong> </p><ol start="2"><li>前面提到，任务调度和监控的功能均由 JobTracker 完成。TaskTracker 周期性地通过 Heartbeat 向 JobTracker 汇报本节点的资源使用 情况， 一旦出 现空闲资源， JobTracker 会按照一定的策略选择一个合适的任务使用该空闲资源， 这由任务调度器完成。 任务调度器是一个可插拔的独立模块， 且为双层架构， 即首先选择作业， 然后从该作业中选择任务， 其中，选择任务时需要重点考虑数据本地性。 此外，JobTracker 跟踪作业的整个运行过程，并为作业的成功运行提供全方位的保障。 首先， 当 TaskTracker 或者 Task 失败时， 转移计算任务 ； 其次， 当某个 Task 执行进度远落后于同一作业的其他 Task 时，为之启动一个相同 Task， 并选取计算快的 Task 结果作为最终结果。 </li></ol><p><strong>3、任务运行环境准备</strong> </p><ol start="3"><li>运行环境准备包括 JVM 启动和资源隔 离， 均由 TaskTracker 实现。 TaskTracker 为每个 Task 启动一个独立的 JVM 以避免不同 Task 在运行过程中相互影响 ； 同时，TaskTracker 使用了操作系统进程实现资源隔离以防止 Task 滥用资源。 </li></ol><p><strong>4、任务执行</strong> </p><ol start="4"><li>TaskTracker 为 Task 准备好运行环境后， 便会启动 Task。 在运行过程中， 每个 Task 的最新进度首先由 Task 通过 RPC 汇报给 TaskTracker， 再由 TaskTracker 汇报给 JobTracker。 </li></ol><p><strong>5、作业完成</strong>。 </p><ol start="5"><li>待所有 Task 执行完毕后， 整个作业执行成功。 </li></ol><h1 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h1><h2 id="5-概念"><a href="#5-概念" class="headerlink" title="5. 概念"></a>5. 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Spark 提供了一个全面、统一的框架用于管理各种有着不同性质（文本数据、图表数据等）的数据集和数据源（批量数据或实时的流数据）的大数据处理的需求。</p><h2 id="6-核心架构"><a href="#6-核心架构" class="headerlink" title="6. 核心架构"></a>6. 核心架构</h2><p><img src="/images/Java_heart_HadoopandSpark/clip_image006.gif" alt="img"> </p><h3 id="6-1-Spark-Core"><a href="#6-1-Spark-Core" class="headerlink" title="6.1. Spark Core"></a>6.1. Spark Core</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;包含 Spark 的基本功能；尤其是定义 RDD 的 API、操作以及这两者上的动作。其他 Spark 的库都是构建在 RDD 和 Spark Core 之上的 </p><h3 id="6-2-Spark-SQL"><a href="#6-2-Spark-SQL" class="headerlink" title="6.2. Spark SQL"></a>6.2. Spark SQL</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;提供通过 Apache Hive 的 SQL 变体 Hive 查询语言（HiveQL）与 Spark 进行交互的 API。每个数据库表被当做一个 RDD，Spark SQL 查询被转换为 Spark 操作。 </p><h3 id="6-3-Spark-Streaming"><a href="#6-3-Spark-Streaming" class="headerlink" title="6.3. Spark Streaming"></a>6.3. Spark Streaming</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对实时数据流进行处理和控制。Spark Streaming 允许程序能够像普通 RDD 一样处理实时数据 </p><h3 id="6-4-Mllib"><a href="#6-4-Mllib" class="headerlink" title="6.4. Mllib"></a>6.4. Mllib</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一个常用机器学习算法库，算法被实现为对 RDD 的 Spark 操作。这个库包含可扩展的学习算法，比如分类、回归等需要对大量数据集进行迭代的操作。 </p><h3 id="6-5-GraphX"><a href="#6-5-GraphX" class="headerlink" title="6.5. GraphX"></a>6.5. GraphX</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;控制图、并行图操作和计算的一组算法和工具的集合。GraphX 扩展了 RDD API，包含控制图、创建子图、访问路径上所有顶点的操作</p><h2 id="7-核心组件"><a href="#7-核心组件" class="headerlink" title="7. 核心组件"></a>7. 核心组件</h2><p><img src="/images/Java_heart_HadoopandSpark/clip_image008.gif" alt="img"> </p><p><strong>Cluster Manager-制整个集群，监控worker</strong> </p><p>在 standalone 模式中即为 Master 主节点，控制整个集群，监控 worker。在 YARN 模式中为资源管理器 </p><p><strong>Worker节点-负责控制计算节点</strong></p><p>从节点，负责控制计算节点，启动 Executor 或者 Driver。 </p><p><strong>Driver： 运行Application 的main()函数</strong> </p><p><strong>Executor：执行器，是为某个Application运行在worker node上的一个进程</strong> </p><h2 id="8-SPARK-编程模型"><a href="#8-SPARK-编程模型" class="headerlink" title="8. SPARK 编程模型"></a>8. SPARK 编程模型</h2><p><img src="/images/Java_heart_HadoopandSpark/clip_image010.jpg" alt="img"> </p><p>Spark 应用程序从编写到提交、执行、输出的整个过程如图所示，图中描述的步骤如下：</p><ol><li><p>用户使用SparkContext提供的API（常用的有textFile、sequenceFile、runJob、stop等）编写 Driver application 程序。此外 SQLContext、HiveContext 及 StreamingContext 对 SparkContext 进行封装，并提供了 SQL、Hive 及流式计算相关的 API。 </p></li><li><p>使用SparkContext提交的用户应用程序，首先会使用BlockManager和BroadcastManager 将任务的 Hadoop 配置进行广播。然后由 DAGScheduler 将任务转换为 RDD 并组织成 DAG， DAG 还将被划分为不同的 Stage。最后由 TaskScheduler 借助 ActorSystem 将任务提交给集群管理器（Cluster Manager）。</p></li><li><p>集群管理器（ClusterManager）给任务分配资源，即将具体任务分配到Worker上，Worker 创建 Executor 来处理任务的运行。Standalone、YARN、Mesos、EC2 等都可以作为 Spark 的集群管理器。 </p></li></ol><h2 id="9-SPARK-计算模型"><a href="#9-SPARK-计算模型" class="headerlink" title="9. SPARK 计算模型"></a>9. SPARK 计算模型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;RDD 可以看做是对各种数据计算模型的统一抽象，Spark 的计算过程主要是 RDD 的迭代计算过程。RDD 的迭代计算过程非常类似于管道。分区数量取决于 partition 数量的设定，每个分区的数据只会在一个 Task 中计算。所有分区可以在多个机器节点的 Executor 上并行执行。</p><p><img src="/images/Java_heart_HadoopandSpark/clip_image012.jpg" alt="img"> </p><h2 id="10-SPARK-运行流程"><a href="#10-SPARK-运行流程" class="headerlink" title="10. SPARK 运行流程"></a>10. SPARK 运行流程</h2><p><img src="/images/Java_heart_HadoopandSpark/clip_image014.gif" alt="img"> </p><ol><li><p>构建 Spark Application 的运行环境，启动 SparkContext </p></li><li><p>SparkContext 向资源管理器（可以是 Standalone，Mesos，Yarn）申请运行 Executor 资源， 并启动 StandaloneExecutorbackend， </p></li><li><p>Executor 向 SparkContext 申请 Task</p></li><li><p>SparkContext 将应用程序分发给 Executor </p></li><li><p>SparkContext 构建成 DAG 图，将 DAG 图分解成 Stage、将 Taskset 发送给 Task Scheduler， 最后由 Task Scheduler 将 Task 发送给 Executor 运行 </p></li><li><p>Task 在 Executor 上运行，运行完释放所有资源</p></li></ol><h2 id="11-SPARK-RDD-流程"><a href="#11-SPARK-RDD-流程" class="headerlink" title="11. SPARK RDD 流程"></a>11. SPARK RDD 流程</h2><p><img src="/images/Java_heart_HadoopandSpark/clip_image016.gif" alt="img"> </p><ol><li><p>创建 RDD 对象 </p></li><li><p>DAGScheduler 模块介入运算，计算 RDD 之间的依赖关系，RDD 之间的依赖关系就形成了DAG</p></li><li><p>每一个 Job 被分为多个 Stage。划分 Stage 的一个主要依据是当前计算因子的输入是否是确定的，如果是则将其分在同一个 Stage，避免多个 Stage 之间的消息传递开销 </p></li></ol><h2 id="12-SPARK-RDD"><a href="#12-SPARK-RDD" class="headerlink" title="12. SPARK RDD"></a>12. SPARK RDD</h2><h3 id="12-1-RDD-的创建方式"><a href="#12-1-RDD-的创建方式" class="headerlink" title="12.1. RDD 的创建方式"></a>12.1. RDD 的创建方式</h3><p>   1）从Hadoop文件系统（或与Hadoop兼容的其他持久化存储系统，如Hive、Cassandra、</p><p>HBase）输入（例如 HDFS）创建。</p><p>   2）从父 RDD 转换得到新 RDD。 </p><p>   3）通过 parallelize 或 makeRDD 将单机数据创建为分布式 RDD。 </p><h3 id="12-2-RDD-的两种操作算子（转换（Transformation）与行动（Action））"><a href="#12-2-RDD-的两种操作算子（转换（Transformation）与行动（Action））" class="headerlink" title="12.2. RDD 的两种操作算子（转换（Transformation）与行动（Action））"></a>12.2. RDD 的两种操作算子（转换（Transformation）与行动（Action））</h3><p>对于 RDD 可以有两种操作算子：转换（Transformation）与行动（Action）。 </p><p>1） 转换（Transformation）：Transformation操作是延迟计算的，也就是说从一个RDD转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算。</p><p><img src="/images/Java_heart_HadoopandSpark/clip_image018.gif" alt="img"> </p><p>   2）行动（Action）：Action 算子会触发 Spark 提交作业（Job），并将数据输出 Spark 系统。</p><p><img src="/images/Java_heart_HadoopandSpark/clip_image020.jpg" alt="img"> </p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hadoop&quot;&gt;&lt;a href=&quot;#Hadoop&quot; class=&quot;headerlink&quot; title=&quot;Hadoop&quot;&gt;&lt;/a&gt;Hadoop&lt;/h1&gt;&lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;就是一个大数据解决方案。它提供了一套分布式系统基础架构。 核心内容包含 hdfs 和 mapreduce。hadoop2.0 以后引入 yarn。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;hdfs 是提供数据存储的，mapreduce 是方便数据计算的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="HDFS" scheme="https://quietair.gitee.io/tags/HDFS/"/>
    
      <category term="Hadoop" scheme="https://quietair.gitee.io/tags/Hadoop/"/>
    
      <category term="Spark" scheme="https://quietair.gitee.io/tags/Spark/"/>
    
      <category term="MapReduce" scheme="https://quietair.gitee.io/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(十八)之数据结构</title>
    <link href="https://quietair.gitee.io/Java_heart_dataStructure/"/>
    <id>https://quietair.gitee.io/Java_heart_dataStructure/</id>
    <published>2020-06-06T07:50:43.000Z</published>
    <updated>2020-06-13T04:24:01.854Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-栈（stack）"><a href="#1-栈（stack）" class="headerlink" title="1. 栈（stack）"></a>1. 栈（stack）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶（top）。它是后进先出（LIFO）的。对栈的基本操作只有 push（进栈）和 pop（出栈）两种，前者相当于插入，后者相当于删除最后的元素。</p><a id="more"></a><p><img src="/images/Java_heart_dataStructure/clip_image003.gif" alt="img"> </p><h2 id="2-队列（queue）"><a href="#2-队列（queue）" class="headerlink" title="2. 队列（queue）"></a>2. 队列（queue）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;队列是一种特殊的<a href="https://baike.baidu.com/item/线性表" target="_blank" rel="noopener">线性表</a>特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><p><img src="/images/Java_heart_dataStructure/clip_image005.jpg" alt="img"> </p><h2 id="3-链表（Link）"><a href="#3-链表（Link）" class="headerlink" title="3. 链表（Link）"></a>3. 链表（Link）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;链表是一种数据结构，和数组同级。比如，Java 中我们使用的 ArrayList，其实现原理是数组。而 LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。 </p><p><img src="/images/Java_heart_dataStructure/clip_image007.gif" alt="img"> </p><h2 id="4-散列表（Hash-Table）"><a href="#4-散列表（Hash-Table）" class="headerlink" title="4. 散列表（Hash Table）"></a>4. 散列表（Hash Table）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;散列表（Hash table，也叫哈希表）是一种查找算法，与链表、树等算法不同的是，散列表算法在查找时不需要进行一系列和关键字（关键字是数据元素中某个数据项的值，用以标识一个数据元素）的比较操作。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>散列表算法希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素</strong>，因而必须要在数据元素的存储位置和它的关键字（可用key表示）之间建立一个确定的对应关系，使每个关键字和散列表中一个唯一的存储位置相对应。因此在查找时，只要根据这个对应关系找到给定关键字在散列表中的位置即可。这种对应关系被称为散列函数(可用 h(key)表示)。 </p><p>用的构造散列函数的方法有： </p><ol><li><p>直接定址法： 取关键字或关键字的某个线性函数值为散列地址。 即：h(key) = key  或 h(key) = a * key + b，其中 a 和 b 为常数。  </p></li><li><p>数字分析法 </p></li><li><p>平方取值法： 取关键字平方后的中间几位为散列地址。 </p></li><li><p>折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。</p></li><li><p>除留余数法：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址，即：h(key) = key MOD p  p ≤ m </p></li><li><p>随机数法：选择一个随机函数，取关键字的随机函数值为它的散列地址，即：h(key) = random(key) </p></li></ol><h2 id="5-排序二叉树"><a href="#5-排序二叉树" class="headerlink" title="5. 排序二叉树"></a>5. 排序二叉树</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;首先如果普通二叉树每个节点满足：左子树所有节点值小于它的根节点值，且右子树所有节点值大于它的根节点值，则这样的二叉树就是排序二叉树。</p><h3 id="5-1-插入操作"><a href="#5-1-插入操作" class="headerlink" title="5.1. 插入操作"></a>5.1. 插入操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;首先要从根节点开始往下找到自己要插入的位置（即新节点的父节点）；具体流程是：新节点与当前节点比较，如果相同则表示已经存在且不能再重复插入；如果小于当前节点，则到左子树中寻找，如果左子树为空则当前节点为要找的父节点，新节点插入到当前节点的左子树即可；如果大于当前节点，则到右子树中寻找，如果右子树为空则当前节点为要找的父节点，新节点插入到当前节点的右子树即可。</p><p><img src="/images/Java_heart_dataStructure/clip_image009.gif" alt="img"> </p><h3 id="5-2-删除操作"><a href="#5-2-删除操作" class="headerlink" title="5.2. 删除操作"></a>5.2. 删除操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;删除操作主要分为三种情况，<strong>即要删除的节点无子节点，要删除的节点只有一个子节点，要删除的节点有两个子节点。</strong> </p><ol><li><p>对于要删除的节点无子节点可以直接删除，即让其父节点将该子节点置空即可。 </p></li><li><p>对于要删除的节点只有一个子节点，则替换要删除的节点为其子节点。 </p></li><li><p>对于要删除的节点有两个子节点，<strong>则首先找该节点的替换节点</strong>（即右子树中最小的节点），接着替换要删除的节点为替换节点，然后删除替换节点。</p></li></ol><p><img src="/images/Java_heart_dataStructure/clip_image011.jpg" alt="img"> </p><h3 id="5-3-查询操作"><a href="#5-3-查询操作" class="headerlink" title="5.3. 查询操作"></a>5.3. 查询操作</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;查找操作的主要流程为：先和根节点比较，如果相同就返回，<strong>如果小于根节点则到左子树中递归查找，如果大于根节点则到右子树中递归查找</strong>。因此在排序二叉树中可以很容易获取最大（最右最深子节点）和最小（最左最深子节点）值。</p><h2 id="6-红黑树"><a href="#6-红黑树" class="headerlink" title="6. 红黑树"></a>6. 红黑树</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;R-B Tree，全称是 Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 </p><h3 id="6-1-红黑树的特性"><a href="#6-1-红黑树的特性" class="headerlink" title="6.1. 红黑树的特性"></a>6.1. 红黑树的特性</h3><p>（1）每个节点或者是黑色，或者是红色。 </p><p>（2）根节点是黑色。 </p><p>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] </p><p>（4）如果一个节点是红色的，则它的子节点必须是黑色的。 </p><p>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><h3 id="6-2-左旋"><a href="#6-2-左旋" class="headerlink" title="6.2. 左旋"></a>6.2. 左旋</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对 x 进行左旋，意味着，将“x 的右孩子”设为“x 的父亲节点”；即，将 x 变成了一个左节点( x 成了为 z 的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。</p><p><img src="/images/Java_heart_dataStructure/clip_image013.jpg" alt="img"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x)</span><br><span class="line">y ← right[x] // 前提：这里假设 x 的右孩子为 y。下面开始正式操作</span><br><span class="line">right[x] ← left[y] // 将 “y 的左孩子” 设为 “x 的右孩子”，即 将β设为 x 的右孩子</span><br><span class="line">p[left[y]] ← x // 将 “x” 设为 “y 的左孩子的父亲”，即 将β的父亲设为 x</span><br><span class="line">p[y] ← p[x] // 将 “x 的父亲” 设为 “y 的父亲”</span><br><span class="line">if p[x] = nil[T]</span><br><span class="line">then root[T] ← y // 情况 1：如果 “x 的父亲” 是空节点，则将 y 设为根节点</span><br><span class="line">else if x = left[p[x]]</span><br><span class="line"> then left[p[x]] ← y // 情况 2：如果 x 是它父节点的左孩子，则将 y 设为“x 的父节点</span><br><span class="line">的左孩子”</span><br><span class="line"> else right[p[x]] ← y // 情况 3：(x 是它父节点的右孩子) 将 y 设为“x 的父节点的右孩</span><br><span class="line">子”</span><br><span class="line">left[y] ← x // 将 “x” 设为 “y 的左孩子”</span><br><span class="line">p[x] ← y // 将 “x 的父节点” 设为 “y”</span><br></pre></td></tr></table></figure><p><img src="/images/Java_heart_dataStructure/clip_image015.gif" alt="img"> </p><h3 id="6-3-右旋"><a href="#6-3-右旋" class="headerlink" title="6.3. 右旋"></a>6.3. 右旋</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对 x 进行右旋，意味着，将“x 的左孩子”设为“x 的父亲节点”；即，将 x 变成了一个右节点( x 成了为 y 的右孩子)！ 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。</p><p><img src="/images/Java_heart_dataStructure/clip_image017.gif" alt="img"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RIGHT-ROTATE(T, y)</span><br><span class="line">x ← left[y] // 前提：这里假设 y 的左孩子为 x。下面开始正式操作</span><br><span class="line">left[y] ← right[x] // 将 “x 的右孩子” 设为 “y 的左孩子”，即 将β设为 y 的左孩子</span><br><span class="line">p[right[x]] ← y // 将 “y” 设为 “x 的右孩子的父亲”，即 将β的父亲设为 y</span><br><span class="line">p[x] ← p[y] // 将 “y 的父亲” 设为 “x 的父亲”</span><br><span class="line">if p[y] = nil[T]</span><br><span class="line">then root[T] ← x // 情况 1：如果 “y 的父亲” 是空节点，则将 x 设为根节点</span><br><span class="line">else if y = right[p[y]]</span><br><span class="line"> then right[p[y]] ← x // 情况 2：如果 y 是它父节点的右孩子，则将 x 设为“y 的父节点的左孩子”</span><br><span class="line"> else left[p[y]] ← x // 情况 3：(y 是它父节点的左孩子) 将 x 设为“y 的父节点的左孩子”</span><br><span class="line">right[x] ← y // 将 “y” 设为 “x 的右孩子”</span><br><span class="line">p[y] ← x // 将 “y 的父节点” 设为 “x”</span><br></pre></td></tr></table></figure><h3 id="6-4-添加"><a href="#6-4-添加" class="headerlink" title="6.4. 添加"></a>6.4. 添加</h3><p>第一步: 将红黑树当作一颗二叉查找树，将节点插入。 </p><p>第二步：将插入的节点着色为”红色”。  </p><p>根据被插入节点的父节点的情况，可以将”当节点 z 被着色为红色节点，并插入二叉树”划分为三种情况来处理。 </p><p>① 情况说明：被插入的节点是根节点。 处理方法：直接把此节点涂为黑色。 </p><p>② 情况说明：被插入的节点的父节点是黑色。 处理方法：什么也不需要做。节点被插入后，仍然是红黑树。 </p><p>③ 情况说明：被插入的节点的父节点是红色。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为 3种情况(Case)。 </p><p><img src="/images/Java_heart_dataStructure/clip_image019.jpg" alt="img"> </p><p>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。 </p><h3 id="6-5-删除"><a href="#6-5-删除" class="headerlink" title="6.5. 删除"></a>6.5. 删除</h3><p>第一步：将红黑树当作一颗二叉查找树，将节点删除。 </p><p>这和”删除常规二叉查找树中删除节点的方法是一样的”。分 3 种情况： </p><p>① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就 OK 了。 </p><p>② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</p><p>③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 </p><p>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。 因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。 </p><p>选择重着色 3 种情况。 </p><p>① 情况说明：x 是“红+黑”节点。 处理方法：直接把 x 设为黑色，结束。此时红黑树性质全部恢复。 </p><p>② 情况说明：x 是“黑+黑”节点，且 x 是根。 处理方法：什么都不做，结束。此时红黑树性质全部恢复。</p><p> ③ 情况说明：x 是“黑+黑”节点，且 x 不是根。 处理方法：这种情况又可以划分为 4 种子情况。这 4 种子情况如下表所示：</p><p> <img src="/images/Java_heart_dataStructure/clip_image021.gif" alt="img"> </p><p>参考：<a href="https://www.jianshu.com/p/038585421b73" target="_blank" rel="noopener">https://www.jianshu.com/p/038585421b73</a></p><p>代码实现：<a href="https://www.cnblogs.com/skywang12345/p/3624343.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3624343.html</a></p><h2 id="7-B-TREE"><a href="#7-B-TREE" class="headerlink" title="7. B-TREE"></a>7. B-TREE</h2><p>B-tree 又叫平衡多路查找树。一棵 m 阶的 B-tree (m 叉树)的特性如下（其中 ceil(x)是一个取上限的函数）： </p><ol><li><p>树中每个结点至多有 m 个孩子；</p></li><li><p>除根结点和叶子结点外，其它每个结点至少有有 ceil(m / 2)个孩子； </p></li><li><p>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</p></li><li><p>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为 null)； </p></li><li><p>每个非终端结点中包含有 n 个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。 其中：</p></li></ol><ul><li><p>Ki (i=1…n)为关键字，且关键字按顺序排序 K(i-1)&lt; Ki。 </p></li><li><p>Pi 为指向子树根的接点，且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。 </p></li><li><p>关键字的个数 n 必须满足： ceil(m / 2)-1 &lt;= n &lt;= m-1。 </p></li></ul><p><img src="/images/Java_heart_dataStructure/clip_image023.gif" alt="img"> </p><p>一棵 m 阶的 B+tree 和 m 阶的 B-tree 的差异在于： </p><ol><li><p>有 n 棵子树的结点中含有 n 个关键字； (B-tree 是 n 棵子树有 n-1 个关键字) </p></li><li><p>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (B-tree 的叶子节点并没有包括全部需要查找的信息) </p></li><li><p>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(B-tree 的非终节点也包含需要查找的有效信息) </p></li></ol><p><img src="/images/Java_heart_dataStructure/clip_image025.gif" alt="img"> </p><p>参考：<a href="https://www.jianshu.com/p/1ed61b4cca12" target="_blank" rel="noopener">https://www.jianshu.com/p/1ed61b4cca12</a></p><h2 id="8-位图"><a href="#8-位图" class="headerlink" title="8. 位图"></a>8. 位图</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;位图的原理就是用一个 bit 来标识一个数字是否存在，采用一个 bit 来存储一个数据，所以这样可以大大的节省空间。 bitmap 是很常用的数据结构，比如用于 Bloom Filter 中；用于无重复整数的排序等等。bitmap 通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素组成更大的二进制集合。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;参考：<a href="https://www.cnblogs.com/polly333/p/4760275.html" target="_blank" rel="noopener">https://www.cnblogs.com/polly333/p/4760275.html</a></p><h2 id="9-最后"><a href="#9-最后" class="headerlink" title="9. 最后"></a>9. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-栈（stack）&quot;&gt;&lt;a href=&quot;#1-栈（stack）&quot; class=&quot;headerlink&quot; title=&quot;1. 栈（stack）&quot;&gt;&lt;/a&gt;1. 栈（stack）&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶（top）。它是后进先出（LIFO）的。对栈的基本操作只有 push（进栈）和 pop（出栈）两种，前者相当于插入，后者相当于删除最后的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(十七)之Java算法、加密算法、分布式缓存</title>
    <link href="https://quietair.gitee.io/Java_heart_JavaAlgorithm/"/>
    <id>https://quietair.gitee.io/Java_heart_JavaAlgorithm/</id>
    <published>2020-05-31T05:12:08.000Z</published>
    <updated>2020-06-13T04:16:29.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java算法"><a href="#Java算法" class="headerlink" title="Java算法"></a>Java算法</h1><h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。</p><a id="more"></a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hi=array.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">mid=(lo+hi)/<span class="number">2</span>;<span class="comment">//中间位置</span></span><br><span class="line"><span class="keyword">if</span>(array[mid]==a)&#123;</span><br><span class="line"><span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;a)&#123; <span class="comment">//向右查找</span></span><br><span class="line">lo=mid+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">//向左查找</span></span><br><span class="line">hi=mid-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-冒泡排序算法"><a href="#2-冒泡排序算法" class="headerlink" title="2. 冒泡排序算法"></a>2. 冒泡排序算法</h2><p>（1）比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。</p><p>（2）这样对数组的第 0 个数据到 N-1 个数据进行一次遍历后，最大的一个数据就“沉”到数组第 N-1 个位置。 </p><p>（3）N=N-1，如果 N 不为 0 就重复前面二步，否则排序完成。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span> [] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i, j;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;<span class="comment">//表示 n 次排序过程。</span></span><br><span class="line"> <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;n-i; j++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(a[j-<span class="number">1</span>] &gt; a[j])&#123;<span class="comment">//前面的数字大于后面的数字就交换</span></span><br><span class="line"> <span class="comment">//交换 a[j-1]和 a[j]</span></span><br><span class="line"> <span class="keyword">int</span> temp;</span><br><span class="line"> temp = a[j-<span class="number">1</span>];</span><br><span class="line"> a[j-<span class="number">1</span>] = a[j];</span><br><span class="line"> a[j]=temp;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-插入排序算法"><a href="#3-插入排序算法" class="headerlink" title="3. 插入排序算法"></a>3. 插入排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着<u>，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的</u>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函 数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是(n2)。</p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image005.gif" alt="img"> </p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line"> <span class="comment">//插入的数</span></span><br><span class="line"> <span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line"> <span class="comment">//被插入的位置(准备和前一个数比较)</span></span><br><span class="line"> <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line"> <span class="comment">//如果插入的数比被插入的数小</span></span><br><span class="line"> <span class="keyword">while</span>(index&gt;=<span class="number">0</span>&amp;&amp;insertVal&lt;arr[index])&#123;</span><br><span class="line"> <span class="comment">//将把 arr[index] 向后移动</span></span><br><span class="line"> arr[index+<span class="number">1</span>]=arr[index];</span><br><span class="line"> <span class="comment">//让 index 向前移动</span></span><br><span class="line"> index--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//把插入的数放入合适位置</span></span><br><span class="line"> arr[index+<span class="number">1</span>]=insertVal;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-快速排序算法"><a href="#4-快速排序算法" class="headerlink" title="4. 快速排序算法"></a>4. 快速排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;快速排序的原理：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;一次循环：<strong>从后往前比较</strong>，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。<strong>找到这个值之后，又从前往后开始比较</strong>，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到<strong>从前往后的比较索引&gt;从后往前比较的索引</strong>，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> start = low;</span><br><span class="line"> <span class="keyword">int</span> end = high;</span><br><span class="line"> <span class="keyword">int</span> key = a[low];</span><br><span class="line"> <span class="keyword">while</span>(end&gt;start)&#123;</span><br><span class="line"> <span class="comment">//从后往前比较</span></span><br><span class="line"> <span class="keyword">while</span>(end&gt;start&amp;&amp;a[end]&gt;=key)</span><br><span class="line"><span class="comment">//如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</span></span><br><span class="line"> end--;</span><br><span class="line"> <span class="keyword">if</span>(a[end]&lt;=key)&#123;</span><br><span class="line"> <span class="keyword">int</span> temp = a[end];</span><br><span class="line"> a[end] = a[start];</span><br><span class="line"> a[start] = temp;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//从前往后比较</span></span><br><span class="line"> <span class="keyword">while</span>(end&gt;start&amp;&amp;a[start]&lt;=key)</span><br><span class="line"><span class="comment">//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</span></span><br><span class="line"> start++;</span><br><span class="line"> <span class="keyword">if</span>(a[start]&gt;=key)&#123;</span><br><span class="line"> <span class="keyword">int</span> temp = a[start];</span><br><span class="line"> a[start] = a[end];</span><br><span class="line"> a[end] = temp;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的</span></span><br><span class="line"><span class="comment">//值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//递归</span></span><br><span class="line"> <span class="keyword">if</span>(start&gt;low) sort(a,low,start-<span class="number">1</span>);<span class="comment">//左边序列。第一个索引位置到关键值索引-1</span></span><br><span class="line"> <span class="keyword">if</span>(end&lt;high) sort(a,end+<span class="number">1</span>,high);<span class="comment">//右边序列。从关键值索引+1 到最后一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Java_heart_JavaAlgorithm/clip_image007.gif" alt="img"> </p><h2 id="6-希尔排序算法"><a href="#6-希尔排序算法" class="headerlink" title="6. 希尔排序算法"></a>6. 希尔排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 </p><ol><li><p>操作方法： 选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk=1； </p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序； </p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ol><p><img src="/images/Java_heart_JavaAlgorithm/clip_image009.gif" alt="img"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dk = a.length/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>( dk &gt;= <span class="number">1</span> )&#123;</span><br><span class="line"> ShellInsertSort(a, dk);</span><br><span class="line"> dk = dk/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShellInsertSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> dk)</span> </span>&#123;</span><br><span class="line"><span class="comment">//类似插入排序，只是插入排序增量是 1，这里增量是 dk,把 1 换成 dk 就可以了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=dk;i&lt;a.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[i-dk])&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">int</span> x=a[i];<span class="comment">//x 为待插入元素</span></span><br><span class="line">a[i]=a[i-dk];</span><br><span class="line"><span class="keyword">for</span>(j=i-dk; j&gt;=<span class="number">0</span> &amp;&amp; x&lt;a[j];j=j-dk)&#123;</span><br><span class="line"><span class="comment">//通过循环，逐个后移一位找到要插入的位置。</span></span><br><span class="line">a[j+dk]=a[j];</span><br><span class="line">&#125;</span><br><span class="line">a[j+dk]=x;<span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-归并排序算法"><a href="#7-归并排序算法" class="headerlink" title="7. 归并排序算法"></a>7. 归并排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image011.gif" alt="img"> </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span> &#125;;</span><br><span class="line"> print(data);</span><br><span class="line"> mergeSort(data);</span><br><span class="line"> System.out.println(<span class="string">"排序后的数组："</span>);</span><br><span class="line"> print(data);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"> sort(data, <span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> <span class="comment">// 找出中间索引</span></span><br><span class="line"> <span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line"> <span class="comment">// 对左边数组进行递归</span></span><br><span class="line"> sort(data, left, center);</span><br><span class="line"> <span class="comment">// 对右边数组进行递归</span></span><br><span class="line"> sort(data, center + <span class="number">1</span>, right);</span><br><span class="line"> <span class="comment">// 合并</span></span><br><span class="line"> merge(data, left, center, right);</span><br><span class="line"> print(data);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将两个数组进行归并，归并前面 2 个数组已有序，归并后依然有序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * 数组对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * 左数组的第一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> center</span></span><br><span class="line"><span class="comment">     * 左数组的最后一个元素的索引，center+1 是右数组第一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * 右数组最后一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> center, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 临时数组</span></span><br><span class="line"> <span class="keyword">int</span>[] tmpArr = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line"> <span class="comment">// 右数组第一个元素索引</span></span><br><span class="line"> <span class="keyword">int</span> mid = center + <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// third 记录临时数组的索引</span></span><br><span class="line"> <span class="keyword">int</span> third = left;</span><br><span class="line"> <span class="comment">// 缓存左数组第一个元素的索引</span></span><br><span class="line"> <span class="keyword">int</span> tmp = left;</span><br><span class="line"> <span class="keyword">while</span> (left &lt;= center &amp;&amp; mid &lt;= right) &#123;</span><br><span class="line"> <span class="comment">// 从两个数组中取出最小的放入临时数组</span></span><br><span class="line"> <span class="keyword">if</span> (data[left] &lt;= data[mid]) &#123;</span><br><span class="line"> tmpArr[third++] = data[left++];</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> tmpArr[third++] = data[mid++];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 剩余部分依次放入临时数组（实际上两个 while 只会执行其中一个）</span></span><br><span class="line"> <span class="keyword">while</span> (mid &lt;= right) &#123;</span><br><span class="line"> tmpArr[third++] = data[mid++]; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (left &lt;= center) &#123;</span><br><span class="line"> tmpArr[third++] = data[left++];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 将临时数组中的内容拷贝回原数组中</span></span><br><span class="line"> <span class="comment">// （原 left-right 范围的内容被复制回原数组）</span></span><br><span class="line">    <span class="keyword">while</span> (tmp &lt;= right) &#123;</span><br><span class="line"> data[tmp] = tmpArr[tmp++];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            System.out.print(data[i] + <span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="8-桶排序算法"><a href="#8-桶排序算法" class="headerlink" title="8. 桶排序算法"></a>8. 桶排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;桶排序的基本思想是： 把数组 arr 划分为 n 个大小相同子区间（桶），每个子区间各自排序，最后合并 。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出待排序数组中的最大值 max、最小值 min </p><p>2.我们使用 动态数组 ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(maxmin)/arr.length+1</p><p>3.遍历数组 arr，计算每个元素 arr[i] 放的桶 </p><p>4.每个桶各自排序 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">max = Math.max(max, arr[i]);</span><br><span class="line">min = Math.min(min, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建桶</span></span><br><span class="line"><span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将每个元素放入桶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> num = (arr[i] - min) / (arr.length);</span><br><span class="line">bucketArr.get(num).add(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对每个桶进行排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">Collections.sort(bucketArr.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-基数排序算法"><a href="#9-基数排序算法" class="headerlink" title="9. 基数排序算法"></a>9. 基数排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">radixSort</span> </span>&#123;</span><br><span class="line">inta[]=&#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">62</span>,<span class="number">99</span>,<span class="number">98</span>,<span class="number">54</span>,<span class="number">101</span>,<span class="number">56</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">15</span>,<span class="number">35</span>,<span class="number">25</span>,<span class="number">53</span>,<span class="number">51</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">radixSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(a);</span><br><span class="line"><span class="keyword">for</span>(inti=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line"><span class="comment">//首先确定排序的趟数;</span></span><br><span class="line"><span class="keyword">int</span> max=array[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(inti=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[i]&gt;max)&#123;</span><br><span class="line">max=array[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//判断位数;</span></span><br><span class="line"><span class="keyword">while</span>(max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">max/=<span class="number">10</span>;</span><br><span class="line">time++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立 10 个队列;</span></span><br><span class="line">List&lt;ArrayList&gt; queue=newArrayList&lt;ArrayList&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">ArrayList&lt;Integer&gt;queue1=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">queue.add(queue1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行 time 次分配和收集;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;time;i++)&#123;</span><br><span class="line"><span class="comment">//分配数组元素;</span></span><br><span class="line"><span class="keyword">for</span>(intj=<span class="number">0</span>;j&lt;array.length;j++)&#123;</span><br><span class="line"><span class="comment">//得到数字的第 time+1 位数;</span></span><br><span class="line"><span class="keyword">int</span> x=array[j]%(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,i+<span class="number">1</span>)/(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i);</span><br><span class="line">ArrayList&lt;Integer&gt;queue2=queue.get(x);</span><br><span class="line">queue2.add(array[j]);</span><br><span class="line">queue.set(x, queue2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//元素计数器;</span></span><br><span class="line"><span class="comment">//收集队列元素;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line"><span class="keyword">while</span>(queue.get(k).size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">ArrayList&lt;Integer&gt;queue3=queue.get(k);</span><br><span class="line">array[count]=queue3.get(<span class="number">0</span>);</span><br><span class="line">queue3.remove(<span class="number">0</span>);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-剪枝算法"><a href="#10-剪枝算法" class="headerlink" title="10. 剪枝算法"></a>10. 剪枝算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即确定哪些枝条应当舍弃，哪些枝条应当保留的方法。</p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image013.jpg" alt="img"> </p><h2 id="11-回溯算法"><a href="#11-回溯算法" class="headerlink" title="11. 回溯算法"></a>11. 回溯算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 </p><h2 id="12-最短路径算法"><a href="#12-最短路径算法" class="headerlink" title="12. 最短路径算法"></a>12. 最短路径算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径叫做最短路径。解决最短路的问题有以下算法，Dijkstra 算法，Bellman-Ford 算法，Floyd 算法和 SPFA 算法等。 </p><h2 id="13-最大子数组算法"><a href="#13-最大子数组算法" class="headerlink" title="13. 最大子数组算法"></a>13. 最大子数组算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMaxSubDoubleArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> MIN_VALUE = -<span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span>[] work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_work</span><span class="params">(<span class="keyword">double</span>[] a)</span></span>&#123;</span><br><span class="line">work = <span class="keyword">new</span> <span class="keyword">double</span>[a.length - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">work[i - <span class="number">1</span>] = a[i] - a[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(work));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">find</span><span class="params">(<span class="keyword">double</span>[] a)</span></span>&#123;</span><br><span class="line">generate_work(a);</span><br><span class="line">Result res = do_rec_find(<span class="number">0</span>, work.length - <span class="number">1</span>);</span><br><span class="line">res.end++;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Result <span class="title">do_rec_find</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">Result rl = do_rec_find(start, mid);</span><br><span class="line">Result rh = do_rec_find(mid + <span class="number">1</span>, end);</span><br><span class="line">Result rc = do_cross_find(start, mid, end);</span><br><span class="line"><span class="keyword">if</span>(rl.max &gt;= rh.max &amp;&amp; rl.max &gt;= rc.max)&#123;</span><br><span class="line"><span class="keyword">return</span> rl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rh.max &gt;= rl.max &amp;&amp; rh.max &gt;= rc.max)&#123;</span><br><span class="line"><span class="keyword">return</span> rh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rc.max &gt;= rl.max &amp;&amp; rc.max &gt;= rh.max)&#123;</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Result res = <span class="keyword">new</span> Result();</span><br><span class="line">res.start = start;</span><br><span class="line">res.end = start;</span><br><span class="line">res.max = work[start];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Result <span class="title">do_cross_find</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> add = <span class="number">0</span>;</span><br><span class="line">Result res = <span class="keyword">new</span> Result();</span><br><span class="line"><span class="keyword">double</span> maxl = MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &gt;= start; i--)&#123;</span><br><span class="line">add += work[i];</span><br><span class="line"><span class="keyword">if</span>(add &gt; maxl)&#123;</span><br><span class="line">res.start = i;</span><br><span class="line">maxl = add;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> maxh = MIN_VALUE;</span><br><span class="line">add = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= end; i++)&#123;</span><br><span class="line">add += work[i];</span><br><span class="line"><span class="keyword">if</span>(add &gt; maxh)&#123;</span><br><span class="line">res.end = i;</span><br><span class="line">maxh = add;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.max = maxl + maxh;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">double</span>[] a = &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//double[] a = &#123;9,10,8,12,10,6,12,11,9,1&#125;;</span></span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">Result res = find(a);</span><br><span class="line">System.out.println(res.start + <span class="string">" "</span> + res.end + <span class="string">" "</span> + res.max);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-最长公共子序算法"><a href="#14-最长公共子序算法" class="headerlink" title="14. 最长公共子序算法"></a>14. 最长公共子序算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getLCSstring</span><span class="params">(<span class="keyword">char</span>[] str1, <span class="keyword">char</span>[] str2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i, j;</span><br><span class="line">       <span class="keyword">int</span> len1, len2;</span><br><span class="line">       len1 = str1.length;</span><br><span class="line">       len2 = str2.length;</span><br><span class="line">       <span class="keyword">int</span> maxLen = len1 &gt; len2 ? len1 : len2;</span><br><span class="line">       <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[maxLen];</span><br><span class="line">       <span class="keyword">int</span>[] maxIndex = <span class="keyword">new</span> <span class="keyword">int</span>[maxLen];</span><br><span class="line">       <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[maxLen];</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="comment">//生成矩阵</span></span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (j = len1 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">               <span class="keyword">if</span> (str2[i] == str1[j]) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((i == <span class="number">0</span>) || (j == <span class="number">0</span>))</span><br><span class="line">                       c[j] = <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       c[j] = c[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   c[j] = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line"> </span><br><span class="line">               <span class="keyword">if</span> (c[j] &gt; max[<span class="number">0</span>]) &#123;   <span class="comment">//如果是大于那暂时只有一个是最长的,而且要把后面的清0;</span></span><br><span class="line">                   max[<span class="number">0</span>] = c[j];</span><br><span class="line">                   maxIndex[<span class="number">0</span>] = j;</span><br><span class="line"> </span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; maxLen; k++) &#123;</span><br><span class="line">                       max[k] = <span class="number">0</span>;</span><br><span class="line">                       maxIndex[k] = <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[j] == max[<span class="number">0</span>]) &#123;   <span class="comment">//有多个是相同长度的子串</span></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; maxLen; k++) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (max[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                           max[k] = c[j];</span><br><span class="line">                           maxIndex[k] = j;</span><br><span class="line">                           <span class="keyword">break</span>;  <span class="comment">//在后面加一个就要退出循环了</span></span><br><span class="line">                       &#125;</span><br><span class="line"> </span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; maxLen; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (max[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">               StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">               <span class="keyword">for</span> (i = maxIndex[j] - max[j] + <span class="number">1</span>; i &lt;= maxIndex[j]; i++) &#123;</span><br><span class="line">                   sb.append(str1[i]);</span><br><span class="line">               &#125;</span><br><span class="line">               String lcs = sb.toString();</span><br><span class="line">               list.add(lcs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">       String str1 = <span class="keyword">new</span> String(<span class="string">"adbba12345"</span>);</span><br><span class="line">       String str2 = <span class="keyword">new</span> String(<span class="string">"adbbf1234sa"</span>);</span><br><span class="line">       List&lt;String&gt; list = getLCSstring(str1.toCharArray(), str2.toCharArray());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"个公共子串:"</span> + list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       str1 = <span class="keyword">new</span> String(<span class="string">"adbab1234"</span>);</span><br><span class="line">       str2 = <span class="keyword">new</span> String(<span class="string">"adbbf123s4a"</span>);</span><br><span class="line">       list = getLCSstring(str1.toCharArray(), str2.toCharArray());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"个公共子串:"</span> + list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="15-最小生成树算法"><a href="#15-最小生成树算法" class="headerlink" title="15. 最小生成树算法"></a>15. 最小生成树算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;现在假设有一个很实际的问题：我们要在 n 个城市中建立一个通信网络，则连通这 n 个城市需要布置 n-1 一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？ </p><p>&nbsp;&nbsp;&nbsp;&nbsp;于是我们就可以引入连通图来解决我们遇到的问题，n 个城市就是图上的 n 个顶点，然后，边表示两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有n个顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：MST 性质（假设 N=(V,{E})是一个连通网，U 是顶点集 V 的一个非空子集，如果（u，v）是一条具有最小权值的边，其中 u 属于U，v 属于V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使用 MST 性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。 </p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image015.gif" alt="img"> </p><h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="16-AES"><a href="#16-AES" class="headerlink" title="16. AES"></a>16. AES</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥，具体的加密流程如下图：</p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image002.jpg" alt="img"> </p><h2 id="17-RSA"><a href="#17-RSA" class="headerlink" title="17. RSA"></a>17. RSA</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;RSA 加密算法是一种典型的非对称加密算法，它基于大数的因式分解数学难题，它也是应用最广泛的非对称加密算法。 非对称加密是通过两个密钥（公钥-私钥）来实现对数据的加密和解密的。公钥用于加密，私钥用于解密。 </p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image004.gif" alt="img"> </p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image005.jpg" alt="img"> </p><h2 id="18-CRC"><a href="#18-CRC" class="headerlink" title="18. CRC"></a>18. CRC</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;循环冗余校验(Cyclic Redundancy Check, CRC)是一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。</p><h2 id="19-MD5"><a href="#19-MD5" class="headerlink" title="19. MD5"></a>19. MD5</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;MD5 常常作为文件的签名出现，我们在下载文件的时候，常常会看到文件页面上附带一个扩展名为.MD5 的文本或者一行字符，这行字符就是就是把整个文件当作原数据通过 MD5 计算后的值，我们下载文件后，可以用检查文件 MD5 信息的软件对下载到的文件在进行一次计算。两次结果对比就可以确保下载到文件的准确性。 另一种常见用途就是网站敏感信息加密，比如用户名密码，支付签名等等。随着 https 技术的普及，现在的网站广泛采用前台明文传输到后台，MD5 加密（使用偏移量）的方式保护敏感数据保护站点和数据安全。</p><h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><h2 id="20-缓存雪崩"><a href="#20-缓存雪崩" class="headerlink" title="20. 缓存雪崩"></a>20. 缓存雪崩</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了，而对数据库 CPU 和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。一般有三种处理办法： </p><ol><li><p>一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。 </p></li><li><p>给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。</p></li><li><p>为 key 设置不同的缓存失效时间。</p></li></ol><h2 id="21-缓存穿透"><a href="#21-缓存穿透" class="headerlink" title="21. 缓存穿透"></a>21. 缓存穿透</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法，<u>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。</u></p><h2 id="22-缓存预热"><a href="#22-缓存预热" class="headerlink" title="22. 缓存预热"></a>22. 缓存预热</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><h2 id="23-缓存更新"><a href="#23-缓存更新" class="headerlink" title="23. 缓存更新"></a>23. 缓存更新</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;缓存更新除了缓存服务器自带的缓存失效策略之外（Redis 默认的有 6 中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><p>（1）定时去清理过期的缓存；</p><p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><h2 id="24-缓存降级"><a href="#24-缓存降级" class="headerlink" title="24. 缓存降级"></a>24. 缓存降级</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java算法&quot;&gt;&lt;a href=&quot;#Java算法&quot; class=&quot;headerlink&quot; title=&quot;Java算法&quot;&gt;&lt;/a&gt;Java算法&lt;/h1&gt;&lt;h2 id=&quot;1-二分查找&quot;&gt;&lt;a href=&quot;#1-二分查找&quot; class=&quot;headerlink&quot; title=&quot;1. 二分查找&quot;&gt;&lt;/a&gt;1. 二分查找&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(十六)之一致性算法</title>
    <link href="https://quietair.gitee.io/Java_heart_Algorithm/"/>
    <id>https://quietair.gitee.io/Java_heart_Algorithm/</id>
    <published>2020-05-24T04:43:31.000Z</published>
    <updated>2020-05-25T05:58:06.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Paxos"><a href="#1-Paxos" class="headerlink" title="1. Paxos"></a>1. Paxos</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。zookeeper 使用的 zab 算法是该算法的一个实现。 在 Paxos 算法中，有三种角色：Proposer，Acceptor，Learners </p><a id="more"></a><p><strong>Paxos</strong> 三种角色：<strong>Proposer</strong>，<strong>Acceptor</strong>，<strong>Learners</strong> </p><p><strong>Proposer</strong>： </p><p>只要 Proposer 发的提案被半数以上 Acceptor 接受，Proposer 就认为该提案里的 value 被选定了。 </p><p><strong>Acceptor</strong>： </p><p>只要 Acceptor 接受了某个提案，Acceptor 就认为该提案里的 value 被选定了。 </p><p><strong>Learner</strong>： </p><p>Acceptor 告诉 Learner 哪个 value 被选定，Learner 就认为那个 value 被选定。 </p><p><strong>Paxos</strong> 算法分为两个阶段。具体如下： </p><p><u>阶段一</u>（准<strong>leader</strong>确定 ）： </p><p>(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。 </p><p>(b) 如果一个 Acceptor 收到一个编号为 N 的 Prepare 请求，且 N 大于该 Acceptor 已经响应过的所有 Prepare 请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给 Proposer，同时该 Acceptor 承诺不再接受任何编号小于 N 的提案。 </p><p><u>阶段二</u>（<strong>leader</strong>确认）： </p><p>(a) 如果 Proposer 收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应，那么它就会发送一个针对[N,V]提案的 Accept 请求给半数以上的 Acceptor。注意：V 就是收到的响应中编号最大的提案的 value，如果响应中不包含任何提案，那么 V 就由 Proposer 自己决定。 </p><p>(b) 如果 Acceptor 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号大于 N 的 Prepare 请求做出过响应，它就接受该提案。 </p><h2 id="2-Zab"><a href="#2-Zab" class="headerlink" title="2. Zab"></a>2. Zab</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;ZAB( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议）协议包括两种基本的模式：崩溃恢复和消息广播</p><ol><li><p>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断崩溃退出与重启等异常情况时，ZAB 就会进入恢复模式并选举产生新的 Leader 服务器。 </p></li><li><p>当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出崩溃恢复模式，进入消息广播模式。</p></li><li><p>当有新的服务器加入到集群中去，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器会自动进入数据恢复模式，找到 Leader 服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。 以上其实大致经历了三个步骤： </p></li></ol><p>1、<strong>崩溃恢复：主要就是Leader选举过程</strong> </p><p>2、<strong>数据同步：Leader服务器与其他服务器进行数据同步</strong> </p><p>3、<strong>消息广播：Leader服务器将数据发送给其他服务器 说明：zookeeper 章节对该协议有详细描述</strong>。 </p><h2 id="3-Raft"><a href="#3-Raft" class="headerlink" title="3. Raft"></a>3. Raft</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;与 Paxos 不同 Raft 强调的是易懂（Understandability），Raft 和 Paxos 一样只要保证 n/2+1 节点正常就能够提供服务；raft 把算法流程分为三个子问题：选举（Leader election）、日志复制（Log replication）、安全性（Safety）三个子问题。 </p><h3 id="3-1-角色"><a href="#3-1-角色" class="headerlink" title="3.1. 角色"></a>3.1. 角色</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Raft 把集群中的节点分为三种状态：<strong>Leader、 Follower 、Candidate</strong>，理所当然每种状态负责的任务也是不一样的，Raft 运行时提供服务的时候只存在 Leader 与 Follower 两种状态； </p><p><strong>Leader（领导者-日志管理）</strong> </p><p>负责日志的同步管理，处理来自客户端的请求，与 Follower 保持这 heartBeat 的联系； </p><p><strong>Follower （追随者-日志同步）</strong> </p><p>刚启动时所有节点为Follower状态，响应Leader的日志同步请求，响应Candidate的请求，</p><p>把请求到 Follower 的事务转发给 Leader； </p><p><strong>Candidate（候选者-负责选票）</strong> </p><p>负责选举投票，Raft 刚启动时由一个节点从 Follower 转为 Candidate 发起选举，选举出</p><p>Leader 后从 Candidate 转为 Leader 状态； </p><h3 id="3-2-Term（任期）"><a href="#3-2-Term（任期）" class="headerlink" title="3.2. Term（任期）"></a>3.2. Term（任期）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Raft 中使用了一个可以理解为周期（第几届、任期）的概念，用 Term 作为一个周期，每个 Term 都是一个连续递增的编号，每一轮选举都是一个 Term 周期，在一个 Term 中只能产生一个 Leader；当某节点收到的请求中 Term 比当前 Term 小时则拒绝该请求。 </p><h3 id="3-3-选举（Election）"><a href="#3-3-选举（Election）" class="headerlink" title="3.3. 选举（Election）"></a>3.3. 选举（Election）</h3><p><strong>选举定时器</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Raft 的选举由定时器来触发，<u>每个节点的选举定时器时间都是不一样的</u>，开始时状态都为Follower 某个节点定时器触发选举后 Term 递增，状态由 Follower 转为 Candidate，向其他节点发起 RequestVote RPC 请求，这时候有三种可能的情况发生：</p><p> 1：该RequestVote请求接收到n/2+1（过半数）个节点的投票，从Candidate 转为Leader，向其他节点发送 heartBeat 以保持 Leader 的正常运转。 </p><p> 2：在此期间如果收到其他节点发送过来的 AppendEntries RPC 请求，如该节点的 Term 大则当前节点转为 Follower，否则保持 Candidate 拒绝该请求。 </p><p> 3：Election timeout 发生则 Term 递增，重新发起选举 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在一个 Term 期间每个节点只能投票一次，<u>所以当有多个 Candidate 存在时就会出现每个 Candidate 发起的选举都存在接收到的投票数都不过半的问题，这时每个 Candidate 都将 Term 递增、重启定时器并重新发起选举，由于每个节点中定时器的时间都是随机的，所以就不会多次存在有多个 Candidate 同时发起投票的问题</u>。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。 </p><h3 id="3-4-安全性（Safety）"><a href="#3-4-安全性（Safety）" class="headerlink" title="3.4. 安全性（Safety）"></a>3.4. 安全性（Safety）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;安全性是用于保证每个节点都执行相同序列的安全机制如当某个 <u>Follower 在当前 Leader commit Log 时变得不可用了，稍后可能该 Follower 又会倍选举为 Leader，这时新 Leader 可能会用新的 Log 覆盖先前已 committed 的 Log</u>，这就是导致节点执行不同序列；Safety 就是用于保证选举出来的 Leader 一定包含先前 commited Log 的机制；  </p><p>选举安全性（Election Safety）：每个 Term 只能选举出一个 Leader </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Leader 完整性（Leader Completeness）：这里所说的<strong>完整性是指 Leader 日志的完整性</strong>， Raft 在选举阶段就使用 Term 的判断用于保证完整性：当请求投票的该 Candidate 的 Term 较大或 Term 相同 Index 更大则投票，该节点将容易变成 leader。 </p><h3 id="3-5-raft-协议和-zab-协议区别"><a href="#3-5-raft-协议和-zab-协议区别" class="headerlink" title="3.5. raft 协议和 zab 协议区别"></a>3.5. raft 协议和 zab 协议区别</h3><p><strong>相同点</strong> </p><ul><li>采用 quorum 来确定整个系统的一致性,这个 quorum 一般实现是集群中半数以上的服务器, §    zookeeper 里还提供了带权重的 quorum 实现. </li><li>都由 leader 来发起写操作. </li><li>都采用心跳检测存活性 </li><li>leader election 都采用先到先得的投票方式 </li></ul><p><strong>不同点</strong> </p><ul><li>zab 用的是 epoch 和 count 的组合来唯一表示一个值, 而 raft 用的是 term 和 index </li><li>zab 的 follower 在投票给一个 leader 之前必须和 leader 的日志达成一致,而 raft 的 follower 则简单地说是谁的 term 高就投票给谁 </li><li>raft 协议的心跳是从 leader 到 follower, 而 zab 协议则相反 </li><li>raft 协议数据只有单向地从 leader 到 follower(成为 leader 的条件之一就是拥有最新的 log), 而 zab 协议在 discovery 阶段, 一个 prospective leader 需要将自己的 log 更新为 quorum 里面最新的 log,然后才好在 synchronization 阶段将 quorum 里的其他机器的 log 都同步到一致. </li></ul><h2 id="4-NWR"><a href="#4-NWR" class="headerlink" title="4. NWR"></a>4. NWR</h2><p><strong>N：在分布式存储系统中，有多少份备份数据</strong> </p><p><strong>W：代表一次成功的更新操作要求至少有W份数据写入成功</strong> </p><p><strong>R： 代表一次成功的读数据操作要求至少有R份数据成功读取</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;NWR值的不同组合会产生不同的一致性效果，当W+R&gt;N的时候，整个系统对于客户端来讲能保证强一致性。而如果 R+W&lt;=N，则无法保证数据的强一致性。以常见的 N=3、W=2、R=2 为例： </p><p>&nbsp;&nbsp;&nbsp;&nbsp;N=3，表示，任何一个对象都必须有三个副本（Replica），W=2 表示，对数据的修改操作（Write）只需要在 3 个 Replica 中的 2 个上面完成就返回，R=2 表示，从三个对象中要读取到 2 个数据对象，才能返回。 </p><p><img src="/images/Java_heart_Algorithm/clip_image003.gif" alt="img"> </p><h2 id="5-Gossip"><a href="#5-Gossip" class="headerlink" title="5. Gossip"></a>5. Gossip</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Gossip 算法又被称为反熵（Anti-Entropy），熵是物理学上的一个概念，<strong>代表杂乱无章，而反熵就是在杂乱无章中寻求一致</strong>，这充分说明了 Gossip 的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。</p><h2 id="6-一致性-Hash"><a href="#6-一致性-Hash" class="headerlink" title="6. 一致性 Hash"></a>6. 一致性 Hash</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; 一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。 Memcached client 也选择这种算法，解决将 key-value 均匀分配到众多 Memcached server 上的问题。它可以取代传统的取模操作，解决了取模操作无法应对增删 Memcached Server 的问题</p><p>(增删 server 会导致同一个 key,在 get 操作时分配不到数据真正存储的 server，命中率会急剧下降)。 </p><h3 id="6-1-一致性-Hash-特性"><a href="#6-1-一致性-Hash-特性" class="headerlink" title="6.1. 一致性 Hash 特性"></a>6.1. 一致性 Hash 特性</h3><ul><li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</li><li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。容易看到，上面的简单求余算法hash(object)%N 难以满足单调性要求。</li><li>平滑性(Smoothness)：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</li></ul><h3 id="6-2-一致性-Hash-原理"><a href="#6-2-一致性-Hash-原理" class="headerlink" title="6.2. 一致性 Hash 原理"></a>6.2. 一致性 Hash 原理</h3><p><strong>1、建构环形 hash 空间：</strong> </p><ol><li>考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环。 </li></ol><p><strong>2、把需要缓存的内容(对象)映射到 hash 空间</strong> </p><ol start="2"><li>接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分布 </li></ol><p><strong>3、把服务器(节点)\映射到 hash 空间</strong> </p><ol start="3"><li>Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash 算法。一般的方法可以使用 服务器(节点) 机器的 IP 地址或者机器名作为 hash 输入。 </li></ol><p><strong>4、把对象映射到服务节点</strong> </p><ol start="4"><li>现在服务节点和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，首先确定对象 hash 值在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</li></ol><p><img src="/images/Java_heart_Algorithm/clip_image005.gif" alt="img"> </p><p><strong>考察 cache 的变动</strong> </p><ol start="5"><li>通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时， cache 会失效。 </li></ol><ul><li><strong>移除 cache</strong>：考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象。 </li><li><strong>添加 cache</strong>：再考虑添加一台新的 cache D 的情况，这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache 之间的对象，将这些对象重新映射到 cache D 上即可。 </li></ul><p><strong>虚拟节点</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义： </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>虚拟节点（ virtual node ）是实际节点在 hash 空间的复制品（ replica ）</u>，一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;仍以仅部署 cache A 和 cache C 的情况为例。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A； cache C1, cache C2 代表了 cache C 。此时，对象到“虚拟节点”的映射关系为： </p><p>objec1-&gt;cache A2 ； objec2-&gt;cache A1 ； objec3-&gt;cache C1 ； objec4-&gt;cache C2 ； </p><p>因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。 </p><p>引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系如下图 所示。 </p><p><img src="/images/Java_heart_Algorithm/clip_image007.gif" alt="img"> </p><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7. 最后"></a>7. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Paxos&quot;&gt;&lt;a href=&quot;#1-Paxos&quot; class=&quot;headerlink&quot; title=&quot;1. Paxos&quot;&gt;&lt;/a&gt;1. Paxos&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。zookeeper 使用的 zab 算法是该算法的一个实现。 在 Paxos 算法中，有三种角色：Proposer，Acceptor，Learners &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(十五)之数据库</title>
    <link href="https://quietair.gitee.io/Java_heart_noSql/"/>
    <id>https://quietair.gitee.io/Java_heart_noSql/</id>
    <published>2020-05-16T07:22:49.000Z</published>
    <updated>2020-05-16T07:43:32.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1. 存储引擎"></a>1. 存储引擎</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1. 概念"></a>1.1. 概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。存储引擎主要有： </p><ol><li>MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。 </li></ol><a id="more"></a><h3 id="1-2-InnoDB（B-树）"><a href="#1-2-InnoDB（B-树）" class="headerlink" title="1.2. InnoDB（B+树）"></a>1.2. InnoDB（B+树）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。 </p><p><img src="/images/Java_heart_noSql/clip_image003.gif" alt="img"> </p><p>适用场景： </p><p>1）经常更新的表，适合处理多重并发的更新请求。 </p><p>2）支持事务。 </p><p>3）可以从灾难中恢复（通过 bin-log 日志等）。 </p><p>4）外键约束。只有他支持外键。 </p><p>5）支持自动增加列属性 auto_increment。 </p><h3 id="1-3-TokuDB（Fractal-Tree-节点带数据）"><a href="#1-3-TokuDB（Fractal-Tree-节点带数据）" class="headerlink" title="1.3. TokuDB（Fractal Tree-节点带数据）"></a>1.3. TokuDB（Fractal Tree-节点带数据）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;TokuDB 底层存储结构为 Fractal Tree,Fractal Tree 的结构与 B+树有些类似, 在 Fractal Tree 中，<strong>每一个 child 指针除了需要指向一个 child 节点外，还会带有一个 Message Buffer ，这个 Message Buffer 是一个 FIFO 的队列，用来缓存更新操作</strong>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。</p><p><img src="/images/Java_heart_noSql/clip_image005.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree 在事务实现上有优势。 他主要适用于访问频率不高的数据或历史数据归档。</p><h3 id="1-4-MyIASM"><a href="#1-4-MyIASM" class="headerlink" title="1.4. MyIASM"></a>1.4. MyIASM</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;ISAM 执行<strong>读取操作的速度很快</strong>，而且不占用大量的内存和存储资源。在设计之初就预想数据组织成有固定长度的记录，按顺序存储的。—ISAM 是一种静态索引结构。 </p><p><strong>缺点是它不 支持事务处理</strong>。 </p><h3 id="1-5-Memory"><a href="#1-5-Memory" class="headerlink" title="1.5. Memory"></a>1.5. Memory</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个磁盘文件。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用 HASH 索引。但是一旦服务关闭，表中的数据就会丢失掉。 <strong>Memory 同时支持散列索引和 B 树索引，B树索引可以使用部分查询和通配查询</strong>，也可以使用&lt;,&gt;和&gt;=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。</p><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,顺序查找,二分查找,二叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree） </p><h3 id="2-1-常见索引原则有"><a href="#2-1-常见索引原则有" class="headerlink" title="2.1. 常见索引原则有"></a>2.1. 常见索引原则有</h3><p><strong>1、选择唯一性索引</strong> </p><p>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。 </p><p><strong>2、为经常需要排序、分组和联合操作的字段建立索引：</strong> </p><p><strong>3、为常作为查询条件的字段建立索引。</strong> </p><p><strong>4、限制索引的数目：</strong> </p><p>越多的索引，会使更新表变得很浪费时间。 </p><p><strong>尽量使用数据量少的索引</strong> </p><p>5、如果索引的值很长，那么查询的速度会受到影响。 </p><p><strong>尽量使用前缀来索引</strong> </p><p>6、如果索引字段的值很长，最好使用值的前缀来索引。 </p><p><strong>7、删除不再使用或者很少使用的索引</strong> </p><p><strong>8、最左前缀匹配原则，非常重要的原则。</strong> </p><p><strong>9、尽量选择区分度高的列作为索引</strong> </p><p>区分度的公式是表示字段不重复的比例 </p><p><strong>10、索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。</strong> </p><p><strong>11、尽量的扩展索引，不要新建索引。</strong> </p><h2 id="3-数据库三范式"><a href="#3-数据库三范式" class="headerlink" title="3. 数据库三范式"></a>3. 数据库三范式</h2><p>范式是具有最小冗余的表结构。3 范式具体如下： </p><h3 id="3-1-第一范式-1st-NF－列都是不可再分"><a href="#3-1-第一范式-1st-NF－列都是不可再分" class="headerlink" title="3.1. 第一范式 (1st NF－列都是不可再分)"></a>3.1. 第一范式 (1st NF－列都是不可再分)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第一范式的目标是确保每列的原子性:如果<strong>每列都是不可再分</strong>的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF） </p><p><img src="/images/Java_heart_noSql/clip_image007.jpg" alt="img"> </p><h3 id="3-2-第二范式-2nd-NF－每个表只描述一件事情"><a href="#3-2-第二范式-2nd-NF－每个表只描述一件事情" class="headerlink" title="3.2. 第二范式 (2nd NF－每个表只描述一件事情)"></a>3.2. 第二范式 (2nd NF－每个表只描述一件事情)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 <strong>第二范式要求每个表只描述一件事情</strong>。 </p><p><img src="/images/Java_heart_noSql/clip_image009.jpg" alt="img"> </p><h3 id="3-3-第三范式-3rd-NF－-不存在对非主键列的传递依赖"><a href="#3-3-第三范式-3rd-NF－-不存在对非主键列的传递依赖" class="headerlink" title="3.3. 第三范式 (3rd NF－ 不存在对非主键列的传递依赖)"></a>3.3. 第三范式 (3rd NF－ 不存在对非主键列的传递依赖)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号。</p><p><img src="/images/Java_heart_noSql/clip_image011.gif" alt="img"> </p><h2 id="4-数据库是事务"><a href="#4-数据库是事务" class="headerlink" title="4. 数据库是事务"></a>4. 数据库是事务</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元 </p><p>事务必须具备以下四个属性，简称 ACID 属性： </p><p><strong>原子性（Atomicity）</strong> </p><ol><li>事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。</li></ol><p><strong>一致性（Consistency）</strong> </p><ol start="2"><li>当事务完成时，数据必须处于一致状态。 </li></ol><p><strong>隔离性（Isolation）</strong> </p><ol start="3"><li>对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。</li></ol><p><strong>永久性（Durability）</strong> </p><ol start="4"><li>事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。 </li></ol><h2 id="5-存储过程-特定功能的-SQL-语句集"><a href="#5-存储过程-特定功能的-SQL-语句集" class="headerlink" title="5. 存储过程 (特定功能的 SQL 语句集)"></a>5. 存储过程 (特定功能的 SQL 语句集)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。</p><p><strong>存储过程优化思路：</strong> </p><ol><li><p>尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。</p></li><li><p>中间结果存放于临时表，加索引。 </p></li><li><p>少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次读取。 </p></li><li><p>事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。 </p></li><li><p>使用 try-catch 处理错误异常。</p></li><li><p>查找语句尽量不要放在循环内。 </p></li></ol><h2 id="6-触发器-一段能自动执行的程序"><a href="#6-触发器-一段能自动执行的程序" class="headerlink" title="6. 触发器 (一段能自动执行的程序)"></a>6. 触发器 (一段能自动执行的程序)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：<strong>触发器是当对某一个表进行操作时触发</strong>。诸如：update、insert、delete 这些操作的时候，系统会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类：DML 触发器和 DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有 create、 alter、drop 语句。 </p><h2 id="7-数据库并发策略"><a href="#7-数据库并发策略" class="headerlink" title="7. 数据库并发策略"></a>7. 数据库并发策略</h2><p>并发控制一般采用三种方法，分别是<strong>乐观锁和悲观锁以及时间戳</strong>。 </p><h3 id="7-1-乐观锁"><a href="#7-1-乐观锁" class="headerlink" title="7.1. 乐观锁"></a>7.1. 乐观锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。</p><h3 id="7-2-悲观锁"><a href="#7-2-悲观锁" class="headerlink" title="7.2. 悲观锁"></a>7.2. 悲观锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是<strong>自己修改某条数据的时候，不允许别人读取该数据</strong>，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</p><h3 id="7-3-时间戳"><a href="#7-3-时间戳" class="headerlink" title="7.3. 时间戳"></a>7.3. 时间戳</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，<strong>每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存</strong>，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量， 以上悲观锁所说的加“锁”，其实分为几种锁，分别是：<strong>排它锁（写锁）和共享锁（读锁）</strong>。 </p><h2 id="8-数据库锁"><a href="#8-数据库锁" class="headerlink" title="8. 数据库锁"></a>8. 数据库锁</h2><h3 id="8-1-行级锁"><a href="#8-1-行级锁" class="headerlink" title="8.1. 行级锁"></a>8.1. 行级锁</h3><p><strong>行级锁是一种排他锁，防止其他事务修改此行</strong>；在使用以下语句时，Oracle 会自动应用行级锁： </p><ol><li><p>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT]; </p></li><li><p>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新 </p></li><li><p>使用 COMMIT 或 ROLLBACK 语句释放锁。 </p></li></ol><h3 id="8-2-表级锁"><a href="#8-2-表级锁" class="headerlink" title="8.2. 表级锁"></a>8.2. 表级锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 </p><h3 id="8-3-页级锁"><a href="#8-3-页级锁" class="headerlink" title="8.3. 页级锁"></a>8.3. 页级锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁 </p><h2 id="9-基于-Redis-分布式锁"><a href="#9-基于-Redis-分布式锁" class="headerlink" title="9. 基于 Redis 分布式锁"></a>9. 基于 Redis 分布式锁</h2><ol><li><p><strong>获取锁的时候，使用 setnx</strong>（SETNX key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value 值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁。 </p></li><li><p>获取锁的时候调用 setnx，<strong>如果返回 0，则该锁正在被别人使用，返回 1 则成功获取锁</strong>。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p></li><li><p>释放锁的时候，通过 UUID <strong>判断是不是该锁</strong>，若是该锁，<strong>则执行 delete 进行锁释放</strong>。 </p></li></ol><h2 id="10-分区分表"><a href="#10-分区分表" class="headerlink" title="10. 分区分表"></a>10. 分区分表</h2><p>分库分表有垂直切分和水平切分两种。 </p><p><strong>垂直切分 (按照功能模块)</strong></p><ul><li><u>将表按照功能模块</u>、关系密切程度划分出来，<u>部署到不同的库上</u>。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。 </li></ul><p><img src="/images/Java_heart_noSql/clip_image013.gif" alt="img"> </p><p><strong>水平切分 (按照规则划分存储)</strong></p><ul><li>当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上。 </li></ul><p><img src="/images/Java_heart_noSql/clip_image015.gif" alt="img"> </p><h2 id="11-两阶段提交协议"><a href="#11-两阶段提交协议" class="headerlink" title="11. 两阶段提交协议"></a>11. 两阶段提交协议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。 </p><p> &nbsp;&nbsp;&nbsp;&nbsp;XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，<u>为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)</u>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的 ACID 特性，<u>需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)</u>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><h3 id="11-1-准备阶段"><a href="#11-1-准备阶段" class="headerlink" title="11.1. 准备阶段"></a>11.1. 准备阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;事务协调者(事务管理器)给每个参与者(资源管理器)<strong>发送 Prepare 消息</strong>，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，<strong>写本地的 redo 和 undo 日志</strong>，但不提交，到达一种“万事俱备，只欠东风”的状态。 </p><h3 id="11-2-提交阶段"><a href="#11-2-提交阶段" class="headerlink" title="11.2. 提交阶段"></a>11.2. 提交阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) </p><h3 id="11-3-缺点"><a href="#11-3-缺点" class="headerlink" title="11.3. 缺点"></a>11.3. 缺点</h3><p><strong>同步阻塞问题</strong> </p><p>1、 执行过程中，所有参与节点都是事务阻塞型的。 </p><p><strong>单点故障</strong> </p><p>2、 由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。 </p><p><strong>数据不一致（脑裂问题）</strong> </p><p>3、 在二阶段提交的阶段二中，当协调者向参与者<u>发送 commit 请求之后，发生了局部网络异常</u>或者在发送 commit 请求过程中协调者发生了故障，导致只有一部分参与者接受到了 commit 请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。 </p><p><strong>二阶段无法解决的问题（数据状态不确定）</strong> </p><p>4、 协调者再发出 commit 消息之后宕机，<u>而唯一接收到这条消息的参与者同时也宕机了</u>。那么即使协调者通过选举协议产生了新的协调者，<u>这条事务的状态也是不确定的，没人知道事务是否被已经提交</u>。 </p><h2 id="12-三阶段提交协议"><a href="#12-三阶段提交协议" class="headerlink" title="12. 三阶段提交协议"></a>12. 三阶段提交协议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;三 阶 段 提 交 （ Three-phase commit ） ， 也 叫 三 阶 段 提 交 协 议 （ Three-phase commit protocol），是二阶段提交（2PC）的改进版本。 </p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。 </p><p>2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，<strong>3PC 把 2PC 的准备阶段再次一分为二</strong>，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。 </p><h3 id="12-1-CanCommit-阶段"><a href="#12-1-CanCommit-阶段" class="headerlink" title="12.1. CanCommit 阶段"></a>12.1. CanCommit 阶段</h3><p>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。 </p><h3 id="12-2-PreCommit-阶段"><a href="#12-2-PreCommit-阶段" class="headerlink" title="12.2. PreCommit 阶段"></a>12.2. PreCommit 阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;协调者根据参与者的反应情况来决定是否可以继续进行，有以下两种可能。假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><h3 id="12-3-doCommit-阶段"><a href="#12-3-doCommit-阶段" class="headerlink" title="12.3. doCommit 阶段"></a>12.3. doCommit 阶段</h3><p>该阶段进行真正的事务提交，主要包含:</p><ol><li><p>协调这发送提交请求 </p></li><li><p>参与者提交事务 </p></li><li><p>参与者响应反馈（ 事务提交完之后，向协调者发送 Ack 响应。）</p></li><li><p>协调者确定完成事务。</p></li></ol><h2 id="13-柔性事务"><a href="#13-柔性事务" class="headerlink" title="13. 柔性事务"></a>13. 柔性事务</h2><h3 id="13-1-柔性事务"><a href="#13-1-柔性事务" class="headerlink" title="13.1. 柔性事务"></a>13.1. 柔性事务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。 </p><p>通常所说的柔性事务分为：<strong>两阶段型、补偿型、异步确保型、最大努力通知型</strong>几种。 </p><p><strong>两阶段型</strong> </p><p>1、 就是<u>分布式事务两阶段提交，对应技术上的 XA、JTA/JTS</u>。这是分布式环境下事务处理的典型模式。 </p><p><strong>补偿型</strong> </p><p>2、 TCC 型事务（Try/Confirm/Cancel）可以归为补偿型。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，服务器 B 参与事务，<u>服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行顺利，则事务 B 也提交，整个事务就算完成</u>。但是<u>如果事务 B 执行失败，事务 B 本身回滚，这时事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢复到未执行前事务 A 的状态</u>。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是提高了 long-running 事务的可用性。 </p><p><img src="/images/Java_heart_noSql/clip_image017.jpg" alt="img"> </p><p><strong>异步确保型</strong> </p><p>3、 通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响。 </p><p><img src="/images/Java_heart_noSql/clip_image019.gif" alt="img"> </p><p><strong>最大努力通知型（多次尝试）</strong> </p><p>4、 这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由 MQ Server 投递到消费者之后, <u>允许在达到最大重试次数之后正常结束事务</u>。</p><h2 id="14-CAP"><a href="#14-CAP" class="headerlink" title="14. CAP"></a>14. CAP</h2><p>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability</p><p>（可用性）、Partition tolerance（分区容错性），三者不可得兼。 </p><p><strong>一致性（C）：</strong> </p><ol><li>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li></ol><p><strong>可用性（A）：</strong> </p><ol start="2"><li>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li></ol><p><strong>分区容忍性（P）：</strong></p><ol start="3"><li>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。 </li></ol><h2 id="15-最后"><a href="#15-最后" class="headerlink" title="15. 最后"></a>15. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-存储引擎&quot;&gt;&lt;a href=&quot;#1-存储引擎&quot; class=&quot;headerlink&quot; title=&quot;1. 存储引擎&quot;&gt;&lt;/a&gt;1. 存储引擎&lt;/h2&gt;&lt;h3 id=&quot;1-1-概念&quot;&gt;&lt;a href=&quot;#1-1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.1. 概念&quot;&gt;&lt;/a&gt;1.1. 概念&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。存储引擎主要有： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。 &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(十四)之负载均衡</title>
    <link href="https://quietair.gitee.io/Java_heart_LoadBalance/"/>
    <id>https://quietair.gitee.io/Java_heart_LoadBalance/</id>
    <published>2020-05-09T09:54:14.000Z</published>
    <updated>2020-05-09T10:07:46.675Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展<a href="https://baike.baidu.com/item/网络设备" target="_blank" rel="noopener">网络设备</a><a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">和</a><a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">服务器</a><a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">的</a>带宽、增加<a href="https://baike.baidu.com/item/吞吐量" target="_blank" rel="noopener">吞吐量</a><a href="https://baike.baidu.com/item/吞吐量" target="_blank" rel="noopener">、</a>加强网络数据处理能力、提高网络的灵活性和可用性。</p><a id="more"></a><h2 id="1-四层负载均衡-vs七层负载均衡"><a href="#1-四层负载均衡-vs七层负载均衡" class="headerlink" title="1. 四层负载均衡 vs七层负载均衡"></a>1. 四层负载均衡 vs七层负载均衡</h2><p><img src="/images%5CJava_heart_LoadBalance%5Cclip_image003.gif" alt="img"> </p><h3 id="1-1-四层负载均衡（目标地址和端口交换）"><a href="#1-1-四层负载均衡（目标地址和端口交换）" class="headerlink" title="1.1. 四层负载均衡（目标地址和端口交换）"></a>1.1. 四层负载均衡（目标地址和端口交换）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;以常见的 TCP 为例，<u>负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标 IP 地址进行修改(改为后端服务器 IP），直接转发给该服务器</u>。TCP 的连接建立，即<strong>三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作</strong>。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。实现四层负载均衡的软件有：</p><ul><li>F5：硬件负载均衡器，功能很好，但是成本很高。 </li><li>lvs：重量级的四层负载软件。 </li><li>nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活。 </li><li>haproxy：模拟四层转发，较灵活。 </li></ul><h3 id="1-2-七层负载均衡（内容交换）"><a href="#1-2-七层负载均衡（内容交换）" class="headerlink" title="1.2. 七层负载均衡（内容交换）"></a>1.2. 七层负载均衡（内容交换）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;所谓七层负载均衡，也<u>称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</u> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;七层应用负载的好处，是使得整个网络更智能化。例如访问一个网站的用户流量，<u>可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术</u>。实现七层负载均衡的软件有：</p><ul><li>haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移； </li><li>nginx：只在http协议和mail协议上功能比较好，性能与haproxy差不多； </li><li>apache：功能较差 ;</li><li>Mysql proxy：功能尚可。 </li></ul><h2 id="2-负载均衡算法-策略"><a href="#2-负载均衡算法-策略" class="headerlink" title="2. 负载均衡算法/策略"></a>2. 负载均衡算法<strong>/</strong>策略</h2><h3 id="2-1-轮循均衡（Round-Robin）"><a href="#2-1-轮循均衡（Round-Robin）" class="headerlink" title="2.1. 轮循均衡（Round Robin）"></a>2.1. 轮循均衡（Round Robin）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;每一次来自网络的<strong>请求轮流分配给内部中的服务器</strong>，从 1 至 N 然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</p><h3 id="2-2-权重轮循均衡（Weighted-Round-Robin）"><a href="#2-2-权重轮循均衡（Weighted-Round-Robin）" class="headerlink" title="2.2. 权重轮循均衡（Weighted Round Robin）"></a>2.2. 权重轮循均衡（Weighted Round Robin）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;根据<strong>服务器的不同处理能力，给每个服务器分配不同的权值</strong>，使其能够接受相应权值数的服务请求。例如：服务器 A 的权值被设计成 1，B 的权值是 3，C 的权值是 6，则服务器 A、B、C 将分别接受到 10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。</p><h3 id="2-3-随机均衡（Random）"><a href="#2-3-随机均衡（Random）" class="headerlink" title="2.3. 随机均衡（Random）"></a>2.3. 随机均衡（Random）</h3><p>把来自网络的请求随机分配给内部中的多个服务器。 </p><h3 id="2-4-权重随机均衡（Weighted-Random）"><a href="#2-4-权重随机均衡（Weighted-Random）" class="headerlink" title="2.4. 权重随机均衡（Weighted Random）"></a>2.4. 权重随机均衡（Weighted Random）</h3><p>此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。 </p><h3 id="2-5-响应速度均衡（Response-Time-探测时间）"><a href="#2-5-响应速度均衡（Response-Time-探测时间）" class="headerlink" title="2.5. 响应速度均衡（Response Time 探测时间）"></a>2.5. 响应速度均衡（Response Time 探测时间）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>负载均衡设备对内部各服务器发出一个探测请求（例如 Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。</u>此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。</p><h3 id="2-6-最少连接数均衡（Least-Connection）"><a href="#2-6-最少连接数均衡（Least-Connection）" class="headerlink" title="2.6. 最少连接数均衡（Least Connection）"></a>2.6. 最少连接数均衡（Least Connection）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如 FTP。 </p><h3 id="2-7-处理能力均衡（CPU、内存）"><a href="#2-7-处理能力均衡（CPU、内存）" class="headerlink" title="2.7. 处理能力均衡（CPU、内存）"></a>2.7. 处理能力均衡（CPU、内存）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;此种均衡算法将把服务请求分配给内<u>部中处理负荷（根据服务器 CPU 型号、CPU 数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确</u>，尤其适合运用到第七层（应用层）负载均衡的情况</p><p>下。 </p><h3 id="2-8-DNS-响应均衡（Flash-DNS）"><a href="#2-8-DNS-响应均衡（Flash-DNS）" class="headerlink" title="2.8. DNS 响应均衡（Flash DNS）"></a>2.8. DNS 响应均衡（Flash DNS）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的 IP 地址并返回给客户端，<u>则客户端将以最先收到的域名解析 IP 地址来继续请求服务，而忽略其它的 IP 地址响应</u>。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。</p><h3 id="2-9-哈希算法"><a href="#2-9-哈希算法" class="headerlink" title="2.9. 哈希算法"></a>2.9. 哈希算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一致性哈希一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p><h3 id="2-10-IP-地址散列（保证客户端服务器对应关系稳定）"><a href="#2-10-IP-地址散列（保证客户端服务器对应关系稳定）" class="headerlink" title="2.10.  IP 地址散列（保证客户端服务器对应关系稳定）"></a>2.10.  IP 地址散列（保证客户端服务器对应关系稳定）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;通过管理发送方 IP 和目的地 IP 地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，<u>保证来自相同客户端的通信能够一直在同一服务器中进行处理</u>。 </p><h3 id="2-11-URL-散列"><a href="#2-11-URL-散列" class="headerlink" title="2.11. URL 散列"></a>2.11. URL 散列</h3><p>通过管理客户端请求 URL 信息的散列，将发送至相同 URL 的请求转发至同一服务器的算法。</p><h2 id="3-LVS"><a href="#3-LVS" class="headerlink" title="3. LVS"></a>3. LVS</h2><h3 id="3-1-LVS-原理"><a href="#3-1-LVS-原理" class="headerlink" title="3.1. LVS 原理"></a>3.1. LVS 原理</h3><p><strong>IPVS</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的，IPVS 是 LVS 集群系统的核心软件，它的主要作用是：安装在 Director Server 上，同时在 Director Server 上虚拟出一个 IP 地址，用户必须通过这个虚拟的 IP 地址访问服务器。这个虚拟 IP 一般称为 LVS 的 VIP，即 Virtual IP。访问的请求首先经过 VIP 到达负载调度器，然后由负载调度器从 Real Server 列表中选取一个服务节点响应用户的请求。 在用户的请求到达负载调度器后，调度器如何将请求发送到提供服务的 Real Server 节点，而 Real Server 节点如何返回数据给用户，是 IPVS 实现的重点技术。</p><p><strong>ipvs ： 工作于内核空间，主要用于使用户定义的策略生效</strong> </p><p><strong>ipvsadm : 工作于用户空间，主要用于用户定义和管理集群服务的工具</strong> </p><p><img src="/images/Java_heart_LoadBalance/clip_image005.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>ipvs 工作于内核空间的 INPUT 链上</u>，当收到用户请求某集群服务时，经过 PREROUTING 链，经检查本机路由表，送往 INPUT 链；在进入 netfilter 的 INPUT 链时，ipvs 强行将请求报文通过 ipvsadm 定义的集群服务策略的路径改为 FORWORD 链，将报文转发至后端真实提供服务的主机。 </p><h3 id="3-2-LVS-NAT-模式"><a href="#3-2-LVS-NAT-模式" class="headerlink" title="3.2. LVS NAT 模式"></a>3.2. LVS NAT 模式</h3><p><img src="/images/Java_heart_LoadBalance/clip_image007.jpg" alt="img"> </p><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP(客户端 IP),后面统称为 CIP)，目标地址为 VIP(负载均衡器前端地址，后面统称为 VIP)。 </p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将<u>客户端请求报文的目标地址改为了后端服务器的 RIP 地址并将报文根据算法发送出去。</u> </p><p>③.报文送到 Real Server 后，由于报文的目标地址是自己，所以会响应该请求，<u>并将响应报文返还给 LVS</u>。 </p><p>④.然后 lvs 将此报文的源地址修改为本机并发送给客户端。 </p><p><strong>注意：在 NAT 模式中，Real Server 的网关必须指向 LVS，否则报文无法送达客户端</strong> </p><p><strong>特点：</strong> </p><p>1、NAT 技术将请求的报文和响应的报文都需要通过 LB 进行地址改写，因此网站访问量比较大的时候 LB 负载均衡调度器有比较大的瓶颈，一般要求最多之能 10-20 台节点 </p><p>2、<strong>只需要在 LB 上配置一个公网 IP 地址就可以了</strong>。 </p><p>3、每台内部的 realserver 服务器的网关地址必须是调度器 LB 的内网地址。 </p><p>4、NAT 模式支持对 IP 地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致。 </p><p><strong>优点：</strong> </p><p>集群中的物理服务器可以使用任何支持 TCP/IP 操作系统，只有负载均衡器需要一个合法的 IP 地址。 </p><p><strong>缺点：</strong> </p><p>扩展性有限。当服务器节点（普通 PC 服务器）增长过多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇在负载均衡器那，速度就会变慢！</p><h3 id="3-3-LVS-DR-模式（局域网改写-mac-地址）"><a href="#3-3-LVS-DR-模式（局域网改写-mac-地址）" class="headerlink" title="3.3. LVS DR 模式（局域网改写 mac 地址）"></a>3.3. LVS DR 模式（局域网改写 mac 地址）</h3><p><img src="/images/Java_heart_LoadBalance/clip_image009.gif" alt="img"> </p><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。 </p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它<u>将客户端请求报文的源MAC地址改为自己DIP的MAC地址，目标MAC改为了RIP的MAC地址</u>，并将此包发送给RS。 </p><p>③.RS 发现请求报文中的目的 MAC 是自己，就会将次报文接收下来，<u>处理完请求报文后，将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端</u>。 </p><p><strong>注意：需要设置 lo 接口的 VIP 不能响应本地网络内的 arp 请求。</strong> </p><p><strong>总结：</strong> </p><p>1、通过在调度器 LB 上<u>修改数据包的目的 MAC 地址实现转发。注意源地址仍然是 CIP，目的地址仍然是 VIP 地址</u>。 </p><p>2、<u>请求的报文经过调度器，而 RS 响应处理后的报文无需经过调度器 LB，因此并发访问量大时使用效率很高</u>（和 NAT 模式比） </p><p>3、因为 DR 模式是<u>通过 MAC 地址改写机制实现转发，因此所有 RS 节点和调度器 LB 只能在一个局域网里面</u> </p><p>4、RS 主机需要绑定 VIP 地址在 LO 接口（掩码 32 位）上，并且需要配置 ARP 抑制。 </p><p>5、RS 节点的默认网关不需要配置成 LB，而是直接配置为上级路由的网关，能让 RS 直接出网就可以。 </p><p>6、由于 DR 模式的调度器仅做 MAC 地址的改写，所以调度器 LB 就不能改写目标端口，那么 RS 服务器就得使用和 VIP <u>相同的端口提供服务</u>。 </p><p>7、直接对外的业务比如 WEB 等，<u>RS 的 IP 最好是使用公网 IP</u>。对外的服务，比如数据库等最好使用内网 IP。 </p><p><strong>优点：</strong> </p><p>和 TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端。与 VS-TUN 相比，<u>VS-DR 这种实现方式不需要隧道结构</u>，因此可以使用大多数操作系统做为物理服务器。 </p><p>DR 模式的效率很高，但是配置稍微复杂一点，因此对于访问量不是特别大的公司可以用haproxy/nginx取代。日1000-2000W PV或者并发请求1万一下都可以考虑用haproxy/nginx。 </p><p><strong>缺点：</strong> <u>所有 RS 节点和调度器 LB 只能在一个局域网里面</u></p><h3 id="3-4-LVS-TUN-模式（IP-封装、跨网段）"><a href="#3-4-LVS-TUN-模式（IP-封装、跨网段）" class="headerlink" title="3.4. LVS TUN 模式（IP 封装、跨网段）"></a>3.4. LVS TUN 模式（IP 封装、跨网段）</h3><p><img src="/images/Java_heart_LoadBalance/clip_image011.jpg" alt="img"> </p><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。 </p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它<u>将在客户端请求报文的首部再封装一层 IP 报文,将源地址改为 DIP，目标地址改为 RIP,并将此包发送给 RS</u>。 </p><p>③.RS 收到请求报文后，会首先拆开第一层封装,然后<u>发现里面还有一层 IP 首部的目标地址是自己 lo 接口上的 VIP</u>，所以会处理次请求报文，并将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。 </p><p><strong>注意：需要设置 lo 接口的 VIP 不能在共网上出现。</strong> </p><p><strong>总结：</strong> </p><p>1、TUNNEL 模式<u>必须在所有的 realserver 机器上面绑定 VIP 的 IP 地址</u> </p><p>2、TUNNEL 模式的 vip ——&gt;realserver 的包通信通过 TUNNEL 模式，<u>不管是内网和外网都能通信，所以不需要 lvs vip 跟 realserver 在同一个网段内</u>。 </p><p>3、TUNNEL 模式 realserver 会把 packet 直接发给 client 不会给 lvs 了 </p><p>4、TUNNEL 模式走的隧道模式，所以运维起来比较难，所以一般不用。 </p><p><strong>优点：</strong> </p><p>负载均衡器只负责将请求包分发给后端节点服务器，而 RS 将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多 RS 进行分发。而且跑在公网上就能进行不同地域的分发。 </p><p><strong>缺点：</strong> </p><p><u>隧道模式的 RS 节点需要合法 IP，这种方式需要所有的服务器支持”IPTunneling”(IP Encapsulation)协议，服务器可能只局限在部分 Linux 系统上</u>。 </p><h3 id="3-5-LVS-FULLNAT-模式"><a href="#3-5-LVS-FULLNAT-模式" class="headerlink" title="3.5. LVS FULLNAT 模式"></a>3.5. LVS FULLNAT 模式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;无论是 DR 还是 NAT 模式，不可避免的都有一个问题：LVS 和 RS 必须在同一个 VLAN 下，否则 LVS 无法作为 RS 的网关。这引发的两个问题是：</p><p>1、同一个 VLAN 的限制导致运维不方便，跨 VLAN 的 RS 无法接入。 </p><p>2、LVS 的水平扩展受到制约。当 RS 水平扩容时，总有一天其上的单点 LVS 会成为瓶颈。 </p><p><strong>Full-NAT 由此而生，解决的是 LVS 和 RS 跨 VLAN 的问题</strong>，而跨 VLAN 问题解决后，LVS 和 RS 不再存在 VLAN 上的从属关系，可以做到多个 LVS 对应多个 RS，解决水平扩容的问题。 </p><p>Full-NAT 相比 NAT 的主要改进是，在 SNAT/DNAT 的基础上，加上另一种转换，转换过程如下： </p><p><img src="/images/Java_heart_LoadBalance/clip_image013.gif" alt="img"> </p><ol><li><p>在包从 LVS 转到 RS 的过程中，源地址从客户端 IP 被替换成了 LVS 的内网 IP。内网 IP 之间可以通过多个交换机跨 VLAN 通信。目标地址从 VIP 修改为 RS IP.</p></li><li><p>当 RS 处理完接受到的包，处理完成后返回时，将目标地址修改为 LVS ip，原地址修改为 RS IP，最终将这个包返回给 LVS 的内网 IP，这一步也不受限于 VLAN。 </p></li><li><p>LVS 收到包后，在 NAT 模式修改源地址的基础上，再把 RS 发来的包中的目标地址从 LVS 内网 IP 改为客户端的 IP,并将原地址修改为 VIP。 </p></li></ol><p>Full-NAT 主要的思想是把网关和其下机器的通信，改为了普通的网络通信，从而解决了跨 VLAN 的问题。采用这种方式，LVS 和 RS 的部署在 VLAN 上将不再有任何限制，大大提高了运维部署的便利性。</p><p><strong>总结</strong> </p><ol><li><p>FULL NAT 模式不需要 LBIP 和 realserver ip 在同一个网段； </p></li><li><p>full nat 因为要更新 sorce ip 所以性能正常比 nat 模式下降 10% 。</p></li></ol><h2 id="4-Keepalive"><a href="#4-Keepalive" class="headerlink" title="4. Keepalive"></a>4. Keepalive</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;keepalive 起初是为 LVS 设计的，专门用来<strong>监控 lvs 各个服务节点的状态</strong>，后来加入了 vrrp 的功能，因此除了 lvs，也可以作为其他服务（nginx，haproxy）的高可用软件。VRRP 是 virtual router redundancy protocal（虚拟路由器冗余协议）的缩写。VRRP 的出现就是为了解决静态路由出现的单点故障，它能够保证网络可以不间断的稳定的运行。所以 keepalive 一方面具有 LVS cluster node healthcheck 功能，另一方面也具有 LVS director failover。 </p><h2 id="5-Nginx-反向代理负载均衡"><a href="#5-Nginx-反向代理负载均衡" class="headerlink" title="5. Nginx 反向代理负载均衡"></a>5. Nginx 反向代理负载均衡</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;普通的负载均衡软件，如LVS，<strong>其实现的功能只是对请求数据包的转发、传递</strong>，从负载均衡下的节点服务器来看，接收到的请求还是来自访问负载均衡器的客户端的真实用户；而反向代理就不一样了，<strong>反向代理服务器在接收访问用户请求后，会代理用户 重新发起请求代理下的节点服务器，最后把数据返回给客户端用户</strong>。在节点服务器看来，访问的节点服务器的客户端用户就是反向代理服务器，而非真实的网站访问用户。</p><h3 id="5-1-upstream-module-和健康检测"><a href="#5-1-upstream-module-和健康检测" class="headerlink" title="5.1. upstream_module 和健康检测"></a>5.1. upstream_module 和健康检测</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>ngx_http_upstream_module 是负载均衡模块，可以实现网站的负载均衡功能即节点的健康检查</strong>，upstream 模块允许 Nginx 定义一组或多组节点服务器组，使用时可通过 proxy_pass 代理方式把网站的请求发送到事先定义好的对应 Upstream 组 的名字上。 </p><table><thead><tr><th><strong>upstream</strong> <strong>模块内参数</strong></th><th><strong>参数说明</strong></th></tr></thead><tbody><tr><td>weight</td><td>服务器权重</td></tr><tr><td>max_fails</td><td>Nginx 尝试连接后端主机失败的此时，这是值是配合 proxy_next_upstream、  fastcgi_next_upstream 和 memcached_next_upstream 这三个参数来使用的。当 Nginx 接收后端服务器返回这三个参数定义的状态码时，会将这个请求转发给正常工作的的后端服务器。如 404、503、503,max_files=1</td></tr><tr><td>fail_timeout</td><td>max_fails  和 fail_timeout 一般会关联使用，如果某台 server 在 fail_timeout 时间内出现了 max_fails 次连接失败，那么 Nginx 会认为其已经挂掉，从而在 fail_timeout 时间内不再去请求它，fail_timeout 默认是 10s，max_fails 默认是 1，即默认情况只要是发生错误就认为服务器挂了，如果将 max_fails 设置为 0，则表示取消这项检查</td></tr><tr><td>backup</td><td>表示当前 server 是备用服务器，只有其它非 backup 后端服务器都挂掉了或很忙才会分配请求给它</td></tr><tr><td>down</td><td>标志服务器永远不可用，可配合 ip_hash 使用</td></tr></tbody></table> <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> lvsServer&#123;  </span><br><span class="line"><span class="attribute">server</span>  <span class="number">191.168.1.11</span> weight=<span class="number">5</span> ;  </span><br><span class="line"><span class="attribute">server</span>  <span class="number">191.168.1.22:82</span>;  </span><br><span class="line"><span class="attribute">server</span> example.com:<span class="number">8080</span>  max_fails=<span class="number">2</span> fail_timeout=<span class="number">10s</span> backup;      <span class="comment">#域名的话需要解析的哦，内网记得 hosts   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-proxy-pass-请求转发"><a href="#5-2-proxy-pass-请求转发" class="headerlink" title="5.2. proxy_pass 请求转发"></a>5.2. proxy_pass 请求转发</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass 指令属于 ngx_http_proxy_module 模块，此模块可以将请求转发到另一台服务器，在实际的反向代理工作中，<strong>会通过 location 功能匹配指定的 URI，然后把接收到服务匹配 URI 的请求通过 proyx_pass 抛给定义好的 upstream 节点池</strong>。 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /download/ &#123;  <span class="attribute">proxy_pass</span> http://download/vedio/;   &#125;    <span class="comment">#这是前端代理节点的设置</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"></th><th></th></tr></thead><tbody><tr><td align="left">#交给后端 upstream 为 download 的节点</td><td></td></tr><tr><td align="left"><strong>proxy</strong> <strong>模块参数</strong></td><td><strong>说明</strong></td></tr><tr><td align="left">proxy_next_upstream</td><td>什么情况下将请求传递到下一个 upstream</td></tr><tr><td align="left">proxy_limite_rate</td><td>限制从后端服务器读取响应的速率</td></tr><tr><td align="left">proyx_set_header</td><td>设置 http 请求  header 传给后端服务器节点，如：可实现让代理后端的服务器节点获取访问客户端的这是 ip</td></tr><tr><td align="left">client_body_buffer_size</td><td>客户端请求主体缓冲区大小</td></tr><tr><td align="left">proxy_connect_timeout</td><td>代理与后端节点服务器连接的超时时间</td></tr><tr><td align="left">proxy_send_timeout</td><td>后端节点数据回传的超时时间</td></tr><tr><td align="left">proxy_read_timeout</td><td>设置 Nginx 从代理的后端服务器获取信息的时间，表示连接成功建立后，Nginx 等待后端服务器的响应时间</td></tr><tr><td align="left">proxy_buffer_size</td><td>设置缓冲区大小</td></tr><tr><td align="left">proxy_buffers</td><td>设置缓冲区的数量和大小</td></tr><tr><td align="left">proyx_busy_buffers_size</td><td>用于设置系统很忙时可以使用的 proxy_buffers 大小，推荐为 proxy_buffers*2</td></tr><tr><td align="left">proxy_temp_file_write_size</td><td>指定 proxy 缓存临时文件的大小</td></tr></tbody></table><h2 id="6-HAProxy"><a href="#6-HAProxy" class="headerlink" title="6. HAProxy"></a>6. HAProxy</h2><p>参考一下链接：</p><p><a href="https://baike.baidu.com/item/haproxy/5825820?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/haproxy/5825820?fr=aladdin</a></p><p><a href="https://www.jianshu.com/p/baa296770bd5" target="_blank" rel="noopener">https://www.jianshu.com/p/baa296770bd5</a></p><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7. 最后"></a>7. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展&lt;a href=&quot;https://baike.baidu.com/item/网络设备&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网络设备&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/服务器&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;和&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/服务器&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;服务器&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/服务器&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;的&lt;/a&gt;带宽、增加&lt;a href=&quot;https://baike.baidu.com/item/吞吐量&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;吞吐量&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/吞吐量&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;、&lt;/a&gt;加强网络数据处理能力、提高网络的灵活性和可用性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Nginx" scheme="https://quietair.gitee.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(十三)之Cassandra</title>
    <link href="https://quietair.gitee.io/Java_heart_Cassandra/"/>
    <id>https://quietair.gitee.io/Java_heart_Cassandra/</id>
    <published>2020-05-03T06:26:42.000Z</published>
    <updated>2020-05-04T07:04:49.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Apache Cassandra 是高度可扩展的，高性能的分布式 NoSQL 数据库。 Cassandra 旨在处理许多商品服务器上的大量数据，提供高可用性而无需担心单点故障。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Cassandra 具有能够处理大量数据的分布式架构。 数据放置在具有多个复制因子的不同机器上，以获得高可用性，而无需担心单点故障。 </p><a id="more"></a><h2 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2. 数据模型"></a>2. 数据模型</h2><p><strong>Key Space（对应SQL数据库中的database）</strong></p><ol><li>一个 Key Space 中可包含若干个 CF，如同 SQL 数据库中一个 database 可包含多个 table </li></ol><p><strong>Key（对应 SQL 数据库中的主键）</strong> </p><ol start="2"><li>在 Cassandra 中，每一行数据记录是以 key/value 的形式存储的，其中 key 是唯一标识。 </li></ol><p><strong>column（对应 SQL数据库中的列）</strong> </p><ol start="3"><li>Cassandra 中每个 key/value 对中的 value 又称为 column，它是一个三元组，即：name， value 和 timestamp，其中 name 需要是唯一的。 </li></ol><p><strong>super column（SQL数据库不支持）</strong> </p><ol start="4"><li>cassandra 允许 key/value 中的 value 是一个 map(key/value_list)，即某个 column 有多个子列。 </li></ol><p><strong>Standard Column Family（相对应 SQL数据库中的 table）</strong> </p><ol start="5"><li>每个 CF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 column。 </li></ol><p><strong>Super Column Family（SQL 数据库不支持）</strong> </p><ol start="6"><li>每个 SCF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 super column。 </li></ol><h2 id="3-Cassandra一致Hash和虚拟节点"><a href="#3-Cassandra一致Hash和虚拟节点" class="headerlink" title="3. Cassandra一致Hash和虚拟节点"></a>3. Cassandra一致Hash和虚拟节点</h2><p><strong>一致性Hash（多米诺down机）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;为每个节点分配一个 token，根据这个 token 值来决定节点在集群中的位置以及这个节点所存储的数据范围。 </p><p><strong>虚拟节点（down机多节点托管）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于这种方式会造成数据分布不均的问题，<u>在 Cassandra1.2 以后采用了虚拟节点的思想：不需要为每个节点分配 token，把圆环分成更多部分，让每个节点负责多个部分的数据，这样一个节点移除后，它所负责的多个 token 会托管给多个节点处理，这种思想解决了数据分布不均的问题。</u> </p><p><img src="/images/Java_heart_Cassandra/clip_image003.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;如图所示，<strong>上面部分是标准一致性哈希</strong>，每个节点负责圆环中连续的一段，如果 Node2 突然 down 掉，Node2 负责的数据托管给 Node1，即 Node1 负责 EFAB 四段，如果 Node1 里面有很多热点用户产生的数据导致 Node1 已经有点撑不住了，恰巧 B 也是热点用户产生的数据，这样一来 Node1 可能会接着 down 机，Node1down 机，Node6 还 hold 住吗？ </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>下面部分是虚拟节点实现，每个节点不再负责连续部分，且圆环被分为更多的部分。如果 Node2 突然down掉，Node2负责的数据不全是托管给Node1，而是托管给多个节点。而且也保持了一致性哈希的特点。</u> </p><h2 id="4-Gossip协议"><a href="#4-Gossip协议" class="headerlink" title="4. Gossip协议"></a>4. Gossip协议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Gossip 算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此 Gossip 有众多的别名“闲话算法”、 “疫情传播算法”、“病毒感染算法”、“谣言传播算法”。 Gossip 的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。因为 Gossip 不要求节点知道所有其他节点，<u>因此又具有去中心化的特点</u>，节点之间完全对等，不需要任何的中心节点。实际上 Gossip 可以用于众多能接受“最终一致性”的领域：失败检测、路由同步、Pub/Sub、动态负载均衡。 </p><p><strong>Gossip节点的通信方式及收敛性</strong> </p><p><strong>Gossip两个节点（A、B）之间存在三种通信方式（push、pull、push&amp;pull）</strong> </p><ol><li><p>push: A 节点将数据(key,value,version)及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据。 </p></li><li><p>pull：A 仅将数据 key,version 推送给 B，B 将本地比 A 新的数据（Key,value,version）推送给 A，A 更新本地。 </p></li><li><p>push/pull：与 pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 更新本地。 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push 需通信 1 次，pull 需 2 次， push/pull 则需 3 次，从效果上来讲，push/pull 最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull 的收敛速度是最快的。 </p><p><strong>gossip 的协议和seed list（防止集群分列）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;cassandra 使用称为 gossip 的协议来发现加入 C 集群中的其他节点的位置和状态信息。<u>gossip 进程每秒都在进行，并与至多三个节点交换状态信息</u>。节点交换他们自己和所知道的信息，于是所有的节点很快就能学习到整个集群中的其他节点的信息。gossip 信息有一个相关的版本号，于是在一次gossip信息交换中，旧的信息会被新的信息覆盖重写。要阻止分区进行gossip交流，那么在集群中的所有节点中使用相同的 seed list，<u>种子节点的指定除了启动起 gossip 进程外，没有其他的目的。</u>种子节点不是一个单点故障，他们在集群操作中也没有其他的特殊目的，除了引导节点以外</p><h2 id="5-数据复制"><a href="#5-数据复制" class="headerlink" title="5. 数据复制"></a>5. 数据复制</h2><p><strong>Partitioners</strong>（计算 <strong>primary key token</strong> 的 <strong>hash</strong> 函数） </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Cassandra 中，table 的每行由唯一的 primarykey 标识，<u>partitioner 实际上为一 hash 函数用以计算 primary key 的 token</u>。Cassandra 依据这个 token 值在集群中放置对应的行 </p><p>两种可用的复制策略： </p><p><strong>SimpleStrategy</strong>：<u>仅用于单数据中心</u>， </p><p>&nbsp;&nbsp;&nbsp;&nbsp;将第一个 replica 放在由 partitioner 确定的节点中，其余的 replicas 放在上述节点顺时针方向的后续节点中。</p><p><strong>NetworkTopologyStrategy：可用于较复杂的多数据中心。</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;可以指定在每个数据中心分别存储多少份 replicas。 复制策略在创建 keyspace 时指定，如 </p><p>CREATE KEYSPACE Excelsior WITH REPLICATION = { ‘class’ : ‘SimpleStrategy’,’replication_factor’ : 3 };  </p><p>CREATE KEYSPACE Excalibur WITH REPLICATION = {‘class’ :’NetworkTopologyStrategy’, ‘dc1’ : 3, ‘dc2’ : 2}; </p><h2 id="6-数据写请求和协调者"><a href="#6-数据写请求和协调者" class="headerlink" title="6. 数据写请求和协调者"></a>6. 数据写请求和协调者</h2><p><strong>协调者(coordinator)</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>协调者(coordinator)将 write 请求发送到拥有对应row 的所有 replica 节点</u>，只要节点可用便获取并执行写请求。<u>写一致性级别(write consistency level)确定要有多少个 replica 节点必须返回成功的确认信息。成功意味着数据被正确写入了 commit log 和 memtable。</u> </p><p><img src="/images/Java_heart_Cassandra/image-20200504140944886.png" alt="image"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;其中 dc1、dc2 这些数据中心名称要与 snitch 中配置的名称一致.上面的拓扑策略表示在 dc1 配置 3 个副本,在 dc2 配置 2 个副本 </p><h2 id="7-数据读请求和后台修复"><a href="#7-数据读请求和后台修复" class="headerlink" title="7. 数据读请求和后台修复"></a>7. 数据读请求和后台修复</h2><ol><li><p>协调者首先与一致性级别确定的所有 replica 联系，<u>被联系的节点返回请求的数据</u>。</p></li><li><p>若多个节点被联系，<u>则来自各 replica 的 row 会在内存中作比较，若不一致，则协调者使用含最新数据的 replica 向 client 返回结果</u>。那么比较操作过程中只需要传递时间戳就可以,因为要比较的只是哪个副本数据是最新的。 </p></li><li><p><u>协调者在后台联系和比较来自其余拥有对应 row 的 replica 的数据，若不一致，会向过时的 replica 发写请求用最新的数据进行更新 read repair。</u> </p></li></ol><p><img src="/images/Java_heart_Cassandra/image-20200504141133102.png" alt="image"> </p><h2 id="8-数据存储（CommitLog、MemTable、SSTable）"><a href="#8-数据存储（CommitLog、MemTable、SSTable）" class="headerlink" title="8. 数据存储（CommitLog、MemTable、SSTable）"></a>8. 数据存储（CommitLog、MemTable、SSTable）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;写请求分别到 CommitLog 和 MemTable, 并且 MemTable 的数据会刷写到磁盘 SSTable 上. 除了写数据,还有索引也会保存到磁盘上. </p><p>&nbsp;&nbsp;&nbsp;&nbsp;先将数据写到磁盘中的 commitlog，同时追加到中内存中的数据结构 memtable 。这个时候就会返 回 客 户 端 状 态 ， memtable 内 容 超 出 指 定 容 量 后 会 被 放 进 将 被 刷 入 磁 盘 的 队 列(memtable_flush_queue_size 配置队列长度)。若将被刷入磁盘的数据超出了队列长度，将内存数据刷进磁盘中的 SSTable,之后 commit log 被清空。 </p><p><strong>SSTable文件构成（BloomFilter、index、data、static）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;SSTable 文件有<strong>fileer</strong>（判断数据key是否存在，这里使用了BloomFilter提高效率），<strong>index</strong>（寻找对应 column 值所在 data 文件位置）文件，data（存储真实数据）文件，static（存储和统计 column 和 row 大小）文件。 </p><h2 id="9-二级索引（对要索引的value摘要，生成RowKey）"><a href="#9-二级索引（对要索引的value摘要，生成RowKey）" class="headerlink" title="9. 二级索引（对要索引的value摘要，生成RowKey）"></a>9. 二级索引（对要索引的value摘要，生成RowKey）</h2><p>在 Cassandra 中，数据都是以 Key-value 的形式保存的。 </p><p><img src="/images/Java_heart_Cassandra/image-20200504141356241.png" alt="image"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;KeysIndex 所创建的二级索引也被保存在一张 ColumnFamily 中。<u>在插入数据时，对需要进行索引的value进行摘要，生成独一无二的key，将其作为RowKey保存在索引的ColumnFamily中</u>；同时在 RowKey 上添加一个 Column，将插入数据的 RowKey 作为 name 域的值，value 域则赋空值，timestamp 域则赋为插入数据的时间戳。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果有相同的 value 被索引了，则会在索引 ColumnFamily 中相同的 RowKey 后再添加新的 Column。如果有新的 value 被索引，则会在索引 ColumnFamily 中添加新的 RowKey 以及对应新的 Column。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;当对 value 进行查询时，只需计算该 value 的 RowKey，在索引 ColumnFamily 中的查找该 RowKey，对其 Columns 进行遍历就能得到该 value 所有数据的 RowKey。 </p><h2 id="10-数据读写"><a href="#10-数据读写" class="headerlink" title="10. 数据读写"></a>10. 数据读写</h2><p><strong>数据写入和更新（数据追加）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Cassandra 的设计思路与这些系统不同，无论是 insert 还是 remove 操作，<u>都是在已有的数据后面进行追加，而不修改已有的数据</u>。这种设计称为 Log structured 存储，顾名思义就是系统中的数据是以日志的形式存在的，所以只会将新的数据追加到已有数据的后面。Log structured 存储系统有两个主要优点： </p><p><strong>数据的写和删除效率极高</strong> </p><ul><li>传统的存储系统需要更新元信息和数据，因此磁盘的磁头需要反复移动，这是一个比较耗时的操作，而 Log structured 的系统则是顺序写，可以充分利用文件系统的 cache，所以效率很高。 </li></ul><p><strong>错误恢复简单</strong> </p><ul><li>由于数据本身就是以日志形式保存，老的数据不会被覆盖，所以在设计 journal 的时候不需要考虑 undo，简化了错误恢复。 </li></ul><p><strong>读的复杂度高</strong> </p><ul><li>但是，Log structured 的存储系统也引入了一个重要的问题：读的复杂度和性能。理论上说，读操作需要从后往前扫描数据，以找到某个记录的最新版本。相比传统的存储系统，这是比较耗时的。</li></ul><p>参考：<a href="https://blog.csdn.net/fs1360472174/article/details/55005335" target="_blank" rel="noopener">https://blog.csdn.net/fs1360472174/article/details/55005335</a></p><p><strong>数据删除（column的墓碑）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果一次删除操作在一个节点上失败了（总共 3 个节点，副本为 3， RF=3).整个删除操作仍然被认为成功的（因为有两个节点应答成功，使用 CL.QUORUM 一致性）。接下来如果读发生在该节点上就会变的不明确，因为结果返回是空，还是返回数据，没有办法确定哪一种是正确的。 Cassandra 总是认为返回数据是对的，那就会发生删除的数据又出现了的事情，这些数据可以叫” 僵尸”，并且他们的表现是不可预见的。 </p><p><strong>墓碑</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>删除一个 column 其实只是插入一个关于这个 column 的墓碑（tombstone），并不直接删除原有的 column。</u>该墓碑被作为对该 CF 的一次修改记录在 Memtable 和 SSTable 中。墓碑的内容是删除请求被执行的时间，该时间是接受客户端请求的存储节点在执行该请求时的本地时间（local delete time），称为本地删除时间。需要注意区分本地删除时间和时间戳，每个 CF 修改记录都有一个时间戳，这个时间戳可以理解为该 column 的修改时间，是由客户端给定的。</p><p><strong>垃圾回收compaction</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于被删除的 column 并不会立即被从磁盘中删除，所以系统占用的磁盘空间会越来越大，这就需要有一种垃圾回收的机制，定期删除被标记了墓碑的 column。垃圾回收是在 compaction 的过程中完成的。 </p><p><strong>数据读取（memtable+SStables）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;为了满足读 cassandra 读取的数据是 <u>memtable 中的数据和 SStables 中数据的合并结果</u>。读取 SSTables 中的数据就是查找到具体的哪些的 SSTables 以及数据在这些 SSTables 中的偏移量 (SSTables 是按主键排序后的数据块)。首先如果 <strong>row cache enable</strong> 了话，会检测缓存。缓存命中直接返回数据，没有则查找 <strong>Bloom filter</strong>，查找可能的 SSTable。然后有一层 Partition key cache，找 partition key 的位置。如果有根据找到的 partition 去压缩偏移量映射表找具体的数据块。如果缓存没有，则要经过 <strong>Partition summary,Partition index</strong> 去找 partition key。然后经过压缩偏移量映射表找具体的数据块。 </p><ol><li><p>检查 memtable </p></li><li><p>如果 enabled 了,检查 row cache </p></li><li><p>检查 Bloom filter </p></li><li><p>如果 enable 了,检查 partition key 缓存 </p></li><li><p>如果在 partition key 缓存中找到了 partition key,直接去 compression offset 命中，如果没有，检查 partition summary </p></li><li><p>根据 compression offset map 找到数据位置 </p></li><li><p>从磁盘的 SSTable 中取出数据</p></li></ol><p><img src="/images/Java_heart_Cassandra/image-20200504141924818.png" alt="image"> </p><p><strong>行缓存和键缓存请求流程图</strong> </p><p> <img src="/images/Java_heart_Cassandra/image-20200504142002332.png" alt="image"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>MemTable</strong>：如果 memtable 有目标分区数据，这个数据会被读出来并且和从 SSTables 中读出来的数据进行合并。SSTable 的数据访问如下面所示的步骤。 </p><p><strong>Row Cache（SSTables中频繁被访问的数据）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>在 Cassandra2.2+，它们被存储在堆外内存，使用全新的实现避免造成垃圾回收对 JVM 造成压力</u>。存在在 row cache 的子集数据可以在特定的一段时间内配置一定大小的内存。row cache 使用LRU(least-recently-userd)进行回收在申请内存。<u>存储在 row cache 中的数据是SSTables 中频繁被访问的数据</u>。存储到row cache中后，数据就可以被后续的查询访问。<u>row cache不是写更新。如果写某行了，这行的缓存就会失效，并且不会被继续缓存，直到这行被读到。类似的，如果一个partition更新了，整个partition的cache都会被移除，但目标的数据在row cache中找不到，就会去检查 Bloom filter。</u> </p><p><strong>Bloom Filter（查找数据可能对应的SSTable）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先，Cassandra 检查 Bloom filter 去发现哪个 SSTables 中有可能有请求的分区数据。<u>Bloom filter 是存储在堆外内存。每个 SSTable 都有一个关联的 Bloom filter</u>。一个 Bloom filter 可以建立一个 SSTable 没有包含的特定的分区数据。同样也可以找到分区数据存在 SSTable 中的可能性。它可以加速查找 partition key 的查找过程。然而，因为 Bloom filter 是一个概率函数，所以可能会得到错误的结果，并不是所有的 SSTables 都可以被 Bloom filter 识别出是否有数据。如果Bloom filter 不能够查找到 SSTable，Cassandra 会检查 partition key cache。Bloom filter 大小增长很适宜，每 10 亿数据 1~2GB。在极端情况下，可以一个分区一行。都可以很轻松的将数十亿的 entries 存储在单个机器上。Bloom filter 是可以调节的，如果你愿意用内存来换取性能。 </p><p><strong>Partition Key Cache（查找数据可能对应的Partition key）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;partition key 缓存如果开启了，将 partition index 存储在堆外内存。key cache 使用一小块可配置大小的内存。在读的过程中，<u>每个”hit”保存一个检索。如果在 key cache 中找到了 partition key。就直接到 compression offset map 中招对应的块</u>。partition key cache 热启动后工作的更好，相比较冷启动，有很大的性能提升。如果一个节点上的内存非常受限制，可能的话，需要限制保存在 key cache 中的 partition key 数目。如果一个在 key cache 中没有找到 partition key。就会去partition summary中去找。partition key cache 大小是可以配置的，意义就是存储在key cache 中的 partition keys 数目。 </p><p><strong>Partition Summary（内存中存储一些partition index 的样本）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;partition summary 是存储在堆外内存的结构，<u>存储一些 partition index 的样本</u>。如果一个 partition index 包含所有的 partition keys。鉴于一个 partition summary 从每 X 个 keys 中取样，然后将每X个key map到index 文件中。例如，如果一个partition summary设置了20keys 进行取样。它就会存储 SSTable file 开始的一个 key,20th 个 key，以此类推。尽管并不知道 partition key 的具体位置，partition summary 可以缩短找到 partition 数据位置。当找到了 partition key 值可能的范围后，就会去找 partition index。通过配置取样频率，你可以用内存来换取性能，当 partition summary 包含的数据越多，使用的内存越多。可以通过表定义的 <a href="http://docs.datastax.com/en/cql/3.3/cql/cql_reference/cqlCreateTable.html#tabProp" target="_blank" rel="noopener">index </a><a href="http://docs.datastax.com/en/cql/3.3/cql/cql_reference/cqlCreateTable.html#tabProp" target="_blank" rel="noopener">interval</a> <a href="http://docs.datastax.com/en/cql/3.3/cql/cql_reference/cqlCreateTable.html#tabProp" target="_blank" rel="noopener">属</a>性来改变样本频率。固定大小的内存可以通过 <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configCassandra_yaml.html#configCassandra_yaml__index_summary_capacity_in_mb" target="_blank" rel="noopener">index_summary_capacity_in_mb</a> <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configCassandra_yaml.html#configCassandra_yaml__index_summary_capacity_in_mb" target="_blank" rel="noopener">属</a>性来设置，默认是堆大小的 5%。 </p><p><strong>Partition Index（磁盘中）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;partition index 驻扎在磁盘中，索引所有 partition keys 和偏移量的映射。如果 partition summary 已经查到 partition keys 的范围，现在的检索就是根据这个范围值来检索目标 partition key。需要进行单次检索和顺序读。根据找到的信息。然后去 compression offset map 中去找磁盘中有这个数据的块。如果 partition index 必须要被检索，则需要检索两次磁盘去找到目标数据。 </p><p><strong>Compression offset map（磁盘中）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>compression offset map 存储磁盘数据准确位置的指针</u>。存储在堆外内存，可以被 partition key cache 或者 partition index 访问。一旦 compression offset map 识别出来磁盘中的数据位置，就会从正确的 SStable(s)中取出数据。查询就会收到结果集。 </p><h2 id="11-最后"><a href="#11-最后" class="headerlink" title="11. 最后"></a>11. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Apache Cassandra 是高度可扩展的，高性能的分布式 NoSQL 数据库。 Cassandra 旨在处理许多商品服务器上的大量数据，提供高可用性而无需担心单点故障。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Cassandra 具有能够处理大量数据的分布式架构。 数据放置在具有多个复制因子的不同机器上，以获得高可用性，而无需担心单点故障。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Cassandra" scheme="https://quietair.gitee.io/tags/Cassandra/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(十二)之RabbitMQ、MongoDB、设计模式</title>
    <link href="https://quietair.gitee.io/Java_heart_RabbitMQorMongoDB/"/>
    <id>https://quietair.gitee.io/Java_heart_RabbitMQorMongoDB/</id>
    <published>2020-05-01T06:36:58.000Z</published>
    <updated>2020-05-04T07:04:49.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ-架构"><a href="#RabbitMQ-架构" class="headerlink" title="RabbitMQ 架构"></a>RabbitMQ 架构</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。 </p><p><strong>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准</strong>，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p><p><strong>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</strong>具体特点包括：</p><a id="more"></a><ol><li><p><strong>可靠性（Reliability）</strong>：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。 </p></li><li><p>灵活的路由（Flexible Routing）：在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</p></li><li><p>消息集群（Clustering）：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</p></li><li><p>高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。 </p></li><li><p>多种协议（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。 </p></li><li><p>多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、 Ruby 等等。 </p></li><li><p><strong>管理界面（Management UI）</strong>:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。 </p></li><li><p><strong>跟踪机制（Tracing）</strong>:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 </p></li><li><p>插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 </p></li></ol><h2 id="2-RabbitMQ架构"><a href="#2-RabbitMQ架构" class="headerlink" title="2. RabbitMQ架构"></a>2. RabbitMQ架构</h2><p><img src="/images/Java_heart_RabbitMQorMongoDB/clip_image003.gif" alt="img"> </p><h3 id="2-1-Message"><a href="#2-1-Message" class="headerlink" title="2.1. Message"></a>2.1. Message</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 </p><h3 id="2-2-Publisher"><a href="#2-2-Publisher" class="headerlink" title="2.2. Publisher"></a>2.2. Publisher</h3><ol><li>消息的生产者，也是一个向交换器发布消息的客户端应用程序。 </li></ol><h3 id="2-3-Exchange（将消息路由给队列-）"><a href="#2-3-Exchange（将消息路由给队列-）" class="headerlink" title="2.3.Exchange（将消息路由给队列 ）"></a>2.3.Exchange（将消息路由给队列 ）</h3><ol start="2"><li>交换器，<u>用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</u> </li></ol><h3 id="2-4-Binding（消息队列和交换器之间的关联）"><a href="#2-4-Binding（消息队列和交换器之间的关联）" class="headerlink" title="2.4.Binding（消息队列和交换器之间的关联）"></a>2.4.Binding（消息队列和交换器之间的关联）</h3><ol start="3"><li>绑定，用于<u>消息队列和交换器之间的关联。</u>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li></ol><h3 id="2-5-Queue"><a href="#2-5-Queue" class="headerlink" title="2.5.Queue"></a>2.5.Queue</h3><ol start="4"><li>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。<u>一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</u> </li></ol><h3 id="2-6-Connection"><a href="#2-6-Connection" class="headerlink" title="2.6.Connection"></a>2.6.Connection</h3><ol start="5"><li>网络连接，比如一个 TCP 连接。</li></ol><h3 id="2-7-Channel"><a href="#2-7-Channel" class="headerlink" title="2.7.Channel"></a>2.7.Channel</h3><ol start="6"><li>信道，<u>多路复用连接中的一条独立的双向数据流通道</u>。信道是建立在真实的 TCP 连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li></ol><h3 id="2-8-Consumer"><a href="#2-8-Consumer" class="headerlink" title="2.8.Consumer"></a>2.8.Consumer</h3><ol start="7"><li>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 </li></ol><h3 id="2-9-Virtual-Host"><a href="#2-9-Virtual-Host" class="headerlink" title="2.9.Virtual Host"></a>2.9.Virtual Host</h3><ol start="8"><li>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</li></ol><h3 id="2-10-Broker"><a href="#2-10-Broker" class="headerlink" title="2.10.Broker"></a>2.10.Broker</h3><ol start="9"><li>表示消息队列服务器实体。 </li></ol><h2 id="3-Exchange类型"><a href="#3-Exchange类型" class="headerlink" title="3. Exchange类型"></a>3. Exchange类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Exchange 分发消息时根据类型的不同分发策略有区别，<strong>目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键</strong>，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p><h3 id="3-1-Direct-键（routing-key）分布："><a href="#3-1-Direct-键（routing-key）分布：" class="headerlink" title="3.1.Direct 键（routing key）分布："></a>3.1.Direct 键（routing key）分布：</h3><ol><li>Direct：<u>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致</u>， 交换器就将消息发到对应的队列中。它是完全匹配、单播的模式。  </li></ol><p><img src="/images/Java_heart_RabbitMQorMongoDB/clip_image002.gif" alt="img"> </p><h3 id="3-2-Fanout（广播分发）"><a href="#3-2-Fanout（广播分发）" class="headerlink" title="3.2.Fanout（广播分发）"></a>3.2.Fanout（广播分发）</h3><ol start="2"><li>Fanout：每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。 </li></ol><p><img src="/images/Java_heart_RabbitMQorMongoDB/clip_image004.gif" alt="image"> </p><h3 id="3-3-topic-交换器（模式匹配）"><a href="#3-3-topic-交换器（模式匹配）" class="headerlink" title="3.3.topic 交换器（模式匹配）"></a>3.3.topic 交换器（模式匹配）</h3><ol start="3"><li>topic 交换器：<strong>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上</strong>。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配 0 个或多个单词，匹配不多不少一个单词。 </li></ol><p><img src="/images/Java_heart_RabbitMQorMongoDB/image-20200430142746466.png" alt="image"></p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="4-概念"><a href="#4-概念" class="headerlink" title="4. 概念"></a>4. 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;MongoDB 是由 C++语言编写的，是一个基于分布式文件存储的开源数据库系统。<u>在高负载的情况下，添加更多的节点，可以保证服务器性能。</u>MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 </p><p><img src="/images/Java_heart_RabbitMQorMongoDB/image-20200430143008754.png" alt="image"></p><h2 id="6-特点"><a href="#6-特点" class="headerlink" title="6. 特点"></a>6. 特点</h2><p>•    MongoDB 是一个<strong>面向文档存储的数据库</strong>，操作起来比较简单和容易。 </p><p>•    你可以在 MongoDB 记录中<strong>设置任何属性的索引</strong> (如：FirstName=”Sameer”,Address=”8 Ga ndhi Road”)来实现更快的排序。 </p><p>•    你可以通过本地或者网络创建数据镜像，这使得 MongoDB 有更强的扩展性。 </p><p>•    如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以<strong>分布在计算机网络中的其他节点上这就是所谓的分片。</strong> </p><p>•    Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的对象及数组。</p><p>•    MongoDb 使用 <strong>update()命令可以实现替换完成的文档</strong>（数据）或者一些指定的数据字段 。 </p><p>•    Mongodb 中的 Map/reduce 主要是用来对数据进行批量处理和聚合操作。 </p><p>•    Map 和 Reduce。Map 函数调用 emit(key,value)遍历集合中所有的记录，将 key 与 value 传给 Reduce 函数进行处理。 </p><p>•    Map 函数和 Reduce 函数是使用 Javascript 编写的，并可以通过 db.runCommand 或 mapre duce 命令来执行 MapReduce 操作。 </p><p>•    <strong>GridFS 是 MongoDB 中的一个内置功能，可以用于存放大量小文件。</strong> </p><p>•    MongoDB 允许在服务端执行脚本，<strong>可以用 Javascript 编写某个函数，直接在服务端执行</strong>，也可以把函数的定义存储在服务端，下次直接调用即可。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ol><li>设计原则 </li><li>工厂方法模式 </li><li>抽象工厂模式 </li><li>单例模式</li><li>建造者模式 </li><li>原型模式 </li><li>适配器模式 </li><li>装饰器模式 </li><li>代理模式 </li><li>外观模式 </li><li>桥接模式 </li><li>组合模式 </li><li>享元模式 </li><li>策略模式 </li><li>模板方法模式 </li><li>观察者模式 </li><li>迭代子模式 </li><li>责任链模式 </li><li>命令模式 </li><li>备忘录模式 </li><li>状态模式 </li><li>访问者模式 </li><li>中介者模式 </li><li>解释器模式</li></ol><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RabbitMQ-架构&quot;&gt;&lt;a href=&quot;#RabbitMQ-架构&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 架构&quot;&gt;&lt;/a&gt;RabbitMQ 架构&lt;/h1&gt;&lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;p&gt;RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准&lt;/strong&gt;，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。&lt;/strong&gt;具体特点包括：&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="RabbitMQ" scheme="https://quietair.gitee.io/tags/RabbitMQ/"/>
    
      <category term="MongoDB" scheme="https://quietair.gitee.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(十一)之Hbase</title>
    <link href="https://quietair.gitee.io/Java_heart_Hbase/"/>
    <id>https://quietair.gitee.io/Java_heart_Hbase/</id>
    <published>2020-04-25T10:25:06.000Z</published>
    <updated>2020-05-04T07:04:49.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;base 是分布式、面向列的开源数据库（其实准确的说是面向列族）。HDFS 为 Hbase 提供可靠的底层数据存储服务，MapReduce 为 Hbase 提供高性能的计算能力，Zookeeper 为 Hbase 提供稳定服务和 Failover 机制，因此我们说 Hbase 是一个通过大量廉价的机器解决海量数据的高速存储和读取的分布式数据库解决方案。</p><a id="more"></a><h2 id="2-列式存储"><a href="#2-列式存储" class="headerlink" title="2. 列式存储"></a>2. 列式存储</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;列方式所带来的重要好处之一就是，由于查询中的选择规则是通过列来定义的，因此整个数据库是自动索引化的。 </p><p><img src="/images/Java_heart_Hbase/biubiubiu.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;这里的列式存储其实说的是列族存储，Hbase 是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。为了加深对 Hbase 列族的理解，下面是一个简单的关系</p><p><img src="/images/Java_heart_Hbase/clip_image014.gif" alt="img"></p><h2 id="3-Hbase核心概念"><a href="#3-Hbase核心概念" class="headerlink" title="3. Hbase核心概念"></a>3. Hbase核心概念</h2><h3 id="3-1-Column-Family-列族"><a href="#3-1-Column-Family-列族" class="headerlink" title="3.1. Column Family 列族"></a>3.1. Column Family 列族</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Column Family 又叫列族，Hbase 通过列族划分数据的存储，列族下面可以包含任意多的列，实现灵活的数据存取。Hbase 表的创建的时候就必须指定列族。就像关系型数据库创建的时候必须指定具体的列是一样的。Hbase的列族不是越多越好，官方推荐的是列族最好小于或者等于3。我们使用的场景一般是 1 个列族。 </p><h3 id="3-2-Rowkey（Rowkey查询，Rowkey-范围扫描，全表扫描）"><a href="#3-2-Rowkey（Rowkey查询，Rowkey-范围扫描，全表扫描）" class="headerlink" title="3.2. Rowkey（Rowkey查询，Rowkey 范围扫描，全表扫描）"></a>3.2. Rowkey（Rowkey查询，Rowkey 范围扫描，全表扫描）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Rowkey 的概念和 mysql 中的主键是完全一样的，Hbase 使用 Rowkey 来唯一的区分某一行的数据。<strong>Hbase 只支持 3 中查询方式：基于 Rowkey 的单行查询，基于 Rowkey 的范围扫描，全表扫描。</strong> </p><h3 id="3-3-Region-分区"><a href="#3-3-Region-分区" class="headerlink" title="3.3. Region 分区"></a>3.3. Region 分区</h3><ul><li>Region: Region 的概念和关系型数据库的分区或者分片差不多。Hbase 会将一个大表的数据基于 <strong>Rowkey 的不同范围分配到不通的 Region 中</strong>，每个 Region 负责一定范围的数据访问和存储。这样即使是一张巨大的表，由于被切割到不通的 region，访问起来的时延也很低。 </li></ul><h3 id="3-4-TimeStamp-多版本"><a href="#3-4-TimeStamp-多版本" class="headerlink" title="3.4. TimeStamp 多版本"></a>3.4. TimeStamp 多版本</h3><ul><li>TimeStamp 是实现 Hbase 多版本的关键。在 Hbase 中使用不同的 timestame 来标识相同 rowkey 行对应的不通版本的数据。在写入数据的时候，如果用户没有指定对应的timestamp，Hbase 会自动添加一个 timestamp，timestamp 和服务器时间保持一致。<u>在 Hbase 中，相同 rowkey 的数据按照 timestamp 倒序排列。默认查询的是最新的版本，用户可同指定 timestamp 的值来读取旧版本的数据。</u> </li></ul><h2 id="4-Hbase-核心架构"><a href="#4-Hbase-核心架构" class="headerlink" title="4. Hbase 核心架构"></a>4. Hbase 核心架构</h2><p><strong>Hbase 是由 Client、Zookeeper、Master、HRegionServer、HDFS</strong> 等几个组建组成。 </p><p><img src="/images/Java_heart_Hbase/clip_image016.gif" alt="img"> </p><h3 id="4-1-Client"><a href="#4-1-Client" class="headerlink" title="4.1. Client"></a>4.1. Client</h3><ul><li>Client 包含了访问 Hbase 的接口，另外 Client 还维护了对应的 cache 来加速 Hbase 的访问，比如 cache 的.META.元数据的信息。 </li></ul><h3 id="4-2-Zookeeper"><a href="#4-2-Zookeeper" class="headerlink" title="4.2. Zookeeper"></a>4.2. Zookeeper</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Hbase 通过 Zookeeper 来做 master 的高可用、RegionServer 的监控、元数据的入口以及集群配置的维护等工作。具体工作如下：</p><ol><li><p>通过 Zoopkeeper 来保证集群中只有 1 个 master 在运行，如果 master 异常，会通过竞争机制产生新的 master 提供服务 </p></li><li><p>通过 Zoopkeeper 来监控 RegionServer 的状态，当 RegionSevrer 有异常的时候，通过回调的形式通知 Master RegionServer 上下限的信息 </p></li><li><p><u>通过 Zoopkeeper 存储元数据的统一入口地址</u>。 </p></li></ol><h3 id="4-3-Hmaster"><a href="#4-3-Hmaster" class="headerlink" title="4.3. Hmaster"></a>4.3. Hmaster</h3><p>master 节点的主要职责如下： </p><ol><li><p>为 RegionServer 分配 Region </p></li><li><p>维护整个集群的负载均衡 </p></li><li><p>维护集群的元数据信息发现失效的 Region，并将失效的 Region 分配到正常 RegionServer 上当 RegionSever 失效的时候，协调对应 Hlog 的拆分 </p></li></ol><h3 id="4-4-HregionServer"><a href="#4-4-HregionServer" class="headerlink" title="4.4. HregionServer"></a>4.4. HregionServer</h3><p>HregionServer 直接对接用户的读写请求，是真正的“干活”的节点。它的功能概括如下： </p><ol><li><p>管理 master 为其分配的 Region </p></li><li><p>处理来自客户端的读写请求 </p></li><li><p>负责和底层 HDFS 的交互，存储数据到 HDFS </p></li><li><p>负责 Region 变大以后的拆分</p></li><li><p>负责 Storefile 的合并工作</p></li></ol><h3 id="4-5-Region寻址方式（通过-zookeeper-META）"><a href="#4-5-Region寻址方式（通过-zookeeper-META）" class="headerlink" title="4.5.Region寻址方式（通过 zookeeper .META）"></a>4.5.Region寻址方式（通过 zookeeper .META）</h3><p>第 1 步：Client 请求 ZK 获取.META.所在的 RegionServer 的地址。 </p><p>第 2 步：Client 请求.META.所在的 RegionServer 获取访问数据所在的 RegionServer 地址，client 会将.META.的相关信息 cache 下来，以便下一次快速访问。 </p><p>第 3 步：Client 请求数据所在的 RegionServer，获取所需要的数据。 </p><p><img src="/images/Java_heart_Hbase/clip_image018.gif" alt="img"> </p><h3 id="4-6-HDFS"><a href="#4-6-HDFS" class="headerlink" title="4.6.HDFS"></a>4.6.HDFS</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;HDFS 为 Hbase 提供最终的底层数据存储服务，同时为 Hbase 提供高可用（Hlog 存储在HDFS）的支持。  </p><h2 id="5-Hbase的写逻辑"><a href="#5-Hbase的写逻辑" class="headerlink" title="5. Hbase的写逻辑"></a>5. Hbase的写逻辑</h2><h3 id="5-1-Hbase的写入流程"><a href="#5-1-Hbase的写入流程" class="headerlink" title="5.1. Hbase的写入流程"></a>5.1. Hbase的写入流程</h3><p><img src="/images/Java_heart_Hbase/clip_image020.jpg" alt="img"> </p><p>从上图可以看出氛围 3 步骤： </p><p><strong>获取RegionServer</strong></p><p>第 1 步：Client 获取数据写入的 Region 所在的 RegionServer </p><p><strong>请求写Hlog</strong></p><p>第 2 步：请求写 Hlog, Hlog 存储在 HDFS，当 RegionServer 出现异常，需要使用 Hlog 来恢复数据。 </p><p><strong>请求写MemStore</strong></p><p>第 3 步：请求写 MemStore,只有当写 Hlog 和写 MemStore 都成功了才算请求写入完成。 <u>MemStore 后续会逐渐刷到 HDFS 中。</u> </p><h3 id="5-2-MemStore刷盘"><a href="#5-2-MemStore刷盘" class="headerlink" title="5.2. MemStore刷盘"></a>5.2. MemStore刷盘</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;为了提高 Hbase 的写入性能，当写请求写入 MemStore 后，不会立即刷盘。而是会等到一定的时候进行刷盘的操作。具体是哪些场景会触发刷盘的操作呢？总结成如下的几个场景：</p><p><strong>全局内存控制</strong> </p><ol><li>这个全局的参数是控制内存整体的使用情况，当所有 memstore 占整个 heap 的最大比例的时候，会触发刷盘的操作。这个参数是hbase.regionserver.global.memstore.upperLimit，默认为整个 heap 内存的 40%。但这并不意味着全局内存触发的刷盘操作会将所有的 MemStore 都进行输盘，而是通过另外一个参数 hbase.regionserver.global.memstore.lowerLimit 来控制，默认是整个 heap 内存的 35%。当 flush 到所有 memstore 占整个 heap 内存的比率为 35%的时候，就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响，实现平滑系统负载的目的。 </li></ol><p><strong>MemStore达到上限</strong> </p><ol start="2"><li>当 MemStore 的大小达到 hbase.hregion.memstore.flush.size 大小的时候会触发刷盘，默认 128M 大小 </li></ol><p><strong>RegionServer 的Hlog数量达到上限</strong> </p><ol start="3"><li>前面说到 Hlog 为了保证 Hbase 数据的一致性，那么如果 Hlog 太多的话，会导致故障恢复的时间太长，因此 Hbase 会对 Hlog 的最大个数做限制。当达到 Hlog 的最大个数的时候，会强制刷盘。这个参数是 hase.regionserver.max.logs，默认是 32 个。 </li></ol><p><strong>手工触发</strong> </p><ol start="4"><li>可以通过 hbase shell 或者 java api 手工触发 flush 的操作。 </li></ol><p><strong>关闭RegionServer触发</strong> </p><ol start="5"><li>在正常关闭 RegionServer 会触发刷盘的操作，全部数据刷盘后就不需要再使用 Hlog 恢复数据。 </li></ol><p><strong>Region使用HLOG恢复完数据后触发</strong> </p><ol start="6"><li>：当 RegionServer 出现故障的时候，其上面的 Region 会迁移到其他正常的 RegionServer 上，在恢复完 Region 的数据后，会触发刷盘，当刷盘完成后才会提供给业务访问。 </li></ol><h2 id="6-HBase-vs-Cassandra"><a href="#6-HBase-vs-Cassandra" class="headerlink" title="6. HBase vs Cassandra"></a>6. HBase vs Cassandra</h2><table><thead><tr><th></th><th><strong>HBase</strong></th><th><strong>Cassandra</strong></th></tr></thead><tbody><tr><td>语言</td><td>Java</td><td>Java</td></tr><tr><td>出发点</td><td>BigTable</td><td>BigTable and Dynamo</td></tr><tr><td>License</td><td>Apache</td><td>Apache</td></tr><tr><td>Protocol</td><td>HTTP/REST (also Thrift)</td><td>Custom, binary (Thrift)</td></tr><tr><td>数据分布</td><td>表划分为多个 region  存在不同 region   server 上</td><td>改进的一致性哈希（虚拟节点）</td></tr><tr><td>存储目标</td><td>大文件</td><td>小文件</td></tr><tr><td>一致性</td><td>强一致性</td><td>最终一致性，Quorum NRW 策略</td></tr><tr><td>架构</td><td>master/slave</td><td>p2p</td></tr><tr><td>高可用性</td><td>NameNode 是 HDFS 的单点故障点</td><td>P2P 和去中心化设计，不会出现单点故障</td></tr><tr><td>伸缩性</td><td>Region Server 扩容，通过将自身发布到  Master，Master 均匀分布 Region</td><td>扩容需在 Hash Ring 上多个节点间调整数据分布</td></tr><tr><td>读写性能</td><td>数据读写定位可能要通过最多 6 次的网络 RPC，性能较低。</td><td>数据读写定位非常快</td></tr><tr><td>数据冲突处理</td><td>乐观并发控制（optimistic  concurrency control）</td><td>向量时钟</td></tr><tr><td>临时故障处理</td><td>Region Server 宕机，重做 HLog</td><td>数据回传机制：某节点宕机，hash 到该节点的新数据自  动路由到下一节点做 hinted  handoff，源节点恢复后，推送回源节点。</td></tr><tr><td>永久故障恢复</td><td>Region Server  恢复，master 重新给其分配 region</td><td>Merkle 哈希树，通过 Gossip 协议同步 Merkle Tree，维  护集群节点间的数据一致性</td></tr><tr><td>成员通信及错误检测</td><td>Zookeeper</td><td>基于 Gossip</td></tr><tr><td>CAP</td><td>1，强一致性，0 数据丢失。2，可用性低。3，扩容方便。</td><td>1，弱一致性，数据可能丢失。2，可用性高。3，扩容方便。</td></tr></tbody></table><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7. 最后"></a>7. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;base 是分布式、面向列的开源数据库（其实准确的说是面向列族）。HDFS 为 Hbase 提供可靠的底层数据存储服务，MapReduce 为 Hbase 提供高性能的计算能力，Zookeeper 为 Hbase 提供稳定服务和 Failover 机制，因此我们说 Hbase 是一个通过大量廉价的机器解决海量数据的高速存储和读取的分布式数据库解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Hbase" scheme="https://quietair.gitee.io/tags/Hbase/"/>
    
      <category term="Zookeeper" scheme="https://quietair.gitee.io/tags/Zookeeper/"/>
    
      <category term="HDFS" scheme="https://quietair.gitee.io/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(十)之Zookeeper、Kafka</title>
    <link href="https://quietair.gitee.io/Java_heart_ZookeeperorKafka/"/>
    <id>https://quietair.gitee.io/Java_heart_ZookeeperorKafka/</id>
    <published>2020-04-18T06:31:37.000Z</published>
    <updated>2020-05-04T07:04:50.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="1-Zookeeper-概念"><a href="#1-Zookeeper-概念" class="headerlink" title="1. Zookeeper 概念"></a>1. Zookeeper 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Zookeeper 是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。Zookeeper 提供了一个类似于 Linux 文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。</p><a id="more"></a><h2 id="2-Zookeeper-角色"><a href="#2-Zookeeper-角色" class="headerlink" title="2. Zookeeper 角色"></a>2. Zookeeper 角色</h2><p>Zookeeper 集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种</p><h3 id="2-1-Leader"><a href="#2-1-Leader" class="headerlink" title="2.1. Leader"></a>2.1. Leader</h3><ol><li><p>一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader，它会发起并维护与各 Follwer 及 Observer 间的心跳。 </p></li><li><p>所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。只要有超过半数节点（不包括 observeer 节点）写入成功，该写请求就会被提交（类 2PC 协议）。 </p></li></ol><h3 id="2-2-Follower"><a href="#2-2-Follower" class="headerlink" title="2.2. Follower"></a>2.2. Follower</h3><ol><li><p>一个 Zookeeper 集群可能同时存在多个 Follower，它会响应 Leader 的心跳， </p></li><li><p>Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理， </p></li><li><p>并且负责在 Leader 处理写请求时对请求进行投票。 </p></li></ol><h3 id="2-3-Observer"><a href="#2-3-Observer" class="headerlink" title="2.3. Observer"></a>2.3. Observer</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;角色与 Follower 类似，但是无投票权。Zookeeper 需保证高可用和强一致性，为了支持更多的客户端，需要增加更多 Server；<u>Server 增多，投票阶段延迟增大，影响性能；引入 Observer， Observer 不参与投票； Observers 接受客户端的连接，并将写请求转发给 leader 节点；</u> 加入更多 Observer 节点，提高伸缩性，同时不影响吞吐率。 </p><p><img src="/images/Java_heart_ZookeeperorKafka/clip_image003.gif" alt="img"> </p><h3 id="2-4-ZAB-协议"><a href="#2-4-ZAB-协议" class="headerlink" title="2.4. ZAB 协议"></a>2.4. ZAB 协议</h3><p><strong>事务编号 Zxid（事务请求计数器+ epoch）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 ZAB ( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议） 协议的事务编号 Zxid 设计中，Zxid 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，<u>针对客户端每一个事务请求，计数器加 1；</u>而高 32 位则代表 Leader 周期 epoch 的编号，<u>每个当选产生一个新的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务的 ZXID，并从中读取 epoch 值，然后加 1，以此作为新的 epoch，</u>并将低 32 位从 0 开始计数。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Zxid（Transaction id）类似于 RDBMS 中的事务 ID，用于标识一次更新操作的 Proposal（提议） ID。为了保证顺序性，该 zkid 必须单调递增。 </p><p><strong>epoch</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;epoch：可以理解为当前集群所处的年代或者周期，每个 leader 就像皇帝，都有自己的年号，所以每次改朝换代，leader 变更之后，都会在前一个年代的基础上加 1。这样就算<u>旧的 leader 崩溃恢复之后，也没有人听他的了，因为 follower 只听从当前年代的 leader 的命令。</u> </p><p><strong>Zab协议有两种模式-恢复模式（选主）、广播模式（同步）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Zab协议有两种模式，它们分别是<u>恢复模式（选主）和广播模式（同步）</u>。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。 </p><p><strong>ZAB协议4阶段</strong> </p><p><strong>Leader election（选举阶段-选出准Leader）</strong> </p><ol><li>Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 广播阶段（broadcast） 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。 </li></ol><p><strong>Discovery（发现阶段-接受提议、生成epoch、接受epoch）</strong> </p><ol start="2"><li>Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且准 leader 生成新的 epoch，让 followers 接受，更新它们的 accepted Epoch 一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入重新选举阶段。 </li></ol><p><strong>Synchronization（同步阶段-同步follower副本）</strong> </p><ol start="3"><li>Synchronization（同步阶段）：同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。只有当 大多数节点都同步完成，准 leader 才会成为真正的 leader。 follower 只会接收 zxid 比自己的 lastZxid 大的提议。 </li></ol><p><strong>Broadcast（广播阶段-leader消息广播）</strong> </p><ol start="4"><li>Broadcast（广播阶段）：到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。 </li></ol><p>ZAB 提交事务并不像 2PC 一样需要全部 follower 都 ACK，只需要得到超过半数的节点的 ACK 就可以了。 </p><p><strong>ZAB协议JAVA 实现（FLE-发现阶段和同步合并为 Recovery Phase（恢复阶段））</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;协议的 Java 版本实现跟上面的定义有些不同，选举阶段使用的是 Fast Leader Election（FLE），它包含了 选举的发现职责。因为 FLE 会选举拥有最新提议历史的节点作为 leader，这样就省去了发现最新提议的步骤。实际的实现将 发现阶段 和 同步合并为 Recovery Phase（恢复阶段）。所以，ZAB 的实现只有三个阶段：Fast Leader Election；Recovery Phase；Broadcast Phase。 </p><h3 id="2-5-投票机制"><a href="#2-5-投票机制" class="headerlink" title="2.5. 投票机制"></a>2.5. 投票机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>每个 sever 首先给自己投票，然后用自己的选票和其他 sever 选票对比，权重大的胜出，使用权重较大的更新自身选票箱。</u>具体选举过程如下：</p><ol><li><p>每个 Server 启动以后<strong>都询问其它的 Server 它要投票给谁</strong>。对于其他 server 的询问， server 每次根据自己的状态都回复自己推荐的 leader 的 id 和上一次处理事务的 zxid（系统启动时每个 server 都会推荐自己） </p></li><li><p>收到所有 Server 回复以后，就<strong>计算出 zxid 最大的哪个 Server</strong>，并将这个 Server 相关信息设置成下一次要投票的 Server。 </p></li><li><p>计算这过程中<strong>获得票数最多的的 sever 为获胜者</strong>，如果获胜者的票数超过半数，则改 server 被选为 leader。否则，继续这个过程，直到 leader 被选举出来  </p></li><li><p>leader 就会开始等待 server 连接</p></li><li><p>Follower 连接 leader，将最大的 zxid 发送给 leader </p></li><li><p>Leader 根据 follower 的 zxid 确定同步点，至此选举阶段完成。 </p></li><li><p>选举阶段完成 Leader 同步后通知 follower 已经成为 uptodate 状态 </p></li><li><p>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;目前有 5 台服务器，每台服务器均没有数据，它们的编号分别是 1,2,3,4,5,按编号依次启动，它们的选择举过程如下： </p><ol><li><p>服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 Looking。 </p></li><li><p>服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。 </p></li><li><p>服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器1,2 成为小弟。</p></li><li><p>服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。 </p></li><li><p>服务器 5 启动，后面的逻辑同服务器 4 成为小弟。 </p></li></ol><h2 id="3-Zookeeper工作原理（原子广播）"><a href="#3-Zookeeper工作原理（原子广播）" class="headerlink" title="3. Zookeeper工作原理（原子广播）"></a>3. Zookeeper工作原理（原子广播）</h2><ol><li><p><strong>Zookeeper 的核心是原子广播</strong>，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。 </p></li><li><p>当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 的完成了和 leader 的状态同步以后，恢复模式就结束了。</p></li><li><p>状态同步保证了 leader 和 server 具有相同的系统状态 </p></li><li><p><strong>一旦 leader 已经和多数的 follower 进行了状态同步后，他就可以开始广播消息了</strong>，即进入广播状态。这时候当一个 server 加入 zookeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。Zookeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。 </p></li><li><p>广播模式需要保证 proposal 被按顺序处理，因此 zk 采用了递增的事务 id 号(zxid)来保证。所有的提议(proposal)都在被提出的时候加上了 zxid。 </p></li><li><p>实现中 zxid 是一个 64 为的数字，它高 32 位是 epoch 用来标识 leader 关系是否改变，每次一个 leader 被选出来，它都会有一个新的 epoch。低 32 位是个递增计数。 </p></li><li><p>当 leader 崩溃或者 leader 失去大多数的 follower，这时候 zk 进入恢复模式，恢复模式需要重新选举出一个新的 leader，让所有的 server 都恢复到一个正确的状态。 </p></li></ol><h2 id="4-Znode有四种形式的目录节点"><a href="#4-Znode有四种形式的目录节点" class="headerlink" title="4. Znode有四种形式的目录节点"></a>4. Znode有四种形式的目录节点</h2><ol><li><p>PERSISTENT：持久的节点。 </p></li><li><p>EPHEMERAL：暂时的节点。 </p></li><li><p>PERSISTENT_SEQUENTIAL：持久化顺序编号目录节点。 </p></li><li><p>EPHEMERAL_SEQUENTIAL：暂时化顺序编号目录节点。 </p></li></ol><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="5-Kafka概念"><a href="#5-Kafka概念" class="headerlink" title="5. Kafka概念"></a>5. Kafka概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用 Scala 语言编写，目前是 Apache 的开源项目。 </p><ol><li><p>broker：Kafka 服务器，负责消息存储和转发</p></li><li><p>topic：消息类别，Kafka 按照 topic 来分类消息 </p></li><li><p>partition：topic 的分区，一个 topic 可以包含多个 partition，topic 消息保存在各个 partition 上 </p></li><li><p>offset：消息在日志中的位置，可以理解是消息在 partition 上的偏移量，也是代表该消息的唯一序号 </p></li><li><p>Producer：消息生产者 </p></li><li><p>Consumer：消息消费者 </p></li><li><p>Consumer Group：消费者分组，每个 Consumer 必须属于一个 group </p></li><li><p>Zookeeper：保存着集群 broker、topic、partition 等 meta 数据；另外，还负责 broker 故障发现，partition leader 选举，负载均衡等功能 </p></li></ol><p><img src="/images/Java_heart_ZookeeperorKafka/clip_image005.gif" alt="img"> </p><h2 id="6-Kafka-数据存储设计"><a href="#6-Kafka-数据存储设计" class="headerlink" title="6. Kafka 数据存储设计"></a>6. Kafka 数据存储设计</h2><h3 id="6-1-partition的数据文件（offset，MessageSize，data）"><a href="#6-1-partition的数据文件（offset，MessageSize，data）" class="headerlink" title="6.1. partition的数据文件（offset，MessageSize，data）"></a>6.1. partition的数据文件（offset，MessageSize，data）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;partition中的每条Message包含了以下三个属性：offset，MessageSize，data，其中<u>offset表示 Message 在这个 partition 中的偏移量，offset 不是该 Message 在 partition 数据文件中的实际存储位置，而是逻辑上一个值</u>，它唯一确定了partition中的一条Message，可以认为offset是 partition 中 Message 的 id；MessageSize 表示消息内容 data 的大小；data 为 Message 的具体内容。 </p><h3 id="6-2-数据文件分段-segment（顺序读写、分段命令、二分查找）"><a href="#6-2-数据文件分段-segment（顺序读写、分段命令、二分查找）" class="headerlink" title="6.2. 数据文件分段 segment（顺序读写、分段命令、二分查找）"></a>6.2. 数据文件分段 segment（顺序读写、分段命令、二分查找）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;partition 物理上由多个 segment 文件组成，每个 segment 大小相等，顺序读写。每个 segment 数据文件以该段中最小的 offset 命名，文件扩展名为.log。这样在查找指定 offset 的 Message 的时候，用二分查找就可以定位到该 Message 在哪个 segment 数据文件中。 </p><h3 id="6-3-数据文件索引（分段索引、稀疏存储）"><a href="#6-3-数据文件索引（分段索引、稀疏存储）" class="headerlink" title="6.3. 数据文件索引（分段索引、稀疏存储）"></a>6.3. 数据文件索引（分段索引、稀疏存储）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka 为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。index 文件中并没有为数据文件中的每条 Message 建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。</p><p><img src="/images/Java_heart_ZookeeperorKafka/clip_image007.gif" alt="img"> </p><h2 id="7-生产者设计"><a href="#7-生产者设计" class="headerlink" title="7. 生产者设计"></a>7. 生产者设计</h2><h3 id="7-1-负载均衡（partition-会均衡分布到不同-broker-上）"><a href="#7-1-负载均衡（partition-会均衡分布到不同-broker-上）" class="headerlink" title="7.1. 负载均衡（partition 会均衡分布到不同 broker 上）"></a>7.1. 负载均衡（partition 会均衡分布到不同 broker 上）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;由于消息 topic 由多个 partition 组成，且 <strong>partition 会均衡分布到不同 broker 上，因此，为了有效利用 broker 集群的性能，提高消息的吞吐量</strong>，producer 可以通过随机或者 hash 等方式，将消息平均发送到多个 partition 上，以实现负载均衡。</p><p><img src="/images/Java_heart_ZookeeperorKafka/clip_image009.gif" alt="img"> </p><h3 id="7-2-批量发送"><a href="#7-2-批量发送" class="headerlink" title="7.2. 批量发送"></a>7.2. 批量发送</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是提高消息吞吐量重要的方式，Producer 端可以在内存中合并多条消息后，<strong>以一次请求的方式发送了批量的消息给 broker</strong>，从而大大减少 broker 存储消息的 IO 操作次数。但也一定程度上影响了消息的实时性，相当于以时延代价，换取更好的吞吐量。 </p><h3 id="7-3-压缩（GZIP或-Snappy）"><a href="#7-3-压缩（GZIP或-Snappy）" class="headerlink" title="7.3. 压缩（GZIP或 Snappy）"></a>7.3. 压缩（GZIP或 Snappy）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Producer 端可以通过 GZIP 或 Snappy 格式对消息集合进行压缩。Producer 端进行压缩之后，在 Consumer 端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大数据处理上，瓶颈往往体现在网络上而不是 CPU（压缩和解压会耗掉部分 CPU 资源）。 </p><h2 id="8-消费者设计"><a href="#8-消费者设计" class="headerlink" title="8. 消费者设计"></a>8. 消费者设计</h2><p><img src="/images/Java_heart_ZookeeperorKafka/clip_image011.jpg" alt="img"> </p><h3 id="8-1-Consumer-Group"><a href="#8-1-Consumer-Group" class="headerlink" title="8.1. Consumer Group"></a>8.1. Consumer Group</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;同一 Consumer Group 中的多个 Consumer 实例，不同时消费同一个 partition，等效于队列模式。partition 内消息是有序的，Consumer 通过 pull 方式消费消息。Kafka 不删除已消费的消息 对于 partition，顺序读写磁盘数据，以时间复杂度 O(1)方式提供消息持久化能力。 </p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Zookeeper&quot;&gt;&lt;a href=&quot;#Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper&quot;&gt;&lt;/a&gt;Zookeeper&lt;/h1&gt;&lt;h2 id=&quot;1-Zookeeper-概念&quot;&gt;&lt;a href=&quot;#1-Zookeeper-概念&quot; class=&quot;headerlink&quot; title=&quot;1. Zookeeper 概念&quot;&gt;&lt;/a&gt;1. Zookeeper 概念&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Zookeeper 是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。Zookeeper 提供了一个类似于 Linux 文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Zookeeper" scheme="https://quietair.gitee.io/tags/Zookeeper/"/>
    
      <category term="Kafka" scheme="https://quietair.gitee.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(九)之日志</title>
    <link href="https://quietair.gitee.io/Java_heart_log/"/>
    <id>https://quietair.gitee.io/Java_heart_log/</id>
    <published>2020-04-12T06:31:37.000Z</published>
    <updated>2020-05-04T07:04:49.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Slf4j"><a href="#1-Slf4j" class="headerlink" title="1. Slf4j"></a>1. Slf4j</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带的 java.util.logging.Logger 等。 </p><a id="more"></a><h2 id="2-Log4j"><a href="#2-Log4j" class="headerlink" title="2. Log4j"></a>2. Log4j</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p><p>Log4j由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。 </p><ol><li><p>Logger：控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制</p></li><li><p>Appenders : 指定了日志将打印到控制台还是文件中</p></li><li><p>Layout : 控制日志信息的显示格式</p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;Log4j 中将要输出的 Log 信息定义了 5 种级别，依次为 DEBUG、INFO、WARN、ERROR 和 FATAL，当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码。 </p><h2 id="3-LogBack"><a href="#3-LogBack" class="headerlink" title="3. LogBack"></a>3. LogBack</h2><p>简单地说，Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。 </p><p>Logback 主要由三个模块组成：<strong>logback-core，logback-classic。logback-access</strong> </p><p>logback-core 是其它模块的基础设施，其它模块基于它构建，显然，logback-core 提供了一些关键的通用机制。 </p><p>logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单日志门面 SLF4J； </p><p>logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与 </p><p>HTTP 访问相关的功能。 </p><h3 id="3-1-Logback优点"><a href="#3-1-Logback优点" class="headerlink" title="3.1. Logback优点"></a>3.1. Logback优点</h3><ul><li>同样的代码路径，Logback 执行更快 </li><li>更充分的测试</li><li>原生实现了 SLF4J API（Log4J 还需要有一个中间转换层） </li><li>内容更丰富的文档</li><li>支持 XML 或者 Groovy 方式配置 </li><li>配置文件自动热加载</li><li>从 IO 错误中优雅恢复 </li><li>自动删除日志归档</li><li>自动压缩日志成为归档文件</li><li>支持 Prudent 模式，使多个 JVM 进程能记录同一个日志文件 </li><li>支持配置文件中加入条件判断来适应不同的环境</li><li>更强大的过滤器</li><li>支持 SiftingAppender（可筛选 Appender） </li><li>异常栈信息带有包信息 </li></ul><h2 id="4-ELk"><a href="#4-ELk" class="headerlink" title="4. ELk"></a>4. ELk</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;ELK 是软件集合 Elasticsearch、Logstash、Kibana 的简称，由这三个软件及其相关的组件可以打造大规模日志实时处理系统。</p><ul><li>Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，主要负责将日志索引并存储起来，方便业务方检索查询。 </li><li>Logstash 是一个日志收集、过滤、转发的中间件，主要负责将各条业务线的各类日志统一收集、过滤后，转发给 Elasticsearch 进行下一步处理。 </li><li>Kibana 是一个可视化工具，主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业务方，比如各类饼图、直方图、区域图等。 </li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;( 1.Filebeat; 2.Filebeat; 3.Filebeat ) –&gt; Redis –&gt; Logstash –&gt; Elasticsearch  –&gt; Kibana </p><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Slf4j&quot;&gt;&lt;a href=&quot;#1-Slf4j&quot; class=&quot;headerlink&quot; title=&quot;1. Slf4j&quot;&gt;&lt;/a&gt;1. Slf4j&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带的 java.util.logging.Logger 等。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(八)之网络</title>
    <link href="https://quietair.gitee.io/Java_heart_network/"/>
    <id>https://quietair.gitee.io/Java_heart_network/</id>
    <published>2020-04-11T05:24:47.000Z</published>
    <updated>2020-05-04T07:04:49.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-网络7层架构"><a href="#1-网络7层架构" class="headerlink" title="1. 网络7层架构"></a>1. 网络7层架构</h2><p><strong>7 层模型主要包括：</strong> </p><ol><li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为 1、0，也就是我们常说的<strong>模数转换与数模转换</strong>）。这一层的数据叫做比特。</li></ol><a id="more"></a><ol start="2"><li><p>数据链路层：主要将从物理层接收的数据进行 <strong>MAC 地址（网卡的地址）的封装与解封装</strong>。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。  </p></li><li><p>网络层：主要将从下层接收到的数据进行 <strong>IP 地址（例 192.168.0.1)的封装与解封装</strong>。在这一层工作的设备是<strong>路由器</strong>，常把这一层的数据叫做数据包。 </p></li><li><p>传输层：定义了一些<strong>传输数据的协议和端口号</strong>（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。  </p></li><li><p>会话层：通过传输层（端口号：传输端口与接收端口）<strong>建立数据传输的通路</strong>。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）  </p></li><li><p>表示层：主要是进行对接收的数据进行<strong>解释、加密与解密、压缩与解压缩</strong>等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））  </p></li><li><p>应用层：主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你 就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。</p></li></ol><p><img src="/images/Java_heart_network/image-01.png" alt="image-20200415130931301"></p><h2 id="2-TCP-IP原理"><a href="#2-TCP-IP原理" class="headerlink" title="2. TCP/IP原理"></a>2. TCP/IP原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。从协议分层模型方面来讲，TCP/IP 由四个层次组成：网络接口层、网络层、传输层、应用层。</p><p><img src="/images/Java_heart_network/clip_image002.jpg" alt="img"> </p><h3 id="2-1-网络访问层-Network-Access-Layer"><a href="#2-1-网络访问层-Network-Access-Layer" class="headerlink" title="2.1. 网络访问层(Network Access Layer)"></a>2.1. 网络访问层(Network Access Layer)</h3><ol><li>网络访问层(Network Access Layer)在 TCP/IP 参考模型中并没有详细描述，只是指出<strong>主机必须使用某种协议与网络相连</strong>。 </li></ol><h3 id="2-2-网络层-Internet-Layer"><a href="#2-2-网络层-Internet-Layer" class="headerlink" title="2.2. 网络层(Internet Layer)"></a>2.2. 网络层(Internet Layer)</h3><ol start="2"><li>网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。<strong>互联网层使用因特网协议(IP，Internet Protocol)</strong>。 </li></ol><h3 id="2-3-传输层-Tramsport-Layer-TCP-UDP"><a href="#2-3-传输层-Tramsport-Layer-TCP-UDP" class="headerlink" title="2.3. 传输层(Tramsport Layer-TCP/UDP)"></a>2.3. 传输层(Tramsport Layer-TCP/UDP)</h3><ol start="3"><li>传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。<strong>在这一层定义了两个端到端的协议</strong>：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。<strong>TCP</strong> 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。<strong>UDP</strong> 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。 </li></ol><h3 id="2-4-应用层-Application-Layer"><a href="#2-4-应用层-Application-Layer" class="headerlink" title="2.4. 应用层(Application Layer)"></a>2.4. 应用层(Application Layer)</h3><ol start="4"><li>应用层(Application Layer)包含所有的高层协议，包括：<u>虚拟终端协议(TELNET， TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。</u> </li></ol><h2 id="3-TCP-三次握手-四次挥手"><a href="#3-TCP-三次握手-四次挥手" class="headerlink" title="3. TCP 三次握手/四次挥手"></a>3. TCP 三次握手/四次挥手</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP 在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般称为“四次挥手”。 </p><h3 id="3-1-数据包说明"><a href="#3-1-数据包说明" class="headerlink" title="3.1. 数据包说明"></a>3.1. 数据包说明</h3><ol><li><p>源端口号（ 16 位）：它（连同源主机 IP 地址）标识源主机的一个应用进程。 </p></li><li><p>目的端口号（ 16 位）：它（连同目的主机 IP 地址）标识目的主机的一个应用进程。这两个值<strong>加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接</strong>。 </p></li><li><p>顺序号 seq（ 32 位）：<strong>用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号</strong>。如果将字节流看作在两个应用程序间的单向流动，则 <strong>TCP 用顺序号对每个字节进行计数</strong>。序号是 32bit 的无符号数，<strong>序号到达 2 的 32 次方 － 1 后又从 0 开始。当建立一个新的连接时， SYN 标志变 1</strong> ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ）。 </p></li><li><p>确认号 ack（ 32 位）：<strong>包含发送确认的一端所期望收到的下一个顺序号</strong>。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。<strong>只有 ACK 标志为 1 时确认序号字段才有效</strong>。 TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。</p></li><li><p>TCP 报头长度（ 4 位）：给出报头中 32bit 字的数目，<strong>它实际上指明数据从哪里开始</strong>。需要这个值是因为任选字段的长度是可变的。这个字段占 4bit ，因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节。 </p></li><li><p>保留位（ 6 位）：保留给将来使用，目前必须置为 0 。 </p></li><li><p><strong>控制位（ control flags ， 6 位）：在 TCP 报头中有 6 个标志比特，它们中的多个可同时被设置为 1 。依次为：</strong> </p></li></ol><ul><li><p>URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。 </p></li><li><p>ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。 </p></li><li><p>PSH ：为 1 表示是带有 PUSH 标志的数据，<strong>指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满</strong>。 </p></li><li><p>RST ：<strong>用于复位由于主机崩溃或其他原因而出现错误的连接</strong>。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。 </p></li><li><p>SYN ：同步序号，<strong>为 1 表示连接请求</strong>，用于建立连接和使顺序号同步（ synchronize ）。 </p></li><li><p>FIN ：<strong>用于释放连接</strong>，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。</p></li></ul><ol start="8"><li><p>窗口大小（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节。 </p></li><li><p>校验和（ 16 位）：此校验和是对整个的 TCP 报文段，<strong>包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得</strong>。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。 </p></li><li><p>紧急指针（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。<strong>TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式</strong>。</p></li><li><p>选项：最常见的可选字段是最长报文大小，又称为 MSS(Maximum Segment Size) 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，它<strong>指明本端所能接收的最大长度的报文段</strong>。选项长度不一定是 32 位字的整数倍，所以要加填充位，使得报头长度成为整字数。 </p></li><li><p>数据： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p></li></ol><p><img src="/images/Java_heart_network/clip_image004.jpg" alt="img"> </p><h3 id="3-2-三次握手"><a href="#3-2-三次握手" class="headerlink" title="3.2. 三次握手"></a>3.2. 三次握手</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第一次握手：主机 A 发送位码为 <strong>syn＝1</strong>,随机产生 <strong>seq number=1234567</strong> 的数据包到服务器，主机 B 由 SYN=1 知道，A 要求建立联机； </p><p>&nbsp;&nbsp;&nbsp;&nbsp;第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 <strong>ack number=(主机 A 的 seq+1),syn=1,ack=1,随机产生 seq=7654321 的包</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;第三次握手：<strong>主机 A 收到后检查 ack number 是否正确</strong>，即第一次发送的 seq number+1,以及位码 ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。</p><p><img src="/images/Java_heart_network/clip_image006.gif" alt="img"> </p><h3 id="3-3-四次挥手"><a href="#3-3-四次挥手" class="headerlink" title="3.3. 四次挥手"></a>3.3. 四次挥手</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 <strong>TCP 的半关闭造成的</strong>。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。 </p><p>  1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u </p><p>  2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。 </p><p>  3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。 </p><p>  4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。   </p><p>首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 </p><p><img src="/images/Java_heart_network/clip_image008.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给 B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL 后，A 才进入到 close 状态。 </p><h2 id="4-HTTP-原理"><a href="#4-HTTP-原理" class="headerlink" title="4. HTTP 原理"></a>4. HTTP 原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP是一个无状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。 </p><h3 id="4-1-传输流程"><a href="#4-1-传输流程" class="headerlink" title="4.1. 传输流程"></a>4.1. 传输流程</h3><p><strong>1：地址解析</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如用客户端浏览器请求这个页面：<a href="http://localhost.com:8080/index.htm" target="_blank" rel="noopener">http://localhost.com:8080/index.htm</a> 从中分解出协议名、主机名、</p><p>端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下： </p><p>协议名：http   </p><p>主机名：localhost.com   </p><p>端口：8080   </p><p>对象路径：/index.htm    </p><p>在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。 </p><p><strong>2：封装HTTP请求数据包</strong> </p><p>把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包 </p><p><strong>3：封装成TCP包并建立连接</strong>    </p><p>封装成 TCP 包，建立 TCP 连接（TCP 的三次握手） </p><p><strong>4：客户机发送请求命</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。</p><p><strong>5：服务器响应</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;服务器接到请求后，给予相应的响应信息，<u>其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容</u>。 </p><p><strong>6：服务器关闭TCP连接</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;服务器关闭 TCP 连接：一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 <u>Connection:keep-alive，TCP 连接在发送后将仍然保持打开状态</u>，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><p><img src="/images/Java_heart_network/clip_image010.jpg" alt="img"> </p><h3 id="4-2-HTTP-状态"><a href="#4-2-HTTP-状态" class="headerlink" title="4.2. HTTP 状态"></a>4.2. HTTP 状态</h3><table><thead><tr><th><strong>状态码</strong></th><th><strong>原因短语</strong></th></tr></thead><tbody><tr><td></td><td><strong>消息响应</strong></td></tr><tr><td>100</td><td>Continue(继续)</td></tr><tr><td>101</td><td>Switching Protocol(切换协议)</td></tr><tr><td></td><td><strong>成功响应</strong></td></tr><tr><td>200</td><td>OK(成功)</td></tr><tr><td>201</td><td>Created(已创建)</td></tr><tr><td>202</td><td>Accepted(已创建)</td></tr><tr><td>203</td><td>Non-Authoritative  Information(未授权信息)</td></tr><tr><td>204</td><td>No  Content(无内容)</td></tr><tr><td>205</td><td>Reset  Content(重置内容)</td></tr><tr><td>206</td><td>Partial  Content(部分内容)</td></tr><tr><td></td><td><strong>重定向</strong></td></tr><tr><td>300</td><td>Multiple  Choice(多种选择)</td></tr><tr><td>301</td><td>Moved  Permanently(永久移动)</td></tr><tr><td>302</td><td>Found(临时移动)</td></tr><tr><td>303</td><td>See  Other(查看其他位置)</td></tr><tr><td>304</td><td>Not  Modified(未修改)</td></tr><tr><td>305</td><td>Use  Proxy(使用代理)</td></tr><tr><td>306</td><td>unused(未使用)</td></tr><tr><td>307</td><td>Temporary  Redirect(临时重定向)</td></tr><tr><td>308</td><td>Permanent  Redirect(永久重定向)</td></tr><tr><td></td><td><strong>客户端错误</strong></td></tr><tr><td>400</td><td>Bad  Request(错误请求)</td></tr><tr><td>401</td><td>Unauthorized(未授权)</td></tr><tr><td>402</td><td>Payment  Required(需要付款)</td></tr><tr><td>403</td><td>Forbidden(禁止访问)</td></tr><tr><td>404</td><td>Not  Found(未找到)</td></tr><tr><td>405</td><td>Method  Not Allowed(不允许使用该方法)</td></tr><tr><td>406</td><td>Not  Acceptable(无法接受)</td></tr><tr><td>407</td><td>Proxy  Authentication Required(要求代理身份验证)</td></tr><tr><td>408</td><td>Request  Timeout(请求超时)</td></tr><tr><td>409</td><td>Conflict(冲突)</td></tr><tr><td>410</td><td>Gone(已失效)</td></tr><tr><td>411</td><td>Length  Required(需要内容长度头)</td></tr><tr><td>412</td><td>Precondition  Failed(预处理失败)</td></tr><tr><td>413</td><td>Request  Entity Too Large(请求实体过长)</td></tr><tr><td>414</td><td>Request-URI  Too Long(请求网址过长)</td></tr><tr><td>415</td><td>Unsupported  Media Type(媒体类型不支持)</td></tr><tr><td>416</td><td>Requested  Range Not Satisfiable(请求范围不合要求)</td></tr><tr><td>417</td><td>Expectation  Failed(预期结果失败)</td></tr><tr><td></td><td><strong>服务器端错误</strong></td></tr><tr><td>500</td><td>Internal  Server Error(内部服务器错误)</td></tr><tr><td>501</td><td>Implemented(未实现)</td></tr><tr><td>502</td><td>Bad  Gateway(网关错误)</td></tr><tr><td>503</td><td>Service  Unavailable(服务不可用)</td></tr><tr><td>504</td><td>Gateway  Timeout (网关超时)</td></tr><tr><td>505</td><td>HTTP  Version Not Supported(HTTP 版本不受支持)</td></tr></tbody></table><h3 id="4-3-HTTPS"><a href="#4-3-HTTPS" class="headerlink" title="4.3. HTTPS"></a>4.3. HTTPS</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用的端口号是 443。 过程大致如下： </p><p><strong>建立连接获取证书</strong> </p><ol><li>SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。         </li></ol><p><strong>证书验证</strong> </p><ol start="2"><li>Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</li></ol><p><strong>数据加密和传输</strong> </p><ol start="3"><li>如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</li></ol><p><img src="/images/Java_heart_network/clip_image012.gif" alt="img"> </p><h2 id="5-CDN-原理"><a href="#5-CDN-原理" class="headerlink" title="5. CDN 原理"></a>5. CDN 原理</h2><p>CND 一般包含分发服务系统、负载均衡系统和管理系统 </p><h3 id="5-1-分发服务系统"><a href="#5-1-分发服务系统" class="headerlink" title="5.1.分发服务系统"></a>5.1.分发服务系统</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：<strong>网页加速服务、流媒体加速服务、应用加速服务</strong>等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个 Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。</u> </p><h3 id="5-2-负载均衡系统"><a href="#5-2-负载均衡系统" class="headerlink" title="5.2.负载均衡系统"></a>5.2.负载均衡系统</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。 GSLB 根据用户地址和用户请求的内容，<u>主要根据就近性原则，确定向用户服务的节点。一般通过 DNS 解析或者应用层重定向（Http 3XX 重定向）的方式实现。</u> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个 Cache 设备的工作状况和内容分布情况等对用户请求重定向。<u>SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。</u> </p><h3 id="5-3-管理系统"><a href="#5-3-管理系统" class="headerlink" title="5.3.管理系统"></a>5.3.管理系统</h3><p>分为<strong>运营管理和网络管理子系统</strong>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。<u>包括用户管理、产品管理、计费管理、统计分析等。</u> </p><p><img src="/images/Java_heart_network/clip_image013.jpg" alt="img"> </p><h2 id="6-最后"><a href="#6-最后" class="headerlink" title="6.最后"></a>6.最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-网络7层架构&quot;&gt;&lt;a href=&quot;#1-网络7层架构&quot; class=&quot;headerlink&quot; title=&quot;1. 网络7层架构&quot;&gt;&lt;/a&gt;1. 网络7层架构&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;7 层模型主要包括：&lt;/strong&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为 1、0，也就是我们常说的&lt;strong&gt;模数转换与数模转换&lt;/strong&gt;）。这一层的数据叫做比特。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(七)之Netty与 RPC</title>
    <link href="https://quietair.gitee.io/Java_heart_NettyorRPC/"/>
    <id>https://quietair.gitee.io/Java_heart_NettyorRPC/</id>
    <published>2020-04-05T06:42:27.000Z</published>
    <updated>2020-05-04T07:04:49.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Netty-原理"><a href="#1-Netty-原理" class="headerlink" title="1. Netty 原理"></a>1. Netty 原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对 TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞的，<strong>通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。</strong>  </p><a id="more"></a><h2 id="2-Netty-高性能"><a href="#2-Netty-高性能" class="headerlink" title="2. Netty 高性能"></a>2. Netty 高性能</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在IO编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。IO多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;与Socket类和ServerSocket类相对应，NIO也提供了SocketChannel和ServerSocketChannel 两种不同的套接字通道实现。 </p><h3 id="2-1-多路复用通讯方式"><a href="#2-1-多路复用通讯方式" class="headerlink" title="2.1. 多路复用通讯方式"></a>2.1. 多路复用通讯方式</h3><p>Netty 架构按照 Reactor 模式设计和实现，它的服务端通信序列图如下： </p><p><img src="/images/Java_heart_NettyorRPC/clip_image003.gif" alt="img"> </p><p>客户端通信序列图如下：</p><p><img src="/images/Java_heart_NettyorRPC/clip_image005.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty 的 IO <strong>线程 NioEventLoop 由于聚合了多路复用器 Selector</strong>，可以同时并发处理成百上千个客户端 Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起。 </p><h3 id="2-2-异步通讯-NIO"><a href="#2-2-异步通讯-NIO" class="headerlink" title="2.2. 异步通讯 NIO"></a>2.2. 异步通讯 NIO</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>由于 Netty 采用了异步通信模式，一个 IO 线程可以并发处理 N 个客户端连接和读写操作</strong>，这从根本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。 </p><h3 id="2-3-零拷贝（DIRECT-BUFFERS-使用堆外直接内存）"><a href="#2-3-零拷贝（DIRECT-BUFFERS-使用堆外直接内存）" class="headerlink" title="2.3. 零拷贝（DIRECT BUFFERS 使用堆外直接内存）"></a>2.3. 零拷贝（DIRECT BUFFERS 使用堆外直接内存）</h3><ol><li><p><strong>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝</strong>。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写， JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 </p></li><li><p><u>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的Buffer。</u> </p></li><li><p>Netty的文件传输采用了<strong>transferTo方法</strong>，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环 write 方式导致的内存拷贝问题 。</p></li></ol><h3 id="2-4-内存池（基于内存池的缓冲区重用机制）"><a href="#2-4-内存池（基于内存池的缓冲区重用机制）" class="headerlink" title="2.4. 内存池（基于内存池的缓冲区重用机制）"></a>2.4. 内存池（基于内存池的缓冲区重用机制）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区 Buffer，情况却稍有不同，特别是对于<strong>堆外直接内存的分配和回收，是一件耗时的操作</strong>。为了尽量重用缓冲区，<strong>Netty 提供了基于内存池的缓冲区重用机制</strong>。 </p><h3 id="2-5-高效的-Reactor-线程模型"><a href="#2-5-高效的-Reactor-线程模型" class="headerlink" title="2.5. 高效的 Reactor 线程模型"></a>2.5. 高效的 Reactor 线程模型</h3><p>常用的 Reactor 线程模型有三种，Reactor 单线程模型, Reactor 多线程模型, 主从 Reactor 多线程模型。 </p><p><strong>Reactor单线程模型</strong> </p><p>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下： </p><p>1) 作为 NIO 服务端，接收客户端的 TCP 连接； </p><p>2) 作为 NIO 客户端，向服务端发起 TCP 连接； </p><p>3) 读取通信对端的请求或者应答消息；</p><p>4) 向通信对端发送消息请求或者应答消息。</p><p><img src="/images/Java_heart_NettyorRPC/clip_image007.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过Acceptor 接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer 派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。 </p><p><strong>Reactor多线程模型</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作。 有专门一个 <strong>NIO 线程-Acceptor 线程用于监听服务端</strong>，接收客户端的 TCP 连接请求； <strong>网络 IO 操作-读、写等由一个 NIO 线程池负责</strong>，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N 个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送；</p><p><img src="/images/Java_heart_NettyorRPC/clip_image009.gif" alt="img"> <strong>主从Reactor多线程模型</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。 Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责 SocketChannel 的读写和编解码工作。<u>Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。</u> </p><p><img src="/images/Java_heart_NettyorRPC/clip_image011.gif" alt="img"> </p><h3 id="2-6-无锁设计、线程绑定"><a href="#2-6-无锁设计、线程绑定" class="headerlink" title="2.6. 无锁设计、线程绑定"></a>2.6. 无锁设计、线程绑定</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列多个工作线程模型性能更优。</p><p><img src="/images/Java_heart_NettyorRPC/clip_image013.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的 fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。</p><h3 id="2-7-高性能的序列化框架"><a href="#2-7-高性能的序列化框架" class="headerlink" title="2.7. 高性能的序列化框架"></a>2.7. 高性能的序列化框架</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty 默认提供了对 Google Protobuf 的支持，通过扩展 Netty 的编解码接口，用户可以实现其它的高性能序列化框架，例如 Thrift 的压缩二进制编解码框架。 </p><ol><li>SO_RCVBUF 和 SO_SNDBUF：<strong>通常建议值为 128K 或者 256K</strong>。 </li></ol><p><strong>小包封大包，防止网络阻塞</strong> </p><ol start="2"><li>SO_TCPNODELAY：<strong>NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络</strong>，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法。 </li></ol><p><strong>软中断Hash值和CPU绑定</strong> </p><ol start="3"><li>软中断：开启 RPS 后可以实现软中断，提升网络吞吐量。<strong>RPS 根据数据包的源地址，目的地址以及目的和源端口，计算出一个 hash 值，然后根据这个 hash 值来选择软中断运行的 cpu</strong>，从上层来看，<strong>也就是说将每个连接和 cpu 绑定，并通过这个 hash 值，来均衡软中断在多个 cpu 上</strong>，提升网络并行处理性能。</li></ol><h2 id="3-Netty-RPC-实现"><a href="#3-Netty-RPC-实现" class="headerlink" title="3. Netty RPC 实现"></a>3. Netty RPC 实现</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1. 概念"></a>3.1. 概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC 可以很好的解耦系统，如 WebService 就是一种基于 Http 协议的 RPC。这个 RPC 整体框架如下： </p><p><img src="/images/Java_heart_NettyorRPC/clip_image015.gif" alt="img"> </p><h3 id="3-2-关键技术"><a href="#3-2-关键技术" class="headerlink" title="3.2. 关键技术"></a>3.2. 关键技术</h3><ol><li><p>服务发布与订阅：服务端使用 Zookeeper 注册服务地址，客户端从 Zookeeper 获取可用的服务地址。 </p></li><li><p>通信：使用 Netty 作为通信框架。</p></li><li><p>Spring：使用 Spring 配置服务，加载 Bean，扫描注解。 </p></li><li><p>动态代理：客户端使用代理模式透明化服务调用。 </p></li><li><p>消息编解码：使用 Protostuff 序列化和反序列化消息。 </p></li></ol><h3 id="3-3-核心流程"><a href="#3-3-核心流程" class="headerlink" title="3.3. 核心流程"></a>3.3. 核心流程</h3><ol><li><p>服务消费方（client）调用以本地调用方式调用服务；</p></li><li><p>client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </p></li><li><p>client stub 找到服务地址，并将消息发送到服务端； </p></li><li><p>server stub 收到消息后进行解码； </p></li><li><p>server stub 根据解码结果调用本地的服务； </p></li><li><p>本地服务执行并将结果返回给 server stub； </p></li><li><p>server stub 将返回结果打包成消息并发送至消费方； </p></li><li><p>client stub 接收到消息，并进行解码； </p></li><li><p>服务消费方得到最终结果。 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>RPC 的目标就是要 2~8 这些步骤都封装起来</strong>，让用户对这些细节透明。<strong>JAVA 一般使用动态代理方式实现远程调用</strong>。 </p><p><img src="/images/Java_heart_NettyorRPC/clip_image017.gif" alt="img"> </p><h3 id="3-4-消息编解码"><a href="#3-4-消息编解码" class="headerlink" title="3.4. 消息编解码"></a>3.4. 消息编解码</h3><p><strong>息数据结构（接口名称+方法名+参数类型和参数值+超时时间+ requestID）</strong>  </p><p>客户端的请求消息结构一般需要包括以下内容： </p><ol><li><p>接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪个接口了；</p></li><li><p>方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；</p></li><li><p>参数类型和参数值：参数类型有很多，比如有 bool、int、long、double、string、map、list，甚至如 struct（class）；以及相应的参数值；</p></li><li><p>超时时间： </p></li><li><p>requestID，标识唯一请求 id，在下面一节会详细描述 requestID 的用处。 </p></li><li><p>服务端返回的消息 ： 一般包括以下内容。返回值+状态 code+requestID </p></li></ol><p><strong>序列化</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;目前互联网公司广泛使用 Protobuf、Thrift、Avro 等成熟的序列化解决方案来搭建 RPC 框架，这些都是久经考验的解决方案。 </p><h3 id="3-5-通讯过程"><a href="#3-5-通讯过程" class="headerlink" title="3.5. 通讯过程"></a>3.5. 通讯过程</h3><p><strong>核心问题(线程暂停、消息乱序)</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果使用 netty 的话，<u>一般会用 channel.writeAndFlush()方法来发送消息二进制串，这个方法调用后对于整个远程调用(从发出请求到接收到结果)来说是一个异步的，即对于当前线程来说，将请求发送出来后，线程就可以往后执行了，至于服务端的结果，是服务端处理完成后，再以消息的形式发送给客户端的。</u>于是这里出现以下两个问题：</p><ol><li><p>怎么让当前线程“暂停”，等结果回来后，再向后执行？ </p></li><li><p>如果有多个线程同时进行远程方法调用，这时建立在 client server 之间的 socket 连接上会有很多双方发送的消息传递，前后顺序也可能是随机的，server 处理完结果后，将结果消息发送给 client，client 收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？如下图所示，线程 A 和线程 B 同时向 client socket 发送请求 requestA 和 requestB， socket 先后将 <u>requestB 和 requestA 发送至 server，而 server 可能将 responseB 先返回</u>，尽管 requestB 请求到达时间更晚。我们需要一种机制保证 responseA 丢给ThreadA，responseB 丢给 ThreadB。 </p></li></ol><p><img src="/images/Java_heart_NettyorRPC/clip_image019.gif" alt="img"> </p><p><strong>通讯流程</strong> </p><p><strong>requestID生成-AtomicLong</strong></p><ol><li>client 线程每次通过 socket 调用一次远程接口前，<u>生成一个唯一的 ID，即 requestID （requestID 必需保证在一个 Socket 连接里面是唯一的）</u>，一般常常使用 AtomicLong 从 0 开始累计数字生成唯一 ID； </li></ol><p><strong>存放回调对象callback到全局ConcurrentHashMap</strong></p><ol start="2"><li>将 处 理 结 果 的 回 调 对 象 callback ， 存 放 到 全 局 ConcurrentHashMap 里 面 put(requestID, callback)； </li></ol><p><strong>synchronized获取回调对象callback的锁并自旋wait</strong></p><ol start="3"><li>当线程调用 channel.writeAndFlush()发送消息后，紧接着执行 callback 的 get()方法试图获取远程返回的结果。在 get()内部，则使用 synchronized 获取回调对象 callback 的锁，再先检测是否已经获取到结果，如果没有，然后调用 callback 的 wait()方法，释放 callback 上的锁，让当前线程处于等待状态。 </li></ol><p><strong>监听消息的线程收到消息，找到callback上的锁并唤醒</strong> </p><ol start="4"><li><p>服务端接收到请求并处理后，将response结果（此结果中包含了前面的requestID）发送给客户端，<u>客户端 socket 连接上专门监听消息的线程收到消息，分析结果，取到 requestID，再从前面的 ConcurrentHashMap 里面 get(requestID)，从而找到 callback 对象，再用 synchronized 获取 callback 上的锁，将方法调用结果设置到 callback 对象里，再调用 callback.notifyAll()唤醒前面处于等待状态的线程。</u> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 旋锁       </span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 是否有结果了   </span></span><br><span class="line">            If （!isDone）&#123;                 </span><br><span class="line">                wait(); <span class="comment">//没结果释放锁，让当前线程处于等待状态   </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//获取数据并处理   </span></span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">setDone</span><span class="params">(Response res)</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">this</span>.res = res;     </span><br><span class="line">    isDone = <span class="keyword">true</span>;       </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">//获取锁，因为前面 wait()已经释放了 callback 的锁了       </span></span><br><span class="line">        notifyAll(); <span class="comment">//  唤醒处于等待的线程       </span></span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-RMI-实现方式"><a href="#4-RMI-实现方式" class="headerlink" title="4. RMI 实现方式"></a>4. RMI 实现方式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 Java 编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接口对象的使用。</p><h3 id="4-1-实现步骤"><a href="#4-1-实现步骤" class="headerlink" title="4.1. 实现步骤"></a>4.1. 实现步骤</h3><ol><li><p>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出 java.rmi.RemoteException 异常；</p></li><li><p>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类； </p></li><li><p>运行 RMI 编译器（rmic），创建客户端 stub 类和服务端 skeleton 类; </p></li><li><p>启动一个 RMI 注册表，以便驻留这些服务; </p></li><li><p>在 RMI 注册表中注册服务；</p></li><li><p>客户端查找远程对象，并调用远程方法； </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1：创建远程接口，继承 java.rmi.Remote 接口    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GreetService</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">Remote</span>  </span>&#123;   </span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span>  <span class="keyword">throws</span> RemoteException</span>;   </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">//2：实现远程接口，继承 java.rmi.server.UnicastRemoteObject 类   </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetServiceImpl</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">server</span>.<span class="title">UnicastRemoteObject</span>  <span class="keyword">implements</span> <span class="title">GreetService</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3434060152387200042L</span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreetServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span>  RemoteException </span>&#123;     </span><br><span class="line">        <span class="keyword">super</span>();       </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span>  <span class="keyword">throws</span> RemoteException </span>&#123;     </span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"Hello "</span> + name;       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//3：生成  Stub 和 Skeleton;    4：执行  rmiregistry 命令注册服务     5：启动服务    </span></span><br><span class="line">LocateRegistry.createRegistry(<span class="number">1098</span>);   </span><br><span class="line">Naming.bind(<span class="string">"rmi://10.108.1.138:1098/GreetService"</span>,  <span class="keyword">new</span> GreetServiceImpl());   </span><br><span class="line"><span class="comment">//6.客户端调用    </span></span><br><span class="line">GreetService   greetService    =   (GreetService)   Naming.lookup(<span class="string">"rmi://10.108.1.138:1098/GreetService"</span>);    </span><br><span class="line">System.out.println(greetService.sayHello(<span class="string">"Jobs"</span>));</span><br></pre></td></tr></table></figure><h2 id="5-Protoclol-Buffer"><a href="#5-Protoclol-Buffer" class="headerlink" title="5. Protoclol Buffer"></a>5. Protoclol Buffer</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;protocol buffer 是 google 的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法，例如 XML，不过它比 xml 更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。</p><h3 id="5-1-特点"><a href="#5-1-特点" class="headerlink" title="5.1. 特点"></a>5.1. 特点</h3><p><img src="/images/Java_heart_NettyorRPC/clip_image021.gif" alt="img"> </p><p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是： </p><ol><li><p>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等） </p></li><li><p>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成 </p></li></ol><p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是： </p><ol><li><p>a. 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等 </p></li><li><p>b. 采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑 </p></li></ol><h2 id="6-Thrift"><a href="#6-Thrift" class="headerlink" title="6. Thrift"></a>6. Thrift</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Apache Thrift 是 Facebook 实现的一种高效的、支持多种编程语言的远程服务调用的框架。本文将从 Java 开发人员角度详细介绍 Apache Thrift 的架构、开发和部署，并且针对不同的传输协议和服务类型给出相应的 Java 实例，同时详细介绍 Thrift 异步客户端的实现，最后提出使用 Thrift 需要注意的事项。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;目前流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;本文将介绍由 Facebook 开发的远程服务调用框架 Apache Thrift，<strong>它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中</strong>，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，<strong>相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;本文将详细介绍 Thrift 的使用，并且提供丰富的实例代码加以解释说明，帮助使用者快速构建服务。 </p><p>为什么要 Thrift：</p><p>1、多语言开发的需要 2、性能问题</p><p><img src="/images/Java_heart_NettyorRPC/clip_image023.gif" alt="img"> </p><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7.最后"></a>7.最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Netty-原理&quot;&gt;&lt;a href=&quot;#1-Netty-原理&quot; class=&quot;headerlink&quot; title=&quot;1. Netty 原理&quot;&gt;&lt;/a&gt;1. Netty 原理&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对 TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞的，&lt;strong&gt;通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。&lt;/strong&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(六)之微服务</title>
    <link href="https://quietair.gitee.io/Java_heart_microservice/"/>
    <id>https://quietair.gitee.io/Java_heart_microservice/</id>
    <published>2020-03-21T05:36:05.000Z</published>
    <updated>2020-05-04T07:04:49.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-服务注册发现"><a href="#1-服务注册发现" class="headerlink" title="1. 服务注册发现"></a>1. 服务注册发现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要Service Provider地址就行了。当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种形式：客户端注册和第三方注册。 </p><a id="more"></a><h3 id="1-1-客户端注册（zookeeper）"><a href="#1-1-客户端注册（zookeeper）" class="headerlink" title="1.1.客户端注册（zookeeper）"></a>1.1.客户端注册（zookeeper）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。</p><p><img src="/images/Java_heart_microservice/clip_image003.gif" alt="img"> </p><h3 id="1-2-第三方注册（独立的服务-Registrar）"><a href="#1-2-第三方注册（独立的服务-Registrar）" class="headerlink" title="1.2.第三方注册（独立的服务 Registrar）"></a>1.2.第三方注册（独立的服务 Registrar）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar，然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统，否则注册工作没法进展。 </p><p><img src="/images/Java_heart_microservice/clip_image005.gif" alt="img"> </p><h3 id="1-3-客户端发现"><a href="#1-3-客户端发现" class="headerlink" title="1.3.客户端发现"></a>1.3.客户端发现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。</p><p><img src="/images/Java_heart_microservice/clip_image007.gif" alt="img"> </p><h3 id="1-4-服务端发现"><a href="#1-4-服务端发现" class="headerlink" title="1.4.服务端发现"></a>1.4.服务端发现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。 </p><p><img src="/images/Java_heart_microservice/clip_image009.jpg" alt="img"> </p><ul><li>Consul</li><li>Eureka</li><li>SmartStack</li><li>Etcd</li></ul><h2 id="2-API-网关"><a href="#2-API-网关" class="headerlink" title="2. API 网关"></a>2. API 网关</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的 Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一个适应当前架构的 API Gateway。 </p><p><img src="/images/Java_heart_microservice/clip_image011.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>API Gateway 负责请求转发、合成和协议转换。</strong>所有来自客户端的请求都要先经过 API Gateway，然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换，如HTTP 协议、WebSocket 协议。</p><h3 id="2-1-请求转发"><a href="#2-1-请求转发" class="headerlink" title="2.1. 请求转发"></a>2.1. 请求转发</h3><p>服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上 </p><h3 id="2-2-响应合并"><a href="#2-2-响应合并" class="headerlink" title="2.2. 响应合并"></a>2.2. 响应合并</h3><p>把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。 </p><h3 id="2-3-协议转换"><a href="#2-3-协议转换" class="headerlink" title="2.3. 协议转换"></a>2.3. 协议转换</h3><p>重点是支持 SOAP，JMS，Rest 间的协议转换。 </p><h3 id="2-4-数据转换"><a href="#2-4-数据转换" class="headerlink" title="2.4. 数据转换"></a>2.4. 数据转换</h3><p>重点是支持 XML 和 Json 之间的报文格式转换能力（可选） </p><h3 id="2-5-安全认证"><a href="#2-5-安全认证" class="headerlink" title="2.5. 安全认证"></a>2.5. 安全认证</h3><ol><li><p>基于 Token 的客户端访问控制和安全策略</p></li><li><p>传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包 </p></li><li><p>基于 Https 的传输加密，客户端和服务端数字证书支持</p></li><li><p>基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等） </p></li></ol><h2 id="3-配置中心"><a href="#3-配置中心" class="headerlink" title="3. 配置中心"></a>3. 配置中心</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访</p><p>问。 </p><h3 id="3-1-zookeeper-配置中心"><a href="#3-1-zookeeper-配置中心" class="headerlink" title="3.1. zookeeper 配置中心"></a>3.1. zookeeper 配置中心</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;实现的架构图如下所示，采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点监听机制来实现实时感知。 </p><img src="/images/Java_heart_microservice/clip_image013.gif" alt="img"> <h3 id="3-2-配置中心数据分类"><a href="#3-2-配置中心数据分类" class="headerlink" title="3.2. 配置中心数据分类"></a>3.2. 配置中心数据分类</h3><p><img src="/images/Java_heart_microservice/clip_image015.gif" alt="img"> </p><h2 id="4-事件调度（kafka）"><a href="#4-事件调度（kafka）" class="headerlink" title="4. 事件调度（kafka）"></a>4. 事件调度（kafka）</h2><p>消息服务和事件的统一调度，常用用 kafka ，activemq 等。 </p><h2 id="5-服务跟踪（starter-sleuth）"><a href="#5-服务跟踪（starter-sleuth）" class="headerlink" title="5. 服务跟踪（starter-sleuth）"></a>5. 服务跟踪（starter-sleuth）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， <strong>Spring Cloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这样你就能跟踪某个请求是如何从一个微服务传递到下一个。</strong> </p><ol><li><p>为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，<strong>这个唯一标识就是前文中提到的 Trace ID</strong>。通过 Trace ID 的记录，我们就能将所有请求过程日志关联起来。 </p></li><li><p>为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的 Span ID，<strong>对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟</strong>，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。</p></li><li><p>在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloudstarter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloudstarter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：（1）、通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息中间件）传递的请求。（2）、通过 Zuul 代理传递的请求。 （3）、通过 RestTemplate 发起的请求。</p></li></ol><h2 id="6-服务熔断（Hystrix）"><a href="#6-服务熔断（Hystrix）" class="headerlink" title="6. 服务熔断（Hystrix）"></a>6. 服务熔断（Hystrix）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。 熔断器的原理很简单，如同电力过载保护器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p><p><img src="/images/Java_heart_microservice/clip_image017.jpg" alt="img"> </p><h3 id="6-1-Hystrix-断路器机制"><a href="#6-1-Hystrix-断路器机制" class="headerlink" title="6.1. Hystrix 断路器机制"></a>6.1. Hystrix 断路器机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。</p><h2 id="7-API-管理"><a href="#7-API-管理" class="headerlink" title="7. API 管理"></a>7. API 管理</h2><p>SwaggerAPI 管理工具。</p><h2 id="8-最后"><a href="#8-最后" class="headerlink" title="8. 最后"></a>8. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-服务注册发现&quot;&gt;&lt;a href=&quot;#1-服务注册发现&quot; class=&quot;headerlink&quot; title=&quot;1. 服务注册发现&quot;&gt;&lt;/a&gt;1. 服务注册发现&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要Service Provider地址就行了。当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种形式：客户端注册和第三方注册。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Zookeeper" scheme="https://quietair.gitee.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot与日志</title>
    <link href="https://quietair.gitee.io/spring-boot-logging/"/>
    <id>https://quietair.gitee.io/spring-boot-logging/</id>
    <published>2020-03-12T02:47:23.000Z</published>
    <updated>2020-05-04T07:04:50.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1.日志框架"></a>1.日志框架</h2><p>一个统一的接口层；日志门面（日志的一个抽象层）；</p><p>给项目中导入具体的日志实现就行了；之前的日志框架都是实现的抽象层；</p><p>市面上的日志框架:</p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j……</p><a id="more"></a><table><thead><tr><th>日志门面  （日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（Jakarta  Commons Logging）</del>    SLF4j（Simple  Logging Facade for Java）    <strong><del>jboss-logging</del></strong></td><td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td></tr></tbody></table><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面：  SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；</p><p>​    <strong>SpringBoot选用 SLF4j和logback；</strong></p><h2 id="2-SLF4j使用"><a href="#2-SLF4j使用" class="headerlink" title="2.SLF4j使用"></a>2.SLF4j使用</h2><h3 id="2-1-如何在系统中使用SLF4j"><a href="#2-1-如何在系统中使用SLF4j" class="headerlink" title="2.1.如何在系统中使用SLF4j"></a>2.1.如何在系统中使用SLF4j</h3><p><a href="http://www.slf4j.org/manual.html" target="_blank" rel="noopener">用户文档</a></p><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p><p>给系统里面导入slf4j的jar和  logback的实现jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示；</p><p><img src="/images/spring-boot-logging/concrete-bindings.png" alt="images/concrete-bindings.png"></p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；</strong></p><h3 id="2-2-遗留问题"><a href="#2-2-遗留问题" class="headerlink" title="2.2.遗留问题"></a>2.2.遗留问题</h3><p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p><p><img src="/images/spring-boot-logging/legacy.png" alt></p><p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p><p>1、将系统中其他日志框架先排除出去；</p><p>2、用中间包来替换原有的日志框架；</p><p>3、我们导入slf4j其他的实现;</p><h2 id="3-SpringBoot日志关系"><a href="#3-SpringBoot日志关系" class="headerlink" title="3.SpringBoot日志关系"></a>3.SpringBoot日志关系</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot使用它来做日志功能；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>底层依赖关系</p><p><img src="/images/spring-boot-logging/20200311190119.png" alt></p><p>总结：</p><p>​    1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p><p>​    2）、SpringBoot也把其他的日志都替换成了slf4j；</p><p>​    3）、中间替换包？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory();</span><br></pre></td></tr></table></figure><p><img src="/images/spring-boot-logging/20200311190307.png" alt></p><p>​    4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>​            Spring框架用的是commons-logging；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；</strong></p><h2 id="4-日志使用"><a href="#4-日志使用" class="headerlink" title="4.日志使用"></a>4.日志使用</h2><h3 id="4-1-默认配置"><a href="#4-1-默认配置" class="headerlink" title="4.1.默认配置"></a>4.1.默认配置</h3><p>SpringBoot默认帮我们配置好了日志；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//日志的级别；</span></span><br><span class="line"><span class="comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line"><span class="comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span></span><br><span class="line">logger.trace(<span class="string">"这是trace日志..."</span>);</span><br><span class="line">logger.debug(<span class="string">"这是debug日志..."</span>);</span><br><span class="line"><span class="comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span></span><br><span class="line">logger.info(<span class="string">"这是info日志..."</span>);</span><br><span class="line">logger.warn(<span class="string">"这是warn日志..."</span>);</span><br><span class="line">logger.error(<span class="string">"这是error日志..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">--</span> </span></span><br><span class="line"><span class="tag">  日志输出格式：</span></span><br><span class="line"><span class="tag">%<span class="attr">d</span>表示日期时间，</span></span><br><span class="line"><span class="tag">%<span class="attr">thread</span>表示线程名，</span></span><br><span class="line"><span class="tag">%<span class="attr">-5level</span>：级别从左显示<span class="attr">5</span>个字符宽度</span></span><br><span class="line"><span class="tag">%<span class="attr">logger</span>&#123;<span class="attr">50</span>&#125; 表示<span class="attr">logger</span>名字最长<span class="attr">50</span>个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="tag">%<span class="attr">msg</span>：日志消息，</span></span><br><span class="line"><span class="tag">%<span class="attr">n</span>是换行符</span></span><br><span class="line"><span class="tag">  <span class="attr">--</span>&gt;</span></span><br><span class="line">  %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br></pre></td></tr></table></figure><p>SpringBoot修改日志的默认配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.com.atguigu</span>=<span class="string">trace</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.path=(过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前项目下生成my.log日志</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">my.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.file=G:/springboot.log(过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.file.path= 文件名  直接在跟目录下创建该文件且自动 帮你创建好 spring.log 文件</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">/log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span></span><br><span class="line"><span class="meta">logging.path</span>=<span class="string">/spring/log(过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  在控制台输出的日志的格式</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>logging.file.name</th><th>logging.file.name</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>(none)</td><td>(none)</td><td></td><td>仅控制台记录。</td></tr><tr><td>指定文件名</td><td>(none)</td><td>my.log</td><td>写入指定的日志文件。名称可以是确切的位置，也可以相对于当前目录。</td></tr><tr><td>(none)</td><td>指定目录</td><td>/var/log</td><td>写入<code>spring.log</code>指定的目录。名称可以是确切的位置，也可以相对于当前目录。</td></tr></tbody></table><h3 id="4-2-指定配置"><a href="#4-2-指定配置" class="headerlink" title="4.2.指定配置"></a>4.2.指定配置</h3><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#boot-features-logging" target="_blank" rel="noopener">官方日志文档</a>；给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>官方建议将<code>-spring</code>变体用于日志记录配置（例如，<code>logback-spring.xml</code>而不是<code>logback.xml</code>）。如果使用标准配置位置，Spring将无法完全控制日志初始化。</p><p>如果用logback.xml：直接就被日志框架识别了；</p><p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">  可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">%d表示日期时间，</span></span><br><span class="line"><span class="comment">%thread表示线程名，</span></span><br><span class="line"><span class="comment">%-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">%msg：日志消息，</span></span><br><span class="line"><span class="comment">%n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no applicable action for [springProfile]</span><br></pre></td></tr></table></figure><h2 id="5-切换日志框架"><a href="#5-切换日志框架" class="headerlink" title="5.切换日志框架"></a>5.切换日志框架</h2><p>可以按照slf4j的日志适配图，进行相关的切换；</p><p>slf4j+log4j的方式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>切换为log4j2:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-最后"><a href="#6-最后" class="headerlink" title="6.最后"></a>6.最后</h2><p>​    此spring boot部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-日志框架&quot;&gt;&lt;a href=&quot;#1-日志框架&quot; class=&quot;headerlink&quot; title=&quot;1.日志框架&quot;&gt;&lt;/a&gt;1.日志框架&lt;/h2&gt;&lt;p&gt;一个统一的接口层；日志门面（日志的一个抽象层）；&lt;/p&gt;
&lt;p&gt;给项目中导入具体的日志实现就行了；之前的日志框架都是实现的抽象层；&lt;/p&gt;
&lt;p&gt;市面上的日志框架:&lt;/p&gt;
&lt;p&gt;JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j……&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot配置文件解析</title>
    <link href="https://quietair.gitee.io/spring-boot-configuration/"/>
    <id>https://quietair.gitee.io/spring-boot-configuration/</id>
    <published>2020-03-05T07:46:27.000Z</published>
    <updated>2020-05-04T07:04:50.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h2><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p><p>•application.properties</p><p>•application.yml</p><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><a id="more"></a><p>YAML（YAML Ain’t Markup Language）</p><p>​    YAML  A Markup Language：是一个标记语言</p><p>​    YAML   isn’t Markup Language：不是一个标记语言；</p><p>标记语言：</p><p>​    以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</p><p>​    YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p><p>​    YAML：配置例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>​    XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-YAML语法："><a href="#2-YAML语法：" class="headerlink" title="2.YAML语法："></a>2.YAML语法：</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1.基本语法"></a>2.1.基本语法</h3><p>k:(空格)v：表示一对键值对（空格必须有）；</p><p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p>属性和值也是大小写敏感；</p><h3 id="2-2-值的写法"><a href="#2-2-值的写法" class="headerlink" title="2.2.值的写法"></a>2.2.值的写法</h3><p><strong>字面量：普通的值（数字，字符串，布尔）</strong></p><p>​    k: v：字面直接来写；</p><p>​        字符串默认不用加上单引号或者双引号；</p><p>​        “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><p>​                name:   “zhangsan \n lisi”：输出；zhangsan 换行  lisi</p><p>​        ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>​                name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</p><h3 id="2-3-对象、Map（属性和值）（键值对）："><a href="#2-3-对象、Map（属性和值）（键值对）：" class="headerlink" title="2.3.对象、Map（属性和值）（键值对）："></a>2.3.对象、Map（属性和值）（键值对）：</h3><p>​    k: v：在下一行来写对象的属性和值的关系；注意缩进</p><p>​        对象还是k: v的方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-数组（List、Set）："><a href="#2-4-数组（List、Set）：" class="headerlink" title="2.4.数组（List、Set）："></a>2.4.数组（List、Set）：</h3><p>用- 值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure><h2 id="3-配置文件值注入"><a href="#3-配置文件值注入" class="headerlink" title="3.配置文件值注入"></a>3.配置文件值注入</h2><p>配置文件:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">    <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line">    <span class="attr">maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line">    <span class="attr">lists:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zhaoliu</span></span><br><span class="line">    <span class="attr">dog:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">小狗</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>javaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>我们可以导入配置文件处理器，以后编写配置就有提示了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-properties配置文件在idea中默认utf-8可能会乱码"><a href="#3-1-properties配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="3.1.properties配置文件在idea中默认utf-8可能会乱码"></a>3.1.properties配置文件在idea中默认utf-8可能会乱码</h3><p>调整:</p><p><img src="/images/spring-boot-configuration/20200302190132.png" alt="idea配置乱码"></p><h3 id="3-2-Value获取值和-ConfigurationProperties获取值比较"><a href="#3-2-Value获取值和-ConfigurationProperties获取值比较" class="headerlink" title="3.2.@Value获取值和@ConfigurationProperties获取值比较"></a>3.2.@Value获取值和@ConfigurationProperties获取值比较</h3><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL(Spring表达式)</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>配置文件yml还是properties他们都能获取到值；</p><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p><p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h3 id="3-3-配置文件注入值数据校验"><a href="#3-3-配置文件注入值数据校验" class="headerlink" title="3.3.配置文件注入值数据校验"></a>3.3.配置文件注入值数据校验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><h3 id="3-4-PropertySource-amp-ImportResource-amp-Bean"><a href="#3-4-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="3.4.@PropertySource&amp;@ImportResource&amp;@Bean"></a>3.4.@PropertySource&amp;@ImportResource&amp;@Bean</h3><p>@<strong>PropertySource</strong>：加载指定的配置文件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@ConfigurationProperties</span>(prefix = "person")默认从全局配置文件中获取值；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">   <span class="comment">// @Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure><p>@<strong>ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p><p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p><p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件让其生效</span><br></pre></td></tr></table></figure><p>不来编写Spring的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p><p>1、配置类<strong>@Configuration</strong>——&gt;Spring配置文件</p><p>2、使用<strong>@Bean</strong>给容器中添加组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##4、配置文件占位符</p><p><strong>1.随机数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="keyword">int</span>&#125;、$&#123;random.<span class="keyword">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="keyword">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure><p><strong>2.占位符获取之前配置的值，如果没有可以是用:指定默认值</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2017/12/15</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">14</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">$&#123;person.hello:hello&#125;_dog</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure><h2 id="4-Profile"><a href="#4-Profile" class="headerlink" title="4.Profile"></a>4.Profile</h2><p>Profile是spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境。</p><h3 id="4-1-多Profile文件"><a href="#4-1-多Profile文件" class="headerlink" title="4.1.多Profile文件"></a>4.1.多Profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</p><p>默认使用application.properties的配置；</p><h3 id="4-2-yml支持多文档块方式"><a href="#4-2-yml支持多文档块方式" class="headerlink" title="4.2.yml支持多文档块方式"></a>4.2.yml支持多文档块方式</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span> <span class="comment">#指定激活哪个环境</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br></pre></td></tr></table></figure><h3 id="4-3-激活指定profile"><a href="#4-3-激活指定profile" class="headerlink" title="4.3.激活指定profile"></a>4.3.激活指定profile</h3><p>​    1、在配置文件中指定  spring.profiles.active=dev</p><p>​    2、命令行：</p><p>​        java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev；</p><p>​        可以直接在测试的时候，配置传入命令行参数</p><p>​    3、虚拟机参数；</p><p>​        -Dspring.profiles.active=dev</p><h2 id="5-配置文件加载位置"><a href="#5-配置文件加载位置" class="headerlink" title="5.配置文件加载位置"></a>5.配置文件加载位置</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><p><img src="/images/spring-boot-configuration/20200304195848.png" alt></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application.properties文件内容</span></span><br><span class="line"><span class="meta">server.post</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment">#server.servlet.context-path=/boot #配置项目得访问路径</span></span><br></pre></td></tr></table></figure><p>–file:./config/</p><p>–file:./</p><p>–classpath:/config/</p><p>–classpath:/</p><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p><p>==我们还可以通过spring.config.location来改变默认的配置文件位置==</p><p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar  G:/application.properties</p><h2 id="6-外部配置加载顺序"><a href="#6-外部配置加载顺序" class="headerlink" title="6.外部配置加载顺序"></a>6.外部配置加载顺序</h2><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p><p><strong>1.命令行参数</strong></p><p>所有的配置都可以在命令行上进行指定</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p><p>多个配置用空格分开； –配置项=值</p><p>2.来自java:comp/env的JNDI属性</p><p>3.Java系统属性（System.getProperties()）</p><p>4.操作系统环境变量</p><p>5.RandomValuePropertySource配置的random.*属性值</p><p><strong>由jar包外向jar包内进行寻找；</strong></p><p><strong>优先加载带profile</strong></p><p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>再来加载不带profile</strong></p><p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource</p><p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><p><img src="/images/spring-boot-configuration/20200305123720.png" alt="支持的配置"></p><h2 id="7-自动配置原理"><a href="#7-自动配置原理" class="headerlink" title="7.自动配置原理"></a>7.自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h3 id="7-1-自动配置原理："><a href="#7-1-自动配置原理：" class="headerlink" title="7.1.自动配置原理："></a>7.1.<strong>自动配置原理：</strong></h3><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 <strong>@EnableAutoConfiguration</strong></p><p>2）、<strong>@EnableAutoConfiguration 作用：</strong></p><ul><li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件;<ul><li>可以查看selectImports()方法的内容；</li><li>List<string> configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</string></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames()</span><br><span class="line"><span class="comment">//扫描所有jar包类路径下  META-INF/spring.factories</span></span><br><span class="line"><span class="comment">//把扫描到的这些文件的内容包装成properties对象</span></span><br><span class="line"><span class="comment">//从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</span></span><br></pre></td></tr></table></figure><p>将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p>3）、每一个自动配置类进行自动配置功能；</p><p>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="class">.<span class="keyword">class</span>)  //启动指定类的<span class="title">ConfigurationProperties</span>功能；将配置文件中对应的值和<span class="title">HttpEncodingProperties</span>绑定起来；并把<span class="title">HttpEncodingProperties</span>加入到<span class="title">ioc</span>容器中</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span> //<span class="title">Spring</span>底层@<span class="title">Conditional</span>注解（<span class="title">Spring</span>注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是<span class="title">web</span>应用，如果是，当前配置类生效</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(<span class="title">CharacterEncodingFilter</span>.<span class="title">class</span>)  //判断当前项目有没有这个类<span class="title">CharacterEncodingFilter</span>；<span class="title">SpringMVC</span>中进行乱码解决的过滤器；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.properties = properties;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>) //判断容器没有这个组件？</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">CharacterEncodingFilter</span> <span class="title">characterEncodingFilter</span>() </span>&#123;</span><br><span class="line">CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line"><span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>)  <span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p><strong>精髓：</strong></p><p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p><p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p><p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p><p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p><p>xxxxAutoConfigurartion：自动配置类；</p><p>给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h3 id="7-2-细节"><a href="#7-2-细节" class="headerlink" title="7.2.细节"></a>7.2.细节</h3><p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><p><strong>我们可以通过启用  debug=true属性；来让控制台打印自动配置报告</strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-CONFIGURATION REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">      - @<span class="title">ConditionalOnWebApplication</span> <span class="params">(required)</span> found <span class="title">StandardServletEnvironment</span> <span class="params">(OnWebApplicationCondition)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   AopAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="params">(OnClassCondition)</span></span></span><br></pre></td></tr></table></figure><h2 id="8-最后"><a href="#8-最后" class="headerlink" title="8.最后"></a>8.最后</h2><p>​    此spring boot部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-配置文件&quot;&gt;&lt;a href=&quot;#1-配置文件&quot; class=&quot;headerlink&quot; title=&quot;1.配置文件&quot;&gt;&lt;/a&gt;1.配置文件&lt;/h2&gt;&lt;p&gt;SpringBoot使用一个全局的配置文件，配置文件名是固定的；&lt;/p&gt;
&lt;p&gt;•application.properties&lt;/p&gt;
&lt;p&gt;•application.yml&lt;/p&gt;
&lt;p&gt;配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot入门</title>
    <link href="https://quietair.gitee.io/spring-boot-01/"/>
    <id>https://quietair.gitee.io/spring-boot-01/</id>
    <published>2020-02-29T12:24:00.000Z</published>
    <updated>2020-05-04T07:04:50.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring-Boot-简介"><a href="#1-Spring-Boot-简介" class="headerlink" title="1.Spring Boot 简介"></a>1.Spring Boot 简介</h2><p>-简化Spring应用开发的一个框架；</p><p>-整个Spring技术栈的一个大整合；</p><p>-J2EE开发的一站式解决方案；</p><a id="more"></a><h2 id="2-微服务"><a href="#2-微服务" class="headerlink" title="2.微服务"></a>2.微服务</h2><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p><p>单体应用：ALL IN ONE</p><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="noopener">详细参照微服务文档</a></p><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3.环境准备"></a>3.环境准备</h2><p>环境约束:</p><p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；</p><p>–maven3.x：maven 3.3以上版本；</p><p>–IntelliJIDEA：IntelliJ IDEA </p><p>–SpringBoot 1.5.9.RELEASE：1.5.9；</p><h3 id="3-1-MAVEN设置"><a href="#3-1-MAVEN设置" class="headerlink" title="3.1.MAVEN设置"></a>3.1.MAVEN设置</h3><p>给maven 的settings.xml配置文件的profiles标签添加(可以添加，也可以不用)；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-IDEA设置"><a href="#3-2-IDEA设置" class="headerlink" title="3.2.IDEA设置"></a>3.2.IDEA设置</h3><p>首先对maven进行整合；</p><p><img src="/images/spring-boot-01/20200229191224.png" alt="idea设置"></p><p><img src="/images/spring-boot-01/20200229191357.png" alt="images/"></p><h2 id="4-Spring-Boot-HelloWorld"><a href="#4-Spring-Boot-HelloWorld" class="headerlink" title="4.Spring Boot HelloWorld"></a>4.Spring Boot HelloWorld</h2><p>实现一个简单的功能：</p><p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p><h3 id="4-1-创建一个maven工程（jar）"><a href="#4-1-创建一个maven工程（jar）" class="headerlink" title="4.1.创建一个maven工程（jar）"></a>4.1.创建一个maven工程（jar）</h3><h3 id="4-2-导入spring-boot相关的依赖"><a href="#4-2-导入spring-boot相关的依赖" class="headerlink" title="4.2.导入spring boot相关的依赖"></a>4.2.导入spring boot相关的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-编写一个主程序；启动Spring-Boot应用"><a href="#4-3-编写一个主程序；启动Spring-Boot应用" class="headerlink" title="4.3.编写一个主程序；启动Spring Boot应用"></a>4.3.编写一个主程序；启动Spring Boot应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-编写相关的Controller、Service"><a href="#4-4-编写相关的Controller、Service" class="headerlink" title="4.4.编写相关的Controller、Service"></a>4.4.编写相关的Controller、Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运行主程序测试"><a href="#4-5-运行主程序测试" class="headerlink" title="4.5.运行主程序测试"></a>4.5.运行主程序测试</h3><h3 id="4-6-简化部署"><a href="#4-6-简化部署" class="headerlink" title="4.6.简化部署"></a>4.6.简化部署</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将这个应用打成jar包，再window下或者Linux下直接使用java -jar的命令进行执行；</p><h2 id="5-Hello-World探究"><a href="#5-Hello-World探究" class="headerlink" title="5.Hello World探究"></a>5.Hello World探究</h2><h3 id="5-1-POM文件"><a href="#5-1-POM文件" class="headerlink" title="5.1.POM文件"></a>5.1.POM文件</h3><h4 id="5-1-1父项目"><a href="#5-1-1父项目" class="headerlink" title="5.1.1父项目"></a>5.1.1父项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">上面的父项目是</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">它来真正管理Spring Boot应用里面的所有依赖版本；</span><br></pre></td></tr></table></figure><p>Spring Boot的版本仲裁中心；</p><p>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p><h4 id="5-1-2启动器"><a href="#5-1-2启动器" class="headerlink" title="5.1.2启动器"></a>5.1.2启动器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-boot-starter-<strong>web</strong>：</p><p>​    spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p><p>总结：Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p><h3 id="5-2-主程序类，主入口类"><a href="#5-2-主程序类，主入口类" class="headerlink" title="5.2.主程序类，主入口类"></a>5.2.主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">      @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p><p>​        标注在某个类上，表示这是一个Spring Boot的配置类；</p><p>​        @<strong>Configuration</strong>:配置类上来标注这个注解；</p><p>​            配置类 —–  配置文件；配置类也是容器中的一个组件；<strong>@Component</strong></p><p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p><p>​        以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>​    @<strong>AutoConfigurationPackage</strong>：自动配置包</p><p>​        @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p><p>​        Spring的底层注解<strong>@Import</strong>，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</p><p>将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</p><p>​    @<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p><p>​        给容器中导入组件？</p><p>​        <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p><p>​        将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p>​        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；        <img src="/images/spring-boot-01/20200229203810.png" alt="自动配置类"></p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p><p>​        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p><p>总结：Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；</p><p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p><h2 id="6-IDEA：使用-Spring-Initializer快速创建spring-boot项目"><a href="#6-IDEA：使用-Spring-Initializer快速创建spring-boot项目" class="headerlink" title="6.IDEA：使用 Spring Initializer快速创建spring boot项目"></a>6.IDEA：使用 Spring Initializer快速创建spring boot项目</h2><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p><p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p><p>默认生成的Spring Boot项目；</p><ul><li>主程序已经生成好了，我们只需要我们自己的逻辑</li><li>resources文件夹中目录结构<ul><li>static：保存所有的静态资源； js css  images；</li><li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li></ul></li></ul><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7.最后"></a>7.最后</h2><p>​    此spring boot部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Spring-Boot-简介&quot;&gt;&lt;a href=&quot;#1-Spring-Boot-简介&quot; class=&quot;headerlink&quot; title=&quot;1.Spring Boot 简介&quot;&gt;&lt;/a&gt;1.Spring Boot 简介&lt;/h2&gt;&lt;p&gt;-简化Spring应用开发的一个框架；&lt;/p&gt;
&lt;p&gt;-整个Spring技术栈的一个大整合；&lt;/p&gt;
&lt;p&gt;-J2EE开发的一站式解决方案；&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
</feed>
