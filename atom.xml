<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QuietAir</title>
  
  <subtitle>沉静的空气，环绕身边，让时间失衡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://quietair.gitee.io/"/>
  <updated>2020-04-04T12:45:52.858Z</updated>
  <id>https://quietair.gitee.io/</id>
  
  <author>
    <name>QuietAir</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot与日志</title>
    <link href="https://quietair.gitee.io/spring-boot-logging/"/>
    <id>https://quietair.gitee.io/spring-boot-logging/</id>
    <published>2020-03-12T02:47:23.000Z</published>
    <updated>2020-04-04T12:45:52.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1.日志框架"></a>1.日志框架</h2><p>一个统一的接口层；日志门面（日志的一个抽象层）；</p><p>给项目中导入具体的日志实现就行了；之前的日志框架都是实现的抽象层；</p><p>市面上的日志框架:</p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j……</p><a id="more"></a><table><thead><tr><th>日志门面  （日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（Jakarta  Commons Logging）</del>    SLF4j（Simple  Logging Facade for Java）    <strong><del>jboss-logging</del></strong></td><td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td></tr></tbody></table><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面：  SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；</p><p>​    <strong>SpringBoot选用 SLF4j和logback；</strong></p><h2 id="2-SLF4j使用"><a href="#2-SLF4j使用" class="headerlink" title="2.SLF4j使用"></a>2.SLF4j使用</h2><h3 id="2-1-如何在系统中使用SLF4j"><a href="#2-1-如何在系统中使用SLF4j" class="headerlink" title="2.1.如何在系统中使用SLF4j"></a>2.1.如何在系统中使用SLF4j</h3><p><a href="http://www.slf4j.org/manual.html" target="_blank" rel="noopener">用户文档</a></p><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p><p>给系统里面导入slf4j的jar和  logback的实现jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示；</p><p><img src="/images/spring-boot-logging/concrete-bindings.png" alt="images/concrete-bindings.png"></p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；</strong></p><h3 id="2-2-遗留问题"><a href="#2-2-遗留问题" class="headerlink" title="2.2.遗留问题"></a>2.2.遗留问题</h3><p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p><p><img src="/images/spring-boot-logging/legacy.png" alt></p><p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p><p>1、将系统中其他日志框架先排除出去；</p><p>2、用中间包来替换原有的日志框架；</p><p>3、我们导入slf4j其他的实现;</p><h2 id="3-SpringBoot日志关系"><a href="#3-SpringBoot日志关系" class="headerlink" title="3.SpringBoot日志关系"></a>3.SpringBoot日志关系</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot使用它来做日志功能；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>底层依赖关系</p><p><img src="/images/spring-boot-logging/20200311190119.png" alt></p><p>总结：</p><p>​    1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p><p>​    2）、SpringBoot也把其他的日志都替换成了slf4j；</p><p>​    3）、中间替换包？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory();</span><br></pre></td></tr></table></figure><p><img src="/images/spring-boot-logging/20200311190307.png" alt></p><p>​    4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>​            Spring框架用的是commons-logging；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；</strong></p><h2 id="4-日志使用"><a href="#4-日志使用" class="headerlink" title="4.日志使用"></a>4.日志使用</h2><h3 id="4-1-默认配置"><a href="#4-1-默认配置" class="headerlink" title="4.1.默认配置"></a>4.1.默认配置</h3><p>SpringBoot默认帮我们配置好了日志；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//日志的级别；</span></span><br><span class="line"><span class="comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line"><span class="comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span></span><br><span class="line">logger.trace(<span class="string">"这是trace日志..."</span>);</span><br><span class="line">logger.debug(<span class="string">"这是debug日志..."</span>);</span><br><span class="line"><span class="comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span></span><br><span class="line">logger.info(<span class="string">"这是info日志..."</span>);</span><br><span class="line">logger.warn(<span class="string">"这是warn日志..."</span>);</span><br><span class="line">logger.error(<span class="string">"这是error日志..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">--</span> </span></span><br><span class="line"><span class="tag">  日志输出格式：</span></span><br><span class="line"><span class="tag">%<span class="attr">d</span>表示日期时间，</span></span><br><span class="line"><span class="tag">%<span class="attr">thread</span>表示线程名，</span></span><br><span class="line"><span class="tag">%<span class="attr">-5level</span>：级别从左显示<span class="attr">5</span>个字符宽度</span></span><br><span class="line"><span class="tag">%<span class="attr">logger</span>&#123;<span class="attr">50</span>&#125; 表示<span class="attr">logger</span>名字最长<span class="attr">50</span>个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="tag">%<span class="attr">msg</span>：日志消息，</span></span><br><span class="line"><span class="tag">%<span class="attr">n</span>是换行符</span></span><br><span class="line"><span class="tag">  <span class="attr">--</span>&gt;</span></span><br><span class="line">  %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br></pre></td></tr></table></figure><p>SpringBoot修改日志的默认配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.com.atguigu</span>=<span class="string">trace</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.path=(过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前项目下生成my.log日志</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">my.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.file=G:/springboot.log(过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.file.path= 文件名  直接在跟目录下创建该文件且自动 帮你创建好 spring.log 文件</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">/log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span></span><br><span class="line"><span class="meta">logging.path</span>=<span class="string">/spring/log(过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  在控制台输出的日志的格式</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>logging.file.name</th><th>logging.file.name</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>(none)</td><td>(none)</td><td></td><td>仅控制台记录。</td></tr><tr><td>指定文件名</td><td>(none)</td><td>my.log</td><td>写入指定的日志文件。名称可以是确切的位置，也可以相对于当前目录。</td></tr><tr><td>(none)</td><td>指定目录</td><td>/var/log</td><td>写入<code>spring.log</code>指定的目录。名称可以是确切的位置，也可以相对于当前目录。</td></tr></tbody></table><h3 id="4-2-指定配置"><a href="#4-2-指定配置" class="headerlink" title="4.2.指定配置"></a>4.2.指定配置</h3><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#boot-features-logging" target="_blank" rel="noopener">官方日志文档</a>；给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>官方建议将<code>-spring</code>变体用于日志记录配置（例如，<code>logback-spring.xml</code>而不是<code>logback.xml</code>）。如果使用标准配置位置，Spring将无法完全控制日志初始化。</p><p>如果用logback.xml：直接就被日志框架识别了；</p><p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">  可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">%d表示日期时间，</span></span><br><span class="line"><span class="comment">%thread表示线程名，</span></span><br><span class="line"><span class="comment">%-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">%msg：日志消息，</span></span><br><span class="line"><span class="comment">%n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no applicable action for [springProfile]</span><br></pre></td></tr></table></figure><h2 id="5-切换日志框架"><a href="#5-切换日志框架" class="headerlink" title="5.切换日志框架"></a>5.切换日志框架</h2><p>可以按照slf4j的日志适配图，进行相关的切换；</p><p>slf4j+log4j的方式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>切换为log4j2:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-最后"><a href="#6-最后" class="headerlink" title="6.最后"></a>6.最后</h2><p>​    此spring boot部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-日志框架&quot;&gt;&lt;a href=&quot;#1-日志框架&quot; class=&quot;headerlink&quot; title=&quot;1.日志框架&quot;&gt;&lt;/a&gt;1.日志框架&lt;/h2&gt;&lt;p&gt;一个统一的接口层；日志门面（日志的一个抽象层）；&lt;/p&gt;
&lt;p&gt;给项目中导入具体的日志实现就行了；之前的日志框架都是实现的抽象层；&lt;/p&gt;
&lt;p&gt;市面上的日志框架:&lt;/p&gt;
&lt;p&gt;JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j……&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot配置文件解析</title>
    <link href="https://quietair.gitee.io/spring-boot-configuration/"/>
    <id>https://quietair.gitee.io/spring-boot-configuration/</id>
    <published>2020-03-05T07:46:27.000Z</published>
    <updated>2020-04-04T12:45:52.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h2><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p><p>•application.properties</p><p>•application.yml</p><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><a id="more"></a><p>YAML（YAML Ain’t Markup Language）</p><p>​    YAML  A Markup Language：是一个标记语言</p><p>​    YAML   isn’t Markup Language：不是一个标记语言；</p><p>标记语言：</p><p>​    以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</p><p>​    YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p><p>​    YAML：配置例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>​    XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-YAML语法："><a href="#2-YAML语法：" class="headerlink" title="2.YAML语法："></a>2.YAML语法：</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1.基本语法"></a>2.1.基本语法</h3><p>k:(空格)v：表示一对键值对（空格必须有）；</p><p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p>属性和值也是大小写敏感；</p><h3 id="2-2-值的写法"><a href="#2-2-值的写法" class="headerlink" title="2.2.值的写法"></a>2.2.值的写法</h3><p><strong>字面量：普通的值（数字，字符串，布尔）</strong></p><p>​    k: v：字面直接来写；</p><p>​        字符串默认不用加上单引号或者双引号；</p><p>​        “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><p>​                name:   “zhangsan \n lisi”：输出；zhangsan 换行  lisi</p><p>​        ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>​                name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</p><h3 id="2-3-对象、Map（属性和值）（键值对）："><a href="#2-3-对象、Map（属性和值）（键值对）：" class="headerlink" title="2.3.对象、Map（属性和值）（键值对）："></a>2.3.对象、Map（属性和值）（键值对）：</h3><p>​    k: v：在下一行来写对象的属性和值的关系；注意缩进</p><p>​        对象还是k: v的方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-数组（List、Set）："><a href="#2-4-数组（List、Set）：" class="headerlink" title="2.4.数组（List、Set）："></a>2.4.数组（List、Set）：</h3><p>用- 值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure><h2 id="3-配置文件值注入"><a href="#3-配置文件值注入" class="headerlink" title="3.配置文件值注入"></a>3.配置文件值注入</h2><p>配置文件:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">    <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line">    <span class="attr">maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line">    <span class="attr">lists:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zhaoliu</span></span><br><span class="line">    <span class="attr">dog:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">小狗</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>javaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>我们可以导入配置文件处理器，以后编写配置就有提示了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-properties配置文件在idea中默认utf-8可能会乱码"><a href="#3-1-properties配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="3.1.properties配置文件在idea中默认utf-8可能会乱码"></a>3.1.properties配置文件在idea中默认utf-8可能会乱码</h3><p>调整:</p><p><img src="/images/spring-boot-configuration/20200302190132.png" alt="idea配置乱码"></p><h3 id="3-2-Value获取值和-ConfigurationProperties获取值比较"><a href="#3-2-Value获取值和-ConfigurationProperties获取值比较" class="headerlink" title="3.2.@Value获取值和@ConfigurationProperties获取值比较"></a>3.2.@Value获取值和@ConfigurationProperties获取值比较</h3><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL(Spring表达式)</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>配置文件yml还是properties他们都能获取到值；</p><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p><p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h3 id="3-3-配置文件注入值数据校验"><a href="#3-3-配置文件注入值数据校验" class="headerlink" title="3.3.配置文件注入值数据校验"></a>3.3.配置文件注入值数据校验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><h3 id="3-4-PropertySource-amp-ImportResource-amp-Bean"><a href="#3-4-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="3.4.@PropertySource&amp;@ImportResource&amp;@Bean"></a>3.4.@PropertySource&amp;@ImportResource&amp;@Bean</h3><p>@<strong>PropertySource</strong>：加载指定的配置文件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@ConfigurationProperties</span>(prefix = "person")默认从全局配置文件中获取值；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">   <span class="comment">// @Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure><p>@<strong>ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p><p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p><p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件让其生效</span><br></pre></td></tr></table></figure><p>不来编写Spring的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p><p>1、配置类<strong>@Configuration</strong>——&gt;Spring配置文件</p><p>2、使用<strong>@Bean</strong>给容器中添加组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##4、配置文件占位符</p><p><strong>1.随机数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="keyword">int</span>&#125;、$&#123;random.<span class="keyword">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="keyword">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure><p><strong>2.占位符获取之前配置的值，如果没有可以是用:指定默认值</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2017/12/15</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">14</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">$&#123;person.hello:hello&#125;_dog</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure><h2 id="4-Profile"><a href="#4-Profile" class="headerlink" title="4.Profile"></a>4.Profile</h2><p>Profile是spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境。</p><h3 id="4-1-多Profile文件"><a href="#4-1-多Profile文件" class="headerlink" title="4.1.多Profile文件"></a>4.1.多Profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</p><p>默认使用application.properties的配置；</p><h3 id="4-2-yml支持多文档块方式"><a href="#4-2-yml支持多文档块方式" class="headerlink" title="4.2.yml支持多文档块方式"></a>4.2.yml支持多文档块方式</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span> <span class="comment">#指定激活哪个环境</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br></pre></td></tr></table></figure><h3 id="4-3-激活指定profile"><a href="#4-3-激活指定profile" class="headerlink" title="4.3.激活指定profile"></a>4.3.激活指定profile</h3><p>​    1、在配置文件中指定  spring.profiles.active=dev</p><p>​    2、命令行：</p><p>​        java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev；</p><p>​        可以直接在测试的时候，配置传入命令行参数</p><p>​    3、虚拟机参数；</p><p>​        -Dspring.profiles.active=dev</p><h2 id="5-配置文件加载位置"><a href="#5-配置文件加载位置" class="headerlink" title="5.配置文件加载位置"></a>5.配置文件加载位置</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><p><img src="/images/spring-boot-configuration/20200304195848.png" alt></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application.properties文件内容</span></span><br><span class="line"><span class="meta">server.post</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment">#server.servlet.context-path=/boot #配置项目得访问路径</span></span><br></pre></td></tr></table></figure><p>–file:./config/</p><p>–file:./</p><p>–classpath:/config/</p><p>–classpath:/</p><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p><p>==我们还可以通过spring.config.location来改变默认的配置文件位置==</p><p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar  G:/application.properties</p><h2 id="6-外部配置加载顺序"><a href="#6-外部配置加载顺序" class="headerlink" title="6.外部配置加载顺序"></a>6.外部配置加载顺序</h2><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p><p><strong>1.命令行参数</strong></p><p>所有的配置都可以在命令行上进行指定</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p><p>多个配置用空格分开； –配置项=值</p><p>2.来自java:comp/env的JNDI属性</p><p>3.Java系统属性（System.getProperties()）</p><p>4.操作系统环境变量</p><p>5.RandomValuePropertySource配置的random.*属性值</p><p><strong>由jar包外向jar包内进行寻找；</strong></p><p><strong>优先加载带profile</strong></p><p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>再来加载不带profile</strong></p><p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource</p><p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><p><img src="/images/spring-boot-configuration/20200305123720.png" alt="支持的配置"></p><h2 id="7-自动配置原理"><a href="#7-自动配置原理" class="headerlink" title="7.自动配置原理"></a>7.自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h3 id="7-1-自动配置原理："><a href="#7-1-自动配置原理：" class="headerlink" title="7.1.自动配置原理："></a>7.1.<strong>自动配置原理：</strong></h3><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 <strong>@EnableAutoConfiguration</strong></p><p>2）、<strong>@EnableAutoConfiguration 作用：</strong></p><ul><li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件;<ul><li>可以查看selectImports()方法的内容；</li><li>List<string> configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</string></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames()</span><br><span class="line"><span class="comment">//扫描所有jar包类路径下  META-INF/spring.factories</span></span><br><span class="line"><span class="comment">//把扫描到的这些文件的内容包装成properties对象</span></span><br><span class="line"><span class="comment">//从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</span></span><br></pre></td></tr></table></figure><p>将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p>3）、每一个自动配置类进行自动配置功能；</p><p>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="class">.<span class="keyword">class</span>)  //启动指定类的<span class="title">ConfigurationProperties</span>功能；将配置文件中对应的值和<span class="title">HttpEncodingProperties</span>绑定起来；并把<span class="title">HttpEncodingProperties</span>加入到<span class="title">ioc</span>容器中</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span> //<span class="title">Spring</span>底层@<span class="title">Conditional</span>注解（<span class="title">Spring</span>注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是<span class="title">web</span>应用，如果是，当前配置类生效</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(<span class="title">CharacterEncodingFilter</span>.<span class="title">class</span>)  //判断当前项目有没有这个类<span class="title">CharacterEncodingFilter</span>；<span class="title">SpringMVC</span>中进行乱码解决的过滤器；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.properties = properties;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>) //判断容器没有这个组件？</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">CharacterEncodingFilter</span> <span class="title">characterEncodingFilter</span>() </span>&#123;</span><br><span class="line">CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line"><span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>)  <span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p><strong>精髓：</strong></p><p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p><p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p><p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p><p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p><p>xxxxAutoConfigurartion：自动配置类；</p><p>给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h3 id="7-2-细节"><a href="#7-2-细节" class="headerlink" title="7.2.细节"></a>7.2.细节</h3><p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><p><strong>我们可以通过启用  debug=true属性；来让控制台打印自动配置报告</strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-CONFIGURATION REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">      - @<span class="title">ConditionalOnWebApplication</span> <span class="params">(required)</span> found <span class="title">StandardServletEnvironment</span> <span class="params">(OnWebApplicationCondition)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   AopAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="params">(OnClassCondition)</span></span></span><br></pre></td></tr></table></figure><h2 id="8-最后"><a href="#8-最后" class="headerlink" title="8.最后"></a>8.最后</h2><p>​    此spring boot部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-配置文件&quot;&gt;&lt;a href=&quot;#1-配置文件&quot; class=&quot;headerlink&quot; title=&quot;1.配置文件&quot;&gt;&lt;/a&gt;1.配置文件&lt;/h2&gt;&lt;p&gt;SpringBoot使用一个全局的配置文件，配置文件名是固定的；&lt;/p&gt;
&lt;p&gt;•application.properties&lt;/p&gt;
&lt;p&gt;•application.yml&lt;/p&gt;
&lt;p&gt;配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot入门</title>
    <link href="https://quietair.gitee.io/spring-boot-01/"/>
    <id>https://quietair.gitee.io/spring-boot-01/</id>
    <published>2020-02-29T12:24:00.000Z</published>
    <updated>2020-04-04T12:45:52.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring-Boot-简介"><a href="#1-Spring-Boot-简介" class="headerlink" title="1.Spring Boot 简介"></a>1.Spring Boot 简介</h2><p>-简化Spring应用开发的一个框架；</p><p>-整个Spring技术栈的一个大整合；</p><p>-J2EE开发的一站式解决方案；</p><a id="more"></a><h2 id="2-微服务"><a href="#2-微服务" class="headerlink" title="2.微服务"></a>2.微服务</h2><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p><p>单体应用：ALL IN ONE</p><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="noopener">详细参照微服务文档</a></p><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3.环境准备"></a>3.环境准备</h2><p>环境约束:</p><p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；</p><p>–maven3.x：maven 3.3以上版本；</p><p>–IntelliJIDEA：IntelliJ IDEA </p><p>–SpringBoot 1.5.9.RELEASE：1.5.9；</p><h3 id="3-1-MAVEN设置"><a href="#3-1-MAVEN设置" class="headerlink" title="3.1.MAVEN设置"></a>3.1.MAVEN设置</h3><p>给maven 的settings.xml配置文件的profiles标签添加(可以添加，也可以不用)；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-IDEA设置"><a href="#3-2-IDEA设置" class="headerlink" title="3.2.IDEA设置"></a>3.2.IDEA设置</h3><p>首先对maven进行整合；</p><p><img src="/images/spring-boot-01/20200229191224.png" alt="idea设置"></p><p><img src="/images/spring-boot-01/20200229191357.png" alt="images/"></p><h2 id="4-Spring-Boot-HelloWorld"><a href="#4-Spring-Boot-HelloWorld" class="headerlink" title="4.Spring Boot HelloWorld"></a>4.Spring Boot HelloWorld</h2><p>实现一个简单的功能：</p><p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p><h3 id="4-1-创建一个maven工程（jar）"><a href="#4-1-创建一个maven工程（jar）" class="headerlink" title="4.1.创建一个maven工程（jar）"></a>4.1.创建一个maven工程（jar）</h3><h3 id="4-2-导入spring-boot相关的依赖"><a href="#4-2-导入spring-boot相关的依赖" class="headerlink" title="4.2.导入spring boot相关的依赖"></a>4.2.导入spring boot相关的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-编写一个主程序；启动Spring-Boot应用"><a href="#4-3-编写一个主程序；启动Spring-Boot应用" class="headerlink" title="4.3.编写一个主程序；启动Spring Boot应用"></a>4.3.编写一个主程序；启动Spring Boot应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-编写相关的Controller、Service"><a href="#4-4-编写相关的Controller、Service" class="headerlink" title="4.4.编写相关的Controller、Service"></a>4.4.编写相关的Controller、Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运行主程序测试"><a href="#4-5-运行主程序测试" class="headerlink" title="4.5.运行主程序测试"></a>4.5.运行主程序测试</h3><h3 id="4-6-简化部署"><a href="#4-6-简化部署" class="headerlink" title="4.6.简化部署"></a>4.6.简化部署</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将这个应用打成jar包，再window下或者Linux下直接使用java -jar的命令进行执行；</p><h2 id="5-Hello-World探究"><a href="#5-Hello-World探究" class="headerlink" title="5.Hello World探究"></a>5.Hello World探究</h2><h3 id="5-1-POM文件"><a href="#5-1-POM文件" class="headerlink" title="5.1.POM文件"></a>5.1.POM文件</h3><h4 id="5-1-1父项目"><a href="#5-1-1父项目" class="headerlink" title="5.1.1父项目"></a>5.1.1父项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">上面的父项目是</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">它来真正管理Spring Boot应用里面的所有依赖版本；</span><br></pre></td></tr></table></figure><p>Spring Boot的版本仲裁中心；</p><p>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p><h4 id="5-1-2启动器"><a href="#5-1-2启动器" class="headerlink" title="5.1.2启动器"></a>5.1.2启动器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-boot-starter-<strong>web</strong>：</p><p>​    spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p><p>总结：Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p><h3 id="5-2-主程序类，主入口类"><a href="#5-2-主程序类，主入口类" class="headerlink" title="5.2.主程序类，主入口类"></a>5.2.主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">      @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p><p>​        标注在某个类上，表示这是一个Spring Boot的配置类；</p><p>​        @<strong>Configuration</strong>:配置类上来标注这个注解；</p><p>​            配置类 —–  配置文件；配置类也是容器中的一个组件；<strong>@Component</strong></p><p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p><p>​        以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>​    @<strong>AutoConfigurationPackage</strong>：自动配置包</p><p>​        @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p><p>​        Spring的底层注解<strong>@Import</strong>，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</p><p>将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</p><p>​    @<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p><p>​        给容器中导入组件？</p><p>​        <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p><p>​        将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p>​        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；        <img src="/images/spring-boot-01/20200229203810.png" alt="自动配置类"></p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p><p>​        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p><p>总结：Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；</p><p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p><h2 id="6-IDEA：使用-Spring-Initializer快速创建spring-boot项目"><a href="#6-IDEA：使用-Spring-Initializer快速创建spring-boot项目" class="headerlink" title="6.IDEA：使用 Spring Initializer快速创建spring boot项目"></a>6.IDEA：使用 Spring Initializer快速创建spring boot项目</h2><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p><p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p><p>默认生成的Spring Boot项目；</p><ul><li>主程序已经生成好了，我们只需要我们自己的逻辑</li><li>resources文件夹中目录结构<ul><li>static：保存所有的静态资源； js css  images；</li><li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li></ul></li></ul><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7.最后"></a>7.最后</h2><p>​    此spring boot部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Spring-Boot-简介&quot;&gt;&lt;a href=&quot;#1-Spring-Boot-简介&quot; class=&quot;headerlink&quot; title=&quot;1.Spring Boot 简介&quot;&gt;&lt;/a&gt;1.Spring Boot 简介&lt;/h2&gt;&lt;p&gt;-简化Spring应用开发的一个框架；&lt;/p&gt;
&lt;p&gt;-整个Spring技术栈的一个大整合；&lt;/p&gt;
&lt;p&gt;-J2EE开发的一站式解决方案；&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(三)之多线程并发</title>
    <link href="https://quietair.gitee.io/Java_heart_thread/"/>
    <id>https://quietair.gitee.io/Java_heart_thread/</id>
    <published>2019-12-15T07:52:18.000Z</published>
    <updated>2020-04-05T15:09:51.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JAVA并发知识库"><a href="#1-JAVA并发知识库" class="headerlink" title="1.JAVA并发知识库"></a>1.JAVA并发知识库</h2><p><img src="/images/Java_heart_thread/clip_image003.gif" alt="img"> </p><a id="more"></a><h2 id="2-JAVA-线程实现-创建方式"><a href="#2-JAVA-线程实现-创建方式" class="headerlink" title="2.JAVA 线程实现/创建方式"></a>2.JAVA 线程实现/创建方式</h2><h3 id="2-1-继承-Thread-类"><a href="#2-1-继承-Thread-类" class="headerlink" title="2.1.继承 Thread 类"></a>2.1.继承 Thread 类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。<strong>start()方法是一个 native 方法</strong>，它将启动一个新线程，并执行run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">myThread1.start();</span><br></pre></td></tr></table></figure><h3 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2.实现Runnable接口"></a>2.2.实现Runnable接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">"MyThread.run()"</span>);     </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：</span></span><br><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">//事实上，当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用</span></span><br><span class="line">target.run()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line"> target.run();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-ExecutorService、Callable、Future有返回值线程"><a href="#2-3-ExecutorService、Callable、Future有返回值线程" class="headerlink" title="2.3.ExecutorService、Callable、Future有返回值线程"></a>2.3.ExecutorService、Callable、Future有返回值线程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行 Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line"><span class="comment">// 创建多个有返回值的任务</span></span><br><span class="line">List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 执行任务并获取 Future 对象</span></span><br><span class="line">Future f = pool.submit(c);</span><br><span class="line">list.add(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line"><span class="keyword">for</span> (Future f : list) &#123;</span><br><span class="line"><span class="comment">// 从 Future 对象上获取任务的返回值，并输出到控制台</span></span><br><span class="line">System.out.println(<span class="string">"res："</span> + f.get().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-基于线程池的方式"><a href="#2-4-基于线程池的方式" class="headerlink" title="2.4. 基于线程池的方式"></a>2.4. 基于线程池的方式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 提交多个线程任务，并执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" is running .."</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-种线程池"><a href="#3-种线程池" class="headerlink" title="3.种线程池"></a>3.种线程池</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; Java 里面线程池的顶级接口是 <strong>Executor</strong>，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 <strong>ExecutorService</strong>。 </p><p><img src="/images/Java_heart_thread/clip_image008.gif" alt="img"></p><h3 id="3-1-newCachedThreadPool"><a href="#3-1-newCachedThreadPool" class="headerlink" title="3.1.   newCachedThreadPool"></a>3.1.   newCachedThreadPool</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。<strong>调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程</strong>。因此，长时间保持空闲的线程池不会使用任何资源。 </p><h3 id="3-2-newFixedThreadPool"><a href="#3-2-newFixedThreadPool" class="headerlink" title="3.2.   newFixedThreadPool"></a>3.2.   newFixedThreadPool</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程</strong>。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><h3 id="3-3-newScheduledThreadPool"><a href="#3-3-newScheduledThreadPool" class="headerlink" title="3.3.   newScheduledThreadPool"></a>3.3.   newScheduledThreadPool</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool=Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">scheduledThreadPool.schedule(newRunnable()&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"延迟三秒"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"延迟 1 秒后每三秒执行一次"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="3-4-newSingleThreadExecutor"><a href="#3-4-newSingleThreadExecutor" class="headerlink" title="3.4.   newSingleThreadExecutor"></a>3.4.   newSingleThreadExecutor</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,<strong>这个线程</strong></p><p><strong>池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去</strong>！ </p><h2 id="4-线程生命周期-状态"><a href="#4-线程生命周期-状态" class="headerlink" title="4.线程生命周期(状态)"></a>4.线程生命周期<strong>(</strong>状态<strong>)</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞 (Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换 </p><h3 id="4-1-新建状态（NEW）"><a href="#4-1-新建状态（NEW）" class="headerlink" title="4.1. 新建状态（NEW）"></a>4.1. 新建状态（<strong>NEW</strong>）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当程序<strong>使用 new 关键字创建了一个线程之后</strong>，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值 </p><h3 id="4-2-就绪状态（RUNNABLE）"><a href="#4-2-就绪状态（RUNNABLE）" class="headerlink" title="4.2. 就绪状态（RUNNABLE）"></a>4.2. 就绪状态（RUNNABLE）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当线程对象<strong>调用了 start()方法之后</strong>，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p><h3 id="4-3-运行状态（RUNNING）"><a href="#4-3-运行状态（RUNNING）" class="headerlink" title="4.3. 运行状态（RUNNING）"></a>4.3. 运行状态（RUNNING）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果处于<strong>就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体</strong>，则该线程处于运行状态。</p><h3 id="4-4-阻塞状态（BLOCKED）"><a href="#4-4-阻塞状态（BLOCKED）" class="headerlink" title="4.4. 阻塞状态（BLOCKED）"></a>4.4. 阻塞状态（BLOCKED）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p><ul><li><p><strong>等待阻塞(o.wait-&gt;等待对列)</strong>：运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列( waitting queue ) 中。 </p></li><li><p><strong>同步阻塞(lock-&gt;锁池)</strong>：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。 </p></li><li><p><strong>其他阻塞(sleep/join)</strong>： 运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时， JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行(runnable)状态。 </p></li></ul><h3 id="4-5-线程死亡（DEAD）"><a href="#4-5-线程死亡（DEAD）" class="headerlink" title="4.5. 线程死亡（DEAD）"></a>4.5. 线程死亡（DEAD）</h3><p>线程会以下面三种方式结束，结束后就是死亡状态。 </p><p><strong>正常结束</strong> ：</p><ol><li>run()或 call()方法执行完成，线程正常结束。</li></ol><p><strong>异常结束</strong> ：</p><ol start="2"><li>线程抛出一个未捕获的 Exception 或 Error。 </li></ol><p><strong>调用stop</strong>：</p><ol start="3"><li>直接调用该线程的 stop()方法来结束该线程—<strong>该方法通常容易导致死锁，不推荐使用</strong>。</li></ol><p><img src="/images/Java_heart_thread/clip_image002.gif" alt="img"> </p><h2 id="5-终止线程-4-种方式"><a href="#5-终止线程-4-种方式" class="headerlink" title="5.终止线程 4 种方式"></a>5.终止线程 4 种方式</h2><h3 id="5-1-正常运行结束"><a href="#5-1-正常运行结束" class="headerlink" title="5.1. 正常运行结束"></a>5.1. 正常运行结束</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;程序运行结束，线程自动结束。 </p><h3 id="5-2-使用退出标志退出线程"><a href="#5-2-使用退出标志退出线程" class="headerlink" title="5.2. 使用退出标志退出线程"></a>5.2. 使用退出标志退出线程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需<strong>要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程</strong>。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false 来控制while 循环是否退出，代码示例：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (!exit)&#123;</span><br><span class="line"> <span class="comment">//do something</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;定义了一个退出标志 exit，当 exit 为 true 时，while 循环退出，exit 的默认值为 false.在定义 exit 时，<strong>使用了一个 Java 关键字 volatile，这个关键字的目的是使 exit 同步</strong>，也就是说在同一时刻只能由一个线程来修改 exit 的值。  </p><h3 id="5-3-Interrupt-方法结束线程"><a href="#5-3-Interrupt-方法结束线程" class="headerlink" title="5.3.   Interrupt 方法结束线程"></a>5.3.   Interrupt 方法结束线程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;使用 interrupt()方法来中断线程有两种情况： </p><ol><li><p>线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。<strong>通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法</strong>。 </p></li><li><p>线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用 interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。 </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (!isInterrupted())&#123; <span class="comment">//非阻塞过程中通过判断中断标志来退出</span></span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);<span class="comment">//阻塞过程捕获中断异常来退出</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> <span class="keyword">break</span>;<span class="comment">//捕获到异常之后，执行 break 跳出循环</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-stop-方法终止线程（线程不安全）"><a href="#5-4-stop-方法终止线程（线程不安全）" class="headerlink" title="5.4.   stop 方法终止线程（线程不安全）"></a>5.4.   stop 方法终止线程（线程不安全）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是： thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在<strong>调用 thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)</strong>，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。 </p><h2 id="6-sleep-与-wait-区别"><a href="#6-sleep-与-wait-区别" class="headerlink" title="6. sleep 与 wait 区别"></a>6. sleep 与 wait 区别</h2><ol><li>对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于</li></ol><p>Object 类中的。 </p><ol start="2"><li><p>sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，<strong>但是他的监控状态依然保持着</strong>，当指定的时间到了又会自动恢复运行状态。</p></li><li><p>在调用 sleep()方法的过程中，<strong>线程不会释放对象锁</strong>。 </p></li><li><p>而当<strong>调用 wait()方法的时候，线程会放弃对象锁</strong>，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</p></li></ol><h2 id="7-start-与-run-区别"><a href="#7-start-与-run-区别" class="headerlink" title="7.start 与 run 区别"></a>7.start 与 run 区别</h2><ol><li><p>start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。 </p></li><li><p>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于<strong>就绪状态</strong>， 并没有运行。</p></li><li><p>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，<strong>开始运行 run 函数当中的代码</strong>。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。 </p></li></ol><h2 id="8-JAVA-后台线程"><a href="#8-JAVA-后台线程" class="headerlink" title="8.JAVA 后台线程"></a>8.JAVA 后台线程</h2><ol><li><p>定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即<strong>为用户线程 提供公共服务</strong>，在没有用户线程可服务时会自动离开。 </p></li><li><p>优先级：守护线程的<strong>优先级比较低</strong>，用于为系统中的其它对象和线程提供服务。 </p></li><li><p>设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。 </p></li><li><p>在 Daemon 线程中产生的新线程也是 Daemon 的。 </p></li><li><p><strong>线程则是 JVM 级别的</strong>，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。 </p></li><li><p>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread, 程序就不会再产生垃圾，垃圾回收器也就无事可做，<strong>所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开</strong>。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 </p></li><li><p>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。</p></li></ol><h2 id="9-JAVA-锁"><a href="#9-JAVA-锁" class="headerlink" title="9.JAVA 锁"></a>9.JAVA 锁</h2><h3 id="9-1-乐观锁"><a href="#9-1-乐观锁" class="headerlink" title="9.1. 乐观锁"></a>9.1. 乐观锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是<strong>在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作</strong>（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。 java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。 </p><h3 id="9-2-悲观锁"><a href="#9-2-悲观锁" class="headerlink" title="9.2. 悲观锁"></a>9.2. 悲观锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。 </p><h3 id="9-3-自旋锁"><a href="#9-3-自旋锁" class="headerlink" title="9.3. 自旋锁"></a>9.3. 自旋锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。 线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。 </p><p><strong>自旋锁的优缺点</strong> ：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！ </p><p>&nbsp;&nbsp;&nbsp;&nbsp;但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁； </p><p><strong>自旋锁时间阈值（1.6引入了适应性自旋锁）</strong> ：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！ </p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过( CPUs/ 2) 个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU 的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。 </p><p><strong>自旋锁的开启</strong> ：</p><p>JDK1.6 中-XX:+UseSpinning 开启； </p><p>-XX:PreBlockSpin=10 为自旋次数； </p><p>JDK1.7 后，去掉此参数，由 jvm 控制； </p><h3 id="9-4-Synchronized-同步锁"><a href="#9-4-Synchronized-同步锁" class="headerlink" title="9.4.   Synchronized 同步锁"></a>9.4.   Synchronized 同步锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;synchronized 它可以把任意一个非 NULL 的对象当作锁。<strong>他属于独占式的悲观锁，同时属于可重入锁</strong>。 </p><p><strong>Synchronized作用范围</strong> ：</p><ol><li><p>作用于方法时，锁住的是对象的实例(this)；</p></li><li><p>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen （jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</p></li><li><p>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p></li></ol><p><strong>Synchronized核心组件</strong> ：</p><p>1) 、 Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；</p><p>2) 、 Contention List：<strong>竞争队列</strong>，所有请求锁的线程首先被放在这个竞争队列中； </p><p>3)  、Entry List：Contention List 中那些<strong>有资格成为候选资源的线程被移动到 Entry List 中</strong>；</p><p>4)  、OnDeck：任意时刻，<strong>最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck</strong>；</p><p>5)  、Owner：当前已经获取到所资源的线程被称为 Owner； </p><p>6)  、!Owner：当前释放锁的线程。 </p><p><strong>Synchronized实现</strong> ：</p><p><img src="/images/Java_heart_thread/clip_image004.gif" alt="img"> </p><ol><li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下， ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。 </p></li><li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定 EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</p></li><li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck， OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在 JVM 中，也把这种选择行为称之为“竞争切换”。 </p></li><li><p>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList 中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify 或者 notifyAll 唤醒，会重新进去 EntryList 中。 </p></li><li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</p></li><li><p><strong>Synchronized 是非公平锁</strong>。 Synchronized 在线程进入 ContentionList 时，<u>等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的</u>，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></p><ol start="7"><li><p>每个对象都有个 monitor 对象，<strong>加锁就是在竞争 monitor 对象</strong>，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</p></li><li><p>synchronized <strong>是一个重量级操作，需要调用操作系统相关接口</strong>，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。 </p></li><li><p>Java1.6，synchronized进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了<strong>偏向锁和轻量级锁</strong>。都是在对象头中有标记位，不需要经过操作系统加锁。 </p></li><li><p><u>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁</u>。这种升级过程叫做锁膨胀； </p></li><li><p>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。 </p></li></ol><h3 id="9-5-ReentrantLock"><a href="#9-5-ReentrantLock" class="headerlink" title="9.5.   ReentrantLock"></a>9.5.   ReentrantLock</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，<strong>还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法</strong>。 </p><p><strong>Lock接口的主要方法</strong> ：</p><ol><li><p>void lock(): 执行此方法时, <strong>如果锁处于空闲状态, 当前线程将获取到锁</strong>. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁. </p></li><li><p>boolean tryLock()：<strong>如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false</strong>. 该方法和 lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. </p></li><li><p>void unlock()：执行此方法时, <strong>当前线程将释放持有的锁</strong>. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生. </p></li><li><p>Condition newCondition()：<strong>条件对象，获取等待通知组件</strong>。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。 </p></li><li><p>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次数。 </p></li><li><p>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9 </p></li><li><p>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了 condition 对象的 await 方法，那么此时执行此方法返回 10 </p></li><li><p>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法</p></li><li><p>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁 </p></li><li><p>hasQueuedThreads()：是否有线程等待此锁 </p></li><li><p>isFair()：该锁是否公平锁 </p></li><li><p>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true </p></li><li><p>isLock()：此锁是否有任意线程占用 </p></li><li><p>lockInterruptibly（）：如果当前线程未被中断，获取锁 </p></li><li><p>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁 </p></li><li><p>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。 </p></li></ol><p><strong>非公平锁</strong> ：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p><p><strong>公平锁</strong>： </p><p>&nbsp;&nbsp;&nbsp;&nbsp;公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁， ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。 </p><p><strong>ReentrantLock与synchronized</strong>：</p><ol><li><p>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，<strong>与 synchronized 会被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁</strong>。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</p></li><li><p>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。 </p></li></ol><p><strong>ReentrantLock实现</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//Lock lock=new ReentrantLock(true);//公平锁</span></span><br><span class="line"> <span class="comment">//Lock lock=new ReentrantLock(false);//非公平锁</span></span><br><span class="line"> <span class="keyword">private</span> Condition condition=lock.newCondition();<span class="comment">//创建 Condition</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> lock.lock();<span class="comment">//lock 加锁</span></span><br><span class="line"><span class="comment">//1：wait 方法等待：</span></span><br><span class="line"> <span class="comment">//System.out.println("开始 wait");</span></span><br><span class="line"> condition.await();</span><br><span class="line"><span class="comment">//通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span></span><br><span class="line"><span class="comment">//:2：signal 方法唤醒</span></span><br><span class="line">condition.signal();<span class="comment">//condition 对象的 signal 方法可以唤醒 wait 线程</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"ThreadName="</span> + Thread.currentThread().getName()+ (<span class="string">" "</span> + (i + <span class="number">1</span>)));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span>&#123;</span><br><span class="line"> lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Condition类和Object类锁方法区别区别</strong> :</p><ol><li><p>Condition 类的 awiat 方法和 Object 类的 wait 方法等效 </p></li><li><p>Condition 类的 signal 方法和 Object 类的 notify 方法等效 </p></li><li><p>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效 </p></li><li><p>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的 </p></li></ol><p><strong>tryLock和lock和lockInterruptibly 的区别</strong> :</p><ol><li><p>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false </p></li><li><p>lock 能获得锁就返回 true，不能的话一直等待获得锁</p></li><li><p>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时<strong>中断这两个线程， lock 不会抛出异常，而 lockInterruptibly 会抛出异常</strong>。 </p></li></ol><h3 id="9-6-Semaphore-信号量"><a href="#9-6-Semaphore-信号量" class="headerlink" title="9.6.   Semaphore 信号量"></a>9.6.   Semaphore 信号量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池 </p><p><strong>实现互斥锁（计数器为1）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。 </p><p>代码实现，它的用法如下： </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个计数阈值为 5 的信号量对象</span></span><br><span class="line"><span class="comment">// 只能 5 个线程同时访问</span></span><br><span class="line">Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 申请许可</span></span><br><span class="line">semp.acquire();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="number">13</span>/<span class="number">04</span>/<span class="number">2018</span> Page <span class="number">69</span> of <span class="number">283</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 释放许可</span></span><br><span class="line">semp.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Semaphore与ReentrantLock</strong>：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与 release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;此外，Semaphore 也实现了<strong>可轮询的锁请求与定时锁的功能</strong>，除了方法名 tryAcquire 与 tryLock 不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Semaphore的锁释放操作也由手动进行，因此与ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。 </p><h3 id="9-7-AtomicInteger"><a href="#9-7-AtomicInteger" class="headerlink" title="9.7.   AtomicInteger"></a>9.7.   AtomicInteger</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;首先说明，此处 AtomicInteger，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<v>将一个对象的所有操作转化成原子操作。 </v></p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们知道，<strong>在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一</strong>。通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger 的性能是 ReentantLock 的好几倍。 </p><h3 id="9-8-可重入锁（递归锁）"><a href="#9-8-可重入锁（递归锁）" class="headerlink" title="9.8. 可重入锁（递归锁）"></a>9.8. 可重入锁（递归锁）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本文里面讲的是广义上的可重入锁，而不是单指JAVA 下的ReentrantLock。<strong>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响</strong>。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。 </p><h3 id="9-9-公平锁与非公平锁"><a href="#9-9-公平锁与非公平锁" class="headerlink" title="9.9. 公平锁与非公平锁"></a><strong>9.9. 公平锁与非公平锁</strong></h3><p><strong>公平锁（Fair）</strong> ：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得 </p><p><strong>非公平锁（Nonfair）</strong> ：</p><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待 </p><ol><li><p>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</p></li><li><p>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。 </p></li></ol><h3 id="9-10-ReadWriteLock-读写锁"><a href="#9-10-ReadWriteLock-读写锁" class="headerlink" title="9.10. ReadWriteLock 读写锁"></a>9.10. ReadWriteLock 读写锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制</strong>，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。 </p><p><strong>读锁</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 </p><p><strong>写锁</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock。 </p><h3 id="9-11-共享锁和独占锁"><a href="#9-11-共享锁和独占锁" class="headerlink" title="9.11. 共享锁和独占锁"></a>9.11. 共享锁和独占锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;java 并发包提供的加锁模式分为独占锁和共享锁。 </p><p><strong>独占锁</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p><p><strong>共享锁</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><ol><li><p>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。 </p></li><li><p>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</p></li></ol><h3 id="9-12-重量级锁（Mutex-Lock）"><a href="#9-12-重量级锁（Mutex-Lock）" class="headerlink" title="9.12. 重量级锁（Mutex Lock）"></a>9.12. 重量级锁（Mutex Lock）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，<strong>这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”</strong>。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。 </p><h3 id="9-13-轻量级锁"><a href="#9-13-轻量级锁" class="headerlink" title="9.13. 轻量级锁"></a>9.13. 轻量级锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。 </p><p><strong>锁升级</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，<u>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁</u>。 </p><h3 id="9-14-偏向锁"><a href="#9-14-偏向锁" class="headerlink" title="9.14. 偏向锁"></a>9.14. 偏向锁</h3><p> &nbsp;&nbsp;&nbsp;&nbsp;Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。<u>偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护</u>。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，<u>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能</u>。 </p><h3 id="9-15-分段锁"><a href="#9-15-分段锁" class="headerlink" title="9.15. 分段锁"></a>9.15. 分段锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p><h3 id="9-16-锁优化"><a href="#9-16-锁优化" class="headerlink" title="9.16. 锁优化"></a>9.16. 锁优化</h3><p><strong>减少锁持有时间</strong> </p><ul><li>只用在有线程安全要求的程序上加锁 </li></ul><p><strong>减小锁粒度</strong> </p><ul><li>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是</li></ul><p>ConcurrentHashMap。 </p><p><strong>锁分离</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>最常见的锁分离就是读写锁 ReadWriteLock</strong>，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五]  JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据 </p><p><strong>锁粗化</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，<u>如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化</u> 。 </p><p><strong>锁消除</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。</p><p>参考：<a href="https://www.jianshu.com/p/39628e1180a9" target="_blank" rel="noopener">https://www.jianshu.com/p/39628e1180a9</a></p><h2 id="10-线程基本方法"><a href="#10-线程基本方法" class="headerlink" title="10.线程基本方法"></a>10.线程基本方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;线程相关的基本方法有 wait，notify，notifyAll，sleep，join，yield 等。</p><p><img src="/images/Java_heart_thread/clip_image005.gif" alt="img"> </p><h3 id="10-1-线程等待（wait）"><a href="#10-1-线程等待（wait）" class="headerlink" title="10.1. 线程等待（wait）"></a>10.1. 线程等待（wait）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，<strong>会释放对象的锁</strong>。因此，wait 方法一般用在同步方法或同步代码块中。 </p><h3 id="10-2-线程睡眠（sleep）"><a href="#10-2-线程睡眠（sleep）" class="headerlink" title="10.2. 线程睡眠（sleep）"></a>10.2. 线程睡眠（sleep）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;sleep 导致当前线程休眠，与 wait 方法不同的是 <strong>sleep 不会释放当前占有的锁</strong>,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态 </p><h3 id="10-3-线程让步（yield）"><a href="#10-3-线程让步（yield）" class="headerlink" title="10.3. 线程让步（yield）"></a>10.3. 线程让步（yield）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;yield 会使当前线程<strong>让出 CPU 执行时间片</strong>，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是 绝对的，有的操作系统对线程优先级并不敏感。 </p><h3 id="10-4-线程中断（interrupt）"><a href="#10-4-线程中断（interrupt）" class="headerlink" title="10.4. 线程中断（interrupt）"></a>10.4. 线程中断（interrupt）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;中断一个线程，其本意是给<strong>这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)</strong>。 </p><ol><li><p>调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。</p></li><li><p>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。 </p></li><li><p>许多声明抛出InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。 </p></li><li><p>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程thread的时候，可以调用thread.interrupt()方法，在线程的run方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。 </p></li></ol><h3 id="10-5-Join-等待其他线程终止"><a href="#10-5-Join-等待其他线程终止" class="headerlink" title="10.5. Join 等待其他线程终止"></a>10.5. Join 等待其他线程终止</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。 </p><h3 id="10-6-为什么要用-join-方法"><a href="#10-6-为什么要用-join-方法" class="headerlink" title="10.6. 为什么要用 join()方法"></a>10.6. 为什么要用 join()方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"线程运行开始!"</span>);</span><br><span class="line">Thread6 thread1 = <span class="keyword">new</span> Thread6();</span><br><span class="line">thread1.setName(<span class="string">"线程 B"</span>);</span><br><span class="line">thread1.join();</span><br><span class="line">System.out.println(<span class="string">"这时 thread1 执行完毕之后才能执行主线程"</span>);</span><br></pre></td></tr></table></figure><h3 id="10-7-线程唤醒（notify）"><a href="#10-7-线程唤醒（notify）" class="headerlink" title="10.7. 线程唤醒（notify）"></a>10.7. 线程唤醒（notify）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Object 类中的 notify() 方法，<strong>唤醒在此对象监视器上等待的单个线程</strong>，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，<u>直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程</u>，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。 </p><h3 id="10-8-其他方法："><a href="#10-8-其他方法：" class="headerlink" title="10.8. 其他方法："></a>10.8. 其他方法：</h3><ol><li><p>sleep()：强迫一个线程睡眠Ｎ毫秒。 </p></li><li><p>isAlive()： 判断一个线程是否存活。 </p></li><li><p>join()： 等待线程终止。 </p></li><li><p>activeCount()： 程序中活跃的线程数。 </p></li><li><p>enumerate()： 枚举程序中的线程。 </p></li><li><p>currentThread()： 得到当前线程。 </p></li><li><p>isDaemon()： 一个线程是否为守护线程。 </p></li><li><p>setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) </p></li><li><p>setName()： 为线程设置一个名称。 </p></li><li><p>wait()： 强迫一个线程等待。 </p></li><li><p>notify()： 通知一个线程继续运行。 </p></li><li><p>setPriority()： 设置一个线程的优先级。 </p></li><li><p>getPriority():：获得一个线程的优先级。</p></li></ol><h2 id="11-线程上下文切换"><a href="#11-线程上下文切换" class="headerlink" title="11.线程上下文切换"></a>11.线程上下文切换</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的  时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，<strong>任务的状态保存及再加载, 这段过程就叫做上下文切换</strong>。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。 </p><p><img src="/images/Java_heart_thread/clip_image009.gif" alt="img"> </p><h3 id="11-1-进程"><a href="#11-1-进程" class="headerlink" title="11.1. 进程"></a>11.1. 进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;（有时候也称做任务）是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。</p><h3 id="11-2-上下文"><a href="#11-2-上下文" class="headerlink" title="11.2. 上下文"></a>11.2. 上下文</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是指某一时间点 CPU 寄存器和程序计数器的内容。 </p><h3 id="11-3-寄存器"><a href="#11-3-寄存器" class="headerlink" title="11.3. 寄存器"></a>11.3. 寄存器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速</p><p>度。 </p><h3 id="11-4-程序计数器"><a href="#11-4-程序计数器" class="headerlink" title="11.4. 程序计数器"></a>11.4. 程序计数器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</p><h3 id="11-5-PCB-“切换桢”"><a href="#11-5-PCB-“切换桢”" class="headerlink" title="11.5. PCB-“切换桢”"></a>11.5. PCB-“切换桢”</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。 </p><h3 id="11-6-上下文切换的活动"><a href="#11-6-上下文切换的活动" class="headerlink" title="11.6. 上下文切换的活动"></a>11.6. 上下文切换的活动</h3><ol><li><p>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。</p></li><li><p>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。 </p></li><li><p>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。</p></li></ol><h3 id="11-7-引起线程上下文切换的原因"><a href="#11-7-引起线程上下文切换的原因" class="headerlink" title="11.7. 引起线程上下文切换的原因"></a>11.7. 引起线程上下文切换的原因</h3><ol><li><p>当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务； </p></li><li><p>当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；</p></li><li><p>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；</p></li><li><p>用户代码挂起当前任务，让出 CPU 时间；</p></li><li><p>硬件中断； </p></li></ol><h2 id="12-同步锁与死锁"><a href="#12-同步锁与死锁" class="headerlink" title="12.同步锁与死锁"></a>12.同步锁与死锁</h2><h3 id="12-1-同步锁"><a href="#12-1-同步锁" class="headerlink" title="12.1. 同步锁"></a>12.1. 同步锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要<strong>保证线程同步互斥，就是指并发执行的多个线程</strong>，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。</p><h3 id="12-2-死锁"><a href="#12-2-死锁" class="headerlink" title="12.2. 死锁"></a>12.2. 死锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。 </p><h2 id="13-线程池原理"><a href="#13-线程池原理" class="headerlink" title="13.线程池原理"></a>13.线程池原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量<strong>超过了最大数量超出数量的线程排队等候</strong>，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：<strong>线程复用；控制最大并发数；管理线程</strong>。 </p><h3 id="13-1-线程复用"><a href="#13-1-线程复用" class="headerlink" title="13.1.线程复用"></a>13.1.线程复用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 <strong>我们可以继承重写 Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象</strong>。 这就是线程池的实现原理。<u>循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的</u>。 </p><h3 id="13-2-线程池的组成"><a href="#13-2-线程池的组成" class="headerlink" title="13.2.线程池的组成"></a>13.2.线程池的组成</h3><p>一般的线程池主要分为以下 4 个组成部分： </p><ol><li><p>线程池管理器：用于创建并管理线程池 </p></li><li><p>工作线程：线程池中的线程 </p></li><li><p>任务接口：每个任务必须实现的接口，用于工作线程调度其运行 </p></li><li><p>任务队列：用于存放待处理的任务，提供一种缓冲机制 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和 Future、FutureTask 这几个类。 </p><p><img src="/images/Java_heart_thread/clip_image006.gif" alt="img"></p><p>ThreadPoolExecutor 的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>corePoolSize：指定了线程池中的线程数量。 </p></li><li><p>maximumPoolSize：指定了线程池中的最大线程数量。 </p></li><li><p>keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。 </p></li><li><p>unit：keepAliveTime 的单位。</p></li><li><p>workQueue：任务队列，被提交但尚未被执行的任务。 </p></li><li><p>threadFactory：线程工厂，用于创建线程，一般用默认的即可。 </p></li><li><p>handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。 </p></li></ol><h3 id="13-3-拒绝策略"><a href="#13-3-拒绝策略" class="headerlink" title="13.3. 拒绝策略"></a>13.3. 拒绝策略</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。 </p><p>JDK 内置的拒绝策略如下： </p><ol><li><p>AbortPolicy ： 直接抛出异常，阻止系统正常运行。 </p></li><li><p>CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。 </p></li><li><p>DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 </p></li><li><p>DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。 </p><h3 id="13-4-Java-线程池工作过程"><a href="#13-4-Java-线程池工作过程" class="headerlink" title="13.4. Java 线程池工作过程"></a>13.4. Java 线程池工作过程</h3><ol><li><p>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p></li><li><p>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><p>a)   如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务； </p><p>b)   如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； </p><p>c)   如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； </p><p>d)   如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。 </p></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。 </p></li><li><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。 </p></li></ol><p><img src="/images/Java_heart_thread/clip_image008.jpg" alt="img"> </p><h2 id="14-JAVA-阻塞队列原理"><a href="#14-JAVA-阻塞队列原理" class="headerlink" title="14.JAVA 阻塞队列原理"></a>14.JAVA 阻塞队列原理</h2><p>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：</p><ol><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</li></ol><p><img src="/images/Java_heart_thread/clip_image010.gif" alt="img"> </p><ol start="2"><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</li></ol><p><img src="/images/Java_heart_thread/clip_image012.gif" alt="img"> </p><h3 id="14-1-阻塞队列的主要方法"><a href="#14-1-阻塞队列的主要方法" class="headerlink" title="14.1. 阻塞队列的主要方法"></a>14.1. 阻塞队列的主要方法</h3><p><img src="/images/Java_heart_thread/clip_image014.gif" alt="img"> </p><ul><li>抛出异常：抛出一个异常； </li><li>特殊值：返回一个特殊值（null 或 false,视情况而定） </li><li>则塞：在成功操作之前，一直阻塞线程 </li><li>超时：放弃前只在最大的时间内阻塞 </li></ul><p><strong>插入操作：</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;1：public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;2：public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;3：public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E paramE)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;     </span><br><span class="line">    checkNotNull(paramE); </span><br><span class="line">ReentrantLock localReentrantLock = <span class="keyword">this</span>.lock;              localReentrantLock.lockInterruptibly();     </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.count == <span class="keyword">this</span>.items.length) </span><br><span class="line">        <span class="keyword">this</span>.notFull.await();<span class="comment">//如果队列满了，则线程阻塞等待       enqueue(paramE); </span></span><br><span class="line">     localReentrantLock.unlock(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;       </span><br><span class="line">        localReentrantLock.unlock(); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;4：offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败。 </p><p><strong>获取数据操作：</strong> </p><ol><li><p>poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数规定的时间,取不到时返回 null; </p></li><li><p>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在</p><p>指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。 </p></li><li><p>take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入。 </p></li><li><p>drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。 </p></li></ol><h3 id="14-2-Java-中的阻塞队列"><a href="#14-2-Java-中的阻塞队列" class="headerlink" title="14.2. Java 中的阻塞队列"></a>14.2. Java 中的阻塞队列</h3><ol><li><p>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。 </p></li><li><p>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。 </p></li><li><p>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。 </p></li><li><p>DelayQueue：使用优先级队列实现的无界阻塞队列。 </p></li><li><p>SynchronousQueue：不存储元素的阻塞队列。 </p></li><li><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列。 </p></li><li><p>LinkedBlockingDeque：由链表结构组成的双向阻塞队列 </p></li></ol><p><img src="/images/Java_heart_thread/clip_image016.gif" alt="img">  </p><h3 id="14-3-ArrayBlockingQueue（公平、非公平）"><a href="#14-3-ArrayBlockingQueue（公平、非公平）" class="headerlink" title="14.3.ArrayBlockingQueue（公平、非公平）"></a>14.3.ArrayBlockingQueue（公平、非公平）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。<strong>默认情况下不保证访问者公平的访问队列</strong>，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码<strong>创建一个公平的阻塞队列</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="14-4-LinkedBlockingQueue（两个独立锁提高并发）"><a href="#14-4-LinkedBlockingQueue（两个独立锁提高并发）" class="headerlink" title="14.4. LinkedBlockingQueue（两个独立锁提高并发）"></a>14.4. LinkedBlockingQueue（两个独立锁提高并发）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;基于链表的阻塞队列，同ArrayListBlockingQueue类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的<strong>处理并发数据</strong>，还因为其<strong>对于生产者端和消费者端分别采用了独立的锁来控制数据同步</strong>，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。 </p><h3 id="14-5-PriorityBlockingQueue（compareTo排序实现优先）"><a href="#14-5-PriorityBlockingQueue（compareTo排序实现优先）" class="headerlink" title="14.5.PriorityBlockingQueue（compareTo排序实现优先）"></a>14.5.PriorityBlockingQueue（compareTo排序实现优先）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是一个<strong>支持优先级的无界队列</strong>。默认情况下元素采取自然顺序升序排列。可以自定义实现 compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><h3 id="14-6-DelayQueue（缓存失效、定时任务-）"><a href="#14-6-DelayQueue（缓存失效、定时任务-）" class="headerlink" title="14.6.DelayQueue（缓存失效、定时任务 ）"></a>14.6.DelayQueue（缓存失效、定时任务 ）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是一个支持<strong>延时获取元素的无界阻塞队列</strong>。队列使用PriorityQueue来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景： </p><ol><li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。</li><li>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。 </li></ol><h3 id="14-7-SynchronousQueue（不存储数据、可用于传递数据）"><a href="#14-7-SynchronousQueue（不存储数据、可用于传递数据）" class="headerlink" title="14.7.SynchronousQueue（不存储数据、可用于传递数据）"></a>14.7.SynchronousQueue（不存储数据、可用于传递数据）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素</strong>。 SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另 外 一 个 线 程 使 用 ， SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和ArrayBlockingQueue。 </p><h3 id="14-8-LinkedTransferQueue"><a href="#14-8-LinkedTransferQueue" class="headerlink" title="14.8. LinkedTransferQueue"></a>14.8. LinkedTransferQueue</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。 </p><ol><li><p>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的 poll()方法时），transfer 方法可以<strong>把生产者传入的元素立刻 transfer（传输）给消费者</strong>。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。 </p></li><li><p>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。</p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。 </p><h3 id="14-9-LinkedBlockingDeque"><a href="#14-9-LinkedBlockingDeque" class="headerlink" title="14.9. LinkedBlockingDeque"></a>14.9. LinkedBlockingDeque</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是一个由链表结构组成的<strong>双向阻塞队列</strong>。所谓双向队列指的<strong>你可以从队列的两端插入和移出元素</strong>。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast， peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。 </p><h2 id="15-CyclicBarrier、CountDownLatch、Semaphore-的用法"><a href="#15-CyclicBarrier、CountDownLatch、Semaphore-的用法" class="headerlink" title="15.CyclicBarrier、CountDownLatch、Semaphore 的用法"></a>15.CyclicBarrier、CountDownLatch、Semaphore 的用法</h2><h3 id="15-1-CountDownLatch（线程计数器-）"><a href="#15-1-CountDownLatch（线程计数器-）" class="headerlink" title="15.1.CountDownLatch（线程计数器 ）"></a>15.1.CountDownLatch（线程计数器 ）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch 来实现这种功能了。 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> Thread()&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;;&#125;.start();</span><br><span class="line"><span class="keyword">new</span> Thread()&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;;&#125;.start();</span><br><span class="line">System.out.println(<span class="string">"等待 2 个子线程执行完毕..."</span>);</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">"2 个子线程已经执行完毕"</span>);</span><br><span class="line">System.out.println(<span class="string">"继续执行主线程"</span>);</span><br></pre></td></tr></table></figure><h3 id="15-2-CyclicBarrier（回环栅栏-等待至-barrier-状态再全部同时执行）"><a href="#15-2-CyclicBarrier（回环栅栏-等待至-barrier-状态再全部同时执行）" class="headerlink" title="15.2. CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）"></a>15.2. CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做barrier，当调用 await()方法之后，线程就处于 barrier 了。 </p><p>CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本： </p><ol><li><p>public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务； </p></li><li><p>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。 </p></li></ol><p>具体使用如下，另外 CyclicBarrier 是可以重用的。 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line"> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"> <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">5000</span>); <span class="comment">//以睡眠来模拟线程需要预定写入数据操作</span></span><br><span class="line">System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">cyclicBarrier.await();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">"所有线程写入完毕，继续处理其他任务，比如数据操作"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-3-Semaphore（信号量-控制同时访问的线程个数）"><a href="#15-3-Semaphore（信号量-控制同时访问的线程个数）" class="headerlink" title="15.3.Semaphore（信号量-控制同时访问的线程个数）"></a>15.3.Semaphore（信号量-控制同时访问的线程个数）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Semaphore 翻译成字面意思为 信号量，<strong>Semaphore 可以控制同时访问的线程个数</strong>，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p><p>Semaphore 类中比较重要的几个方法：</p><ol><li><p>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</p></li><li><p>public void acquire(int permits):获取 permits 个许可</p></li><li><p>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。 </p></li><li><p>public void release(int permits) { }:释放 permits 个许可 </p></li></ol><p>上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法 </p><ol><li><p>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false </p></li><li><p>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false </p></li><li><p>public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false </p></li><li><p>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits 个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false </p></li><li><p>还可以通过 availablePermits()方法得到可用的许可数目。 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;例子：若一个工厂有5 台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = <span class="number">8</span>; <span class="comment">//工人数</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">new</span> Worker(i,semaphore).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num,Semaphore semaphore)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line"><span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">semaphore.acquire();</span><br><span class="line">System.out.println(<span class="string">"工人"</span>+<span class="keyword">this</span>.num+<span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(<span class="string">"工人"</span>+<span class="keyword">this</span>.num+<span class="string">"释放出机器"</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不 同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 <strong>CyclicBarrier 一般用于一组线程互相等待至某个状态</strong>，然后这一组线程再同时执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。 </li><li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li></ul><h2 id="16-volatile-关键字的作用（变量可见性、禁止重排序）"><a href="#16-volatile-关键字的作用（变量可见性、禁止重排序）" class="headerlink" title="16.volatile 关键字的作用（变量可见性、禁止重排序）"></a>16.volatile 关键字的作用（变量可见性、禁止重排序）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。 </p><p><strong>变量可见性</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。</u> </p><p><strong>禁止重排序</strong> </p><p> <u>volatile 禁止了指令重排。</u> </p><p>比sychronized更轻量级的同步锁 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。 </p><p><img src="/images/Java_heart_thread/clip_image017.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。 </p><p><strong>适用场景</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：</p><p> （1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）。</p><p>（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。<strong>只有在状态真正独立于程序内其他内容时才能使用 volatile</strong>。 </p><h2 id="17-如何在两个线程之间共享数据"><a href="#17-如何在两个线程之间共享数据" class="headerlink" title="17.如何在两个线程之间共享数据"></a>17.如何在两个线程之间共享数据</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。有以下常规实现方法： </p><ul><li>将数据抽象成一个类，并将数据的操作作为这个类的方法 </li></ul><ol><li>将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到同步，只要在方法上加”synchronized“ </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"> j++;</span><br><span class="line">System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line"> j--;</span><br><span class="line"> System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> j;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> MyData data;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">AddRunnable</span><span class="params">(MyData data)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.data= data;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> data.add();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> MyData data;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DecRunnable</span><span class="params">(MyData data)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.data = data;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> data.dec();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line"> Runnable add = <span class="keyword">new</span> AddRunnable(data);</span><br><span class="line"> Runnable dec = <span class="keyword">new</span> DecRunnable(data);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">new</span> Thread(add).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(dec).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Runnable对象作为一个类的内部类 </li></ul><ol start="2"><li>将 Runnable 对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个 Runnable 对象调用外部类的这些方法。 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"> j++;</span><br><span class="line"> System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line"> j--;</span><br><span class="line"> System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> data.add();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> data.dec();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;).start();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-ThreadLocal-作用（线程本地存储）"><a href="#18-ThreadLocal-作用（线程本地存储）" class="headerlink" title="18.ThreadLocal 作用（线程本地存储）"></a>18.ThreadLocal 作用（线程本地存储）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 </p><p><strong>ThreadLocalMap（线程的一个属性）</strong> </p><ol><li><p>每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。 </p></li><li><p>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的 ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。 </p></li><li><p>ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义 </p><p>ThreadLocal.ThreadLocalMap threadLocals = null; </p></li></ol><p><img src="/images/Java_heart_thread/clip_image018.gif" alt="img"> </p><p><strong>使用场景</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line"> Session s = (Session) threadSession.get();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line"> s = getSessionFactory().openSession();</span><br><span class="line"> threadSession.set(s);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-synchronized-和-ReentrantLock-的区别"><a href="#19-synchronized-和-ReentrantLock-的区别" class="headerlink" title="19.synchronized 和 ReentrantLock 的区别"></a>19.synchronized 和 ReentrantLock 的区别</h2><h3 id="19-1-两者的共同点："><a href="#19-1-两者的共同点：" class="headerlink" title="19.1. 两者的共同点："></a>19.1. 两者的共同点：</h3><ol><li><p>都是用来协调多线程对共享对象、变量的访问 </p></li><li><p>都是可重入锁，同一线程可以多次获得同一个锁 </p></li><li><p>都保证了可见性和互斥性 </p></li></ol><h3 id="19-2-两者的不同点："><a href="#19-2-两者的不同点：" class="headerlink" title="19.2. 两者的不同点："></a>19.2. 两者的不同点：</h3><ol><li><p>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁 </p></li><li><p>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 </p></li><li><p><strong>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</strong></p></li><li><p>ReentrantLock 可以实现公平锁 </p></li><li><p>ReentrantLock 通过 Condition 可以绑定多个条件</p></li><li><p>底层实现不一样， <strong>synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略</strong> </p></li><li><p>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。 </p></li><li><p><strong>synchronized 在发生异常时，会自动释放线程占有的锁</strong>，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。 </p></li><li><p><strong>Lock 可以让等待锁的线程响应中断</strong>，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。 </p></li><li><p>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 </p></li><li><p>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。 </p></li></ol><h2 id="20-ConcurrentHashMap-并发"><a href="#20-ConcurrentHashMap-并发" class="headerlink" title="20.ConcurrentHashMap 并发"></a>20.ConcurrentHashMap 并发</h2><h3 id="20-1-减小锁粒度"><a href="#20-1-减小锁粒度" class="headerlink" title="20.1.  减小锁粒度"></a>20.1.  减小锁粒度</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被<strong>称为 ConcurrentHashMap 的并发度</strong>。 </p><h3 id="20-2-ConcurrentHashMap-分段锁"><a href="#20-2-ConcurrentHashMap-分段锁" class="headerlink" title="20.2.  ConcurrentHashMap 分段锁"></a>20.2.  ConcurrentHashMap 分段锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。<strong>默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段</strong>，既就是锁的并发度。 如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据hashcode得到该表项应该存放在哪个段中，然后对该段加锁，并完成put操作。在多线程环境中，如果多个线程同时进行put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。 </p><p><strong>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， <strong>每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</strong> </p><p><img src="/images/Java_heart_thread/clip_image19.gif" alt="img"> </p><h2 id="21-Java-中用到的线程调度"><a href="#21-Java-中用到的线程调度" class="headerlink" title="21.Java 中用到的线程调度"></a>21.Java 中用到的线程调度</h2><h3 id="21-1-抢占式调度："><a href="#21-1-抢占式调度：" class="headerlink" title="21.1.  抢占式调度："></a>21.1.  抢占式调度：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</p><h3 id="21-2-协同式调度："><a href="#21-2-协同式调度：" class="headerlink" title="21.2.  协同式调度："></a>21.2.  协同式调度：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</p><p><img src="/images/Java_heart_thread/clip_image20.gif" alt="img"> </p><h3 id="21-3-JVM-的线程调度实现（抢占式调度）"><a href="#21-3-JVM-的线程调度实现（抢占式调度）" class="headerlink" title="21.3.  JVM 的线程调度实现（抢占式调度）"></a>21.3.  JVM 的线程调度实现（抢占式调度）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，<strong>且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片</strong>，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</p><h3 id="21-4-线程让出-cpu-的情况："><a href="#21-4-线程让出-cpu-的情况：" class="headerlink" title="21.4.  线程让出 cpu 的情况："></a>21.4.  线程让出 cpu 的情况：</h3><ol><li><p>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。 </p></li><li><p>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。 </p></li><li><p>当前运行线程结束，即运行完 run()方法里面的任务。</p></li></ol><h2 id="22-进程调度算法"><a href="#22-进程调度算法" class="headerlink" title="22.进程调度算法"></a>22.进程调度算法</h2><h3 id="22-1-优先调度算法"><a href="#22-1-优先调度算法" class="headerlink" title="22.1. 优先调度算法"></a>22.1. 优先调度算法</h3><ol><li>先来先服务调度算法（FCFS）    </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。 </p><ol start="2"><li>短作业(进程)优先调度算法 </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</p><h3 id="22-2-高优先权优先调度算法"><a href="#22-2-高优先权优先调度算法" class="headerlink" title="22.2. 高优先权优先调度算法"></a>22.2. 高优先权优先调度算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</p><ol><li>非抢占式优先权算法 </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><ol start="2"><li>抢占式优先权调度算法 </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。<strong>但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程</strong>(原优先权最高的进程) 的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p><ol start="3"><li>高响应比优先调度算法    </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为： </p><p><img src="/images/Java_heart_thread/clip_image010.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;(1)   如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;(2)   当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;(3)   对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p><h3 id="22-3-基于时间片的轮转调度算法"><a href="#22-3-基于时间片的轮转调度算法" class="headerlink" title="22.3. 基于时间片的轮转调度算法"></a>22.3. 基于时间片的轮转调度算法</h3><ol><li>时间片轮转法 </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。<strong>当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片</strong>。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。 </p><ol start="2"><li>多级反馈队列调度算法 </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;1)、应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;2)、当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;3)、仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</p><h2 id="23-什么是-CAS（比较并交换-乐观锁机制-锁自旋）"><a href="#23-什么是-CAS（比较并交换-乐观锁机制-锁自旋）" class="headerlink" title="23.什么是 CAS（比较并交换-乐观锁机制-锁自旋）"></a>23.什么是 CAS（比较并交换-乐观锁机制-锁自旋）</h2><h3 id="23-1-概念及特性"><a href="#23-1-概念及特性" class="headerlink" title="23.1.  概念及特性"></a>23.1.  概念及特性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数 CAS(V,E,N)。<strong>V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。<strong>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作</strong>。基于这样的原理， CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。 </p><h3 id="23-2-原子包-java-util-concurrent-atomic（锁自旋）"><a href="#23-2-原子包-java-util-concurrent-atomic（锁自旋）" class="headerlink" title="23.2.  原子包 java.util.concurrent.atomic（锁自旋）"></a>23.2.  原子包 java.util.concurrent.atomic（锁自旋）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，<strong>即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入</strong>，这只是一种逻辑上的理解。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。<strong>由于一般 CPU 切换时间比 CPU 指令集操作更加长</strong>， 所以 J.U.C 在性能上有了很大的提升。如下代码： </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (;;) &#123; <span class="comment">//CAS 自旋，一直尝试，直达成功</span></span><br><span class="line"> <span class="keyword">int</span> current = get();</span><br><span class="line"> <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line"> <span class="keyword">return</span> current;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;getAndIncrement 采用了 CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行 CAS 操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成 CPU 指令的操作。 </p><p><img src="/images/Java_heart_thread/clip_image022.gif" alt="img"> </p><h3 id="23-3-ABA-问题"><a href="#23-3-ABA-问题" class="headerlink" title="23.3.  ABA 问题"></a>23.3.  ABA 问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;CAS 会导致“ABA 问题”。<strong>CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化</strong>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;比如说一个线程 <strong>one 从内存位置 V 中取出 A</strong>，这时候另一个线程 <strong>two 也从内存中取出 A</strong>，并且 <strong>two 进行了一些操作变成了 B</strong>，然后 <strong>two 又将 V 位置的数据变成 A</strong>，这时候线程 <strong>one 进行 CAS 操作发现内存中仍然是 A</strong>，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</p><h2 id="24-什么是-AQS（抽象的队列同步器）"><a href="#24-什么是-AQS（抽象的队列同步器）" class="headerlink" title="24.什么是 AQS（抽象的队列同步器）"></a>24.什么是 AQS（抽象的队列同步器）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，<strong>AQS 定义了一套多线程访问共享资源的同步器框架</strong>，许多同步类实现都依赖于它，如常用的ReentrantLock、Semaphore、CountDownLatch。 </p><p><img src="/images/Java_heart_thread/clip_image023.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种: </p><ul><li>getState() </li><li>setState() </li><li>compareAndSetState() </li></ul><p><strong>AQS 定义两种资源共享方式</strong> </p><p><strong>Exclusive独占资源-ReentrantLock</strong></p><p><strong>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）</strong> </p><p><strong>Share共享资源-Semaphore/CountDownLatch</strong></p><p><strong>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现</strong>，AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS)之所以没有定义成 abstract，是因为独占模式下只用实现 tryAcquire-tryRelease，而共享模式下只用实现 tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/ 唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法： </p><ol><li><p>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。 </p></li><li><p>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。 3． tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。 </p></li><li><p>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 </p></li><li><p>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。 </p></li></ol><p><strong>同步器的实现是ABS核心（state资源状态计数）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;同步器的实现是 ABS 核心，以 ReentrantLock 为例，<strong>state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止</strong>，其它线程才有机会获取该锁。当然，释放锁之前，<strong>A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念</strong>。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS 减1。等到所有子线程都执行完后(即state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。 </p><p><strong>ReentrantReadWriteLock实现独占和共享两种方式</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 <strong>AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock</strong>。</p><h2 id="25-最后"><a href="#25-最后" class="headerlink" title="25.最后"></a>25.最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-JAVA并发知识库&quot;&gt;&lt;a href=&quot;#1-JAVA并发知识库&quot; class=&quot;headerlink&quot; title=&quot;1.JAVA并发知识库&quot;&gt;&lt;/a&gt;1.JAVA并发知识库&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/Java_heart_thread/clip_image003.gif&quot; alt=&quot;img&quot;&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(二)之集合</title>
    <link href="https://quietair.gitee.io/Java_heart_list/"/>
    <id>https://quietair.gitee.io/Java_heart_list/</id>
    <published>2019-11-09T06:32:07.000Z</published>
    <updated>2020-04-05T14:12:08.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-接口继承关系和实现"><a href="#1-接口继承关系和实现" class="headerlink" title="1.接口继承关系和实现"></a>1.接口继承关系和实现</h2><p>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。</p><ol><li><p>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。</p></li><li><p>Iterator：迭代器，可以通过迭代器遍历集合中的数据 </p></li><li><p>Map：是映射表的基础接口 </p></li></ol><a id="more"></a><p><img src="/images/Java_heart_list/clip_image003.gif" alt> </p><p><img src="/images/Java_heart_list/clip_image005.gif" alt="img"> </p><h2 id="2-List"><a href="#2-List" class="headerlink" title="2.List"></a>2.List</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 的 List 是非常常用的数据类型。<strong>List 是有序的 Collection</strong>。Java List 一共三个实现类：分别是 ArrayList、Vector 和 LinkedList。 </p><p><img src="/images/Java_heart_list/clip_image007.jpg" alt="img"> </p><h3 id="2-1-ArrayList（数组）"><a href="#2-1-ArrayList（数组）" class="headerlink" title="2.1.  ArrayList（数组）"></a>2.1.  ArrayList（数组）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 </p><h3 id="2-2-Vector（数组实现、线程同步）"><a href="#2-2-Vector（数组实现、线程同步）" class="headerlink" title="2.2.  Vector（数组实现、线程同步）"></a>2.2.  Vector（数组实现、线程同步）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Vector 与 ArrayList 一样，也是通过数组实现的，不同的是<strong>它支持线程的同步，即某一时刻只有一个线程能够写 Vector</strong>，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 </p><h3 id="2-3-LinkList（链表）"><a href="#2-3-LinkList（链表）" class="headerlink" title="2.3.  LinkList（链表）"></a>2.3.  LinkList（链表）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除</strong>，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 </p><h2 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，<strong>值不能重复</strong>。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，<strong>如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法</strong>。 </p><p><img src="/images/Java_heart_list/clip_image009.gif" alt="img"> </p><h3 id="3-1-HashSet（Hash-表）"><a href="#3-1-HashSet（Hash-表）" class="headerlink" title="3.1.HashSet（Hash 表）"></a>3.1.HashSet（Hash 表）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的 hashcode 方法来获取的，** HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。** </p><p>&nbsp;&nbsp;&nbsp;&nbsp;哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。 </p><p><img src="/images/Java_heart_list/clip_image011.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;HashSet 通过 hashCode 值来确定元素在内存中的位置。<strong>一个 hashCode 位置上可以存放多个元素</strong>。 </p><h3 id="3-2-TreeSet（二叉树）"><a href="#3-2-TreeSet（二叉树）" class="headerlink" title="3.2.TreeSet（二叉树）"></a>3.2.TreeSet（二叉树）</h3><ol><li><p>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 </p></li><li><p>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，<strong>自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数</strong>，才可以正常使用。 </p></li><li><p>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序 </p></li><li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p></li></ol><h3 id="3-3-LinkHashSet（HashSet-LinkedHashMap）"><a href="#3-3-LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="3.3.LinkHashSet（HashSet+LinkedHashMap）"></a>3.3.LinkHashSet（HashSet+LinkedHashMap）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。 LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 </p><h2 id="4-Map"><a href="#4-Map" class="headerlink" title="4.Map"></a>4.Map</h2><p><img src="/images/Java_heart_list/clip_image013.gif" alt="img"> </p><h3 id="4-1-HashMap（数组-链表-红黑树）"><a href="#4-1-HashMap（数组-链表-红黑树）" class="headerlink" title="4.1. HashMap（数组+链表+红黑树）"></a>4.1. HashMap（数组+链表+红黑树）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍HashMap 的结构。</p><h4 id="4-1-1-JAVA7-实现"><a href="#4-1-1-JAVA7-实现" class="headerlink" title="4.1.1.   JAVA7 实现"></a>4.1.1.   JAVA7 实现</h4><p><img src="/images/Java_heart_list/clip_image015.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：<strong>key, value, hash 值和用于单向链表</strong>的 next。 </p><ol><li><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 </p></li><li><p>loadFactor：负载因子，默认为 0.75。</p></li><li><p>threshold：扩容的阈值，等于 capacity * loadFactor </p></li></ol><h4 id="4-1-2-JAVA8-实现"><a href="#4-1-2-JAVA8-实现" class="headerlink" title="4.1.2.   JAVA8 实现"></a>4.1.2.   JAVA8 实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; Java8对 HashMap 进行了一些修改，<strong>最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树组成</strong>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;根据Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，<strong>需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)</strong>。为了降低这部分的开销，在 Java8 中，<strong>当链表中的元素超过了 8 个以后，会将链表转换为红黑树</strong>，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 </p><p><img src="/images/Java_heart_list/clip_image017.gif" alt="img"> </p><h3 id="4-2-ConcurrentHashMap"><a href="#4-2-ConcurrentHashMap" class="headerlink" title="4.2. ConcurrentHashMap"></a>4.2. ConcurrentHashMap</h3><h4 id="4-2-1-Segment段"><a href="#4-2-1-Segment段" class="headerlink" title="4.2.1.   Segment段"></a>4.2.1.   Segment段</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 </p><p>segment。 </p><h4 id="4-2-2-线程安全Segment继承ReentrantLock加锁）"><a href="#4-2-2-线程安全Segment继承ReentrantLock加锁）" class="headerlink" title="4.2.2.线程安全Segment继承ReentrantLock加锁）"></a>4.2.2.线程安全Segment继承ReentrantLock加锁）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="/images/Java_heart_list/clip_image019.gif" alt="img"> </p><h4 id="4-2-3-并行度（默认16）"><a href="#4-2-3-并行度（默认16）" class="headerlink" title="4.2.3.并行度（默认16）"></a>4.2.3.并行度（默认16）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 <strong>ConcurrentHashMap 有 16 个 Segments</strong>，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 </p><h4 id="4-2-4-Java8-实现（引入了红黑树）"><a href="#4-2-4-Java8-实现（引入了红黑树）" class="headerlink" title="4.2.4. Java8 实现（引入了红黑树）"></a>4.2.4. Java8 实现（引入了红黑树）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。 </p><p><img src="/images/Java_heart_list/clip_image021.gif" alt="img"> </p><h3 id="4-3-HashTable（线程安全）"><a href="#4-3-HashTable（线程安全）" class="headerlink" title="4.3. HashTable（线程安全）"></a>4.3. HashTable（线程安全）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。 </p><h3 id="4-4-TreeMap（可排序）"><a href="#4-4-TreeMap（可排序）" class="headerlink" title="4.4. TreeMap（可排序）"></a>4.4. TreeMap（可排序）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。 如果使用排序的映射，建议使用 TreeMap。 </p><p>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。 </p><p>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html</a></p><p><strong>4.5. LinkHashMap</strong>（记录插入顺序） </p><p>&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 </p><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5.最后"></a>5.最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-接口继承关系和实现&quot;&gt;&lt;a href=&quot;#1-接口继承关系和实现&quot; class=&quot;headerlink&quot; title=&quot;1.接口继承关系和实现&quot;&gt;&lt;/a&gt;1.接口继承关系和实现&lt;/h2&gt;&lt;p&gt;集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Collection：Collection 是集合 List、Set、Queue 的最基本的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Iterator：迭代器，可以通过迭代器遍历集合中的数据 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Map：是映射表的基础接口 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(一)之JVM</title>
    <link href="https://quietair.gitee.io/Java_heart_JVM/"/>
    <id>https://quietair.gitee.io/Java_heart_JVM/</id>
    <published>2019-10-24T07:24:00.000Z</published>
    <updated>2020-04-05T14:11:14.115Z</updated>
    
    <content type="html"><![CDATA[<p>(1) 基本概念：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM是可运行Java代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。 </p><a id="more"></a><p><img src="/images/Java_heart_JVM/java_1_jvm_01.png" alt></p><p><strong>(2) 运行过程：</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件， 而字节码文件又通过Java虚拟机中的解释器，编译成特定机器上的机器码 。也就是如下：<br>     ① Java源文件—-&gt;编译器—-&gt;字节码文件<br>     ② 字节码文件—-&gt;JVM—-&gt;机器码<br>&nbsp;&nbsp;&nbsp;&nbsp;每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够 跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会 存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不 能共享。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_02.png" alt></p><h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1.线程"></a>1.线程</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。 <u>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系</u>。<strong>当线程本地存储、缓 冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可 用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。</strong> </p><p>Hotspot JVM 后台运行的系统线程主要有下面几个：</p><table><thead><tr><th align="center">名称</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">虚拟机线程 （VM thread）</td><td align="center">这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当 堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。</td></tr><tr><td align="center">周期性任务线程</td><td align="center">这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</td></tr><tr><td align="center">GC 线程</td><td align="center">这些线程支持 JVM 中不同的垃圾回收活动。</td></tr><tr><td align="center">编译器线程</td><td align="center">这些线程在运行时将字节码动态编译成本地平台相关的机器码。</td></tr><tr><td align="center">信号分发线程</td><td align="center">这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。</td></tr></tbody></table><h2 id="2-JVM-内存区域"><a href="#2-JVM-内存区域" class="headerlink" title="2.JVM 内存区域"></a>2.JVM 内存区域</h2><p><img src="/images/Java_heart_JVM/java_1_jvm_03.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区 域【JAVA堆、方法区】、直接内存。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>线程私有数据区域生命周期与线程相同, 依赖用户线程的启动/结束 而 创建/销毁(在 Hotspot VM 内,</strong> 每个线程都与操作系统的本地线程直接映射, 因此这部分内存区域的存/否跟随本地线程的 生/死对应)。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>线程共享区域随虚拟机的启动/关闭而创建/销毁。</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;直接内存并不是JVM运行时数据区的一部分, 但也会被频繁的使用: 在JDK 1.4引入的NIO提 供了基于 Channel 与 Buffer 的 IO 方式, 它可以使用 Native 函数库直接分配堆外内存, 然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展), 这样就避免了在 Java 堆和Native堆中来回复制数据, 因此在一些场景中可以显著提高性能。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_04.png" alt></p><h3 id="2-1-程序计数器-线程私有"><a href="#2-1-程序计数器-线程私有" class="headerlink" title="2.1. 程序计数器(线程私有)"></a>2.1. 程序计数器(线程私有)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一块较小的内存空间, <strong>是当前线程所执行的字节码的行号指示器</strong>，每条线程都要有一个独立的 程序计数器，这类内存也称为“线程私有”的内存。<br>&nbsp;&nbsp;&nbsp;&nbsp;正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如 果还是Native方法，则为空。<br>&nbsp;&nbsp;&nbsp;&nbsp;这个内存区域是唯一一个在虚拟机中没有规定任何OutOfMemoryError情况的区域。 </p><h3 id="2-2-虚拟机栈-线程私有"><a href="#2-2-虚拟机栈-线程私有" class="headerlink" title="2.2. 虚拟机栈(线程私有)"></a>2.2. 虚拟机栈(线程私有)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是描述java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<u>每一个方法从调用直至执行完成 的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</u><br>&nbsp;&nbsp;&nbsp;&nbsp;栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接 (Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。<u>栈帧随着方法调用而创建，随着方法结束而销毁</u>——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异 常）都算作方法结束。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_05.png" alt></p><h3 id="2-3-本地方法区-线程私有"><a href="#2-3-本地方法区-线程私有" class="headerlink" title="2.3. 本地方法区(线程私有)"></a>2.3. 本地方法区(线程私有)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本地方法区和<strong>Java Stack作用类似</strong>, 区别是虚拟机栈为执行Java方法服务, 而<strong>本地方法栈则为 Native方法服务</strong>, 如果一个VM实现使用C-linkage模型来支持Native调用, 那么该栈将会是一个 C栈，但HotSpot VM直接就把本地方法栈和虚拟机栈合二为一。 </p><h3 id="2-4-堆（Heap-线程共享）运行时数据区"><a href="#2-4-堆（Heap-线程共享）运行时数据区" class="headerlink" title="2.4. 堆（Heap-线程共享）运行时数据区"></a>2.4. 堆（Heap-线程共享）运行时数据区</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是被线程共享的一块内存区域，<strong>创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行 垃圾收集的最重要的内存区域</strong>。由于现代VM采用分代收集算法, 因此Java堆从GC的角度还可以 细分为: 新生代( Eden 区 、 From Survivor 区 和 To Survivor 区 )和老年代。 </p><h3 id="2-5-方法区-永久代（线程共享）"><a href="#2-5-方法区-永久代（线程共享）" class="headerlink" title="2.5. 方法区/永久代（线程共享）"></a>2.5. 方法区/永久代（线程共享）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;即我们常说的<strong>永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静 态变量、即时编译器编译后的代码</strong>等数据. HotSpot VM把GC分代收集扩展至方法区, 即使用Java 堆的永久代来实现方法区, 这样HotSpot的垃圾收集器就可以像管理Java堆一样管理这部分内存, 而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型 的卸载, 因此收益一般很小)。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>运行时常量池</u>（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版 本、字段、方法、接口等描述等信息外，还有一项信息是常量池 Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加 载后存放到方法区的运行时常量池中。 Java虚拟机对Class文件的每一部分（自然也包括常量 池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会 被虚拟机认可、装载和执行。 </p><h2 id="3-JVM-运行时内存"><a href="#3-JVM-运行时内存" class="headerlink" title="3. JVM 运行时内存"></a>3. JVM 运行时内存</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java堆从GC的角度还可以细分为: <u>新生代</u>( Eden 区 、 From Survivor 区 和To Survivor 区 )和<u>老年代</u>。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_06.png" alt></p><h3 id="3-1-新生代"><a href="#3-1-新生代" class="headerlink" title="3.1. 新生代"></a>3.1. 新生代</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是用来存放新生的对象。一般占据堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC进行垃圾回收。新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。</p><h4 id="3-1-1-Eden-区"><a href="#3-1-1-Eden-区" class="headerlink" title="3.1.1. Eden 区"></a>3.1.1. Eden 区</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Java新对象的出生地</strong>（如果新创建的对象占用内存很大，则直接分配到老 年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行 一次垃圾回收。</p><h4 id="3-1-2-ServivorFrom"><a href="#3-1-2-ServivorFrom" class="headerlink" title="3.1.2. ServivorFrom"></a>3.1.2. ServivorFrom</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;上一次GC的幸存者，作为这一次GC 的被扫描者。 </p><h4 id="3-1-3-ServivorTo"><a href="#3-1-3-ServivorTo" class="headerlink" title="3.1.3. ServivorTo"></a>3.1.3. ServivorTo</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;保留了一次MinorGC过程中的幸存者。 </p><h4 id="3-1-4-MinorGC的过程（复制-gt-清空-gt-互换）"><a href="#3-1-4-MinorGC的过程（复制-gt-清空-gt-互换）" class="headerlink" title="3.1.4.  MinorGC的过程（复制-&gt;清空-&gt;互换）"></a>3.1.4.  MinorGC的过程（复制-&gt;清空-&gt;互换）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;MinorGC采用<strong>复制算法</strong>。 </p><p><strong>1 ： eden 、 servicorFrom 复制到 ServicorTo ，年龄 + 1</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先，把Eden和ServivorFrom区域中存活的对象复制到ServicorTo区域（如果有对象的年 龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不 够位置了就放到老年区）； </p><p><strong>2 ： 清空 eden 、 servicorFrom</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;然后，清空Eden和ServicorFrom中的对象； </p><p><strong>3 ： ServicorTo和 ServicorFrom互换</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;最后，ServicorTo和ServicorFrom互换，原ServicorTo成为下一次GC时的ServicorFrom 区。 </p><h3 id="3-2-老年代"><a href="#3-2-老年代" class="headerlink" title="3.2. 老年代"></a>3.2. 老年代</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;主要存放应用程序中生命周期长的内存对象。<br>&nbsp;&nbsp;&nbsp;&nbsp;老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行 了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足 够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。<br>&nbsp;&nbsp;&nbsp;&nbsp;MajorGC 采用<strong>标记清除算法</strong>：首先扫描一次所有老年代，标记出存活的对象，然后回收没 有标记的对象。MajorGC的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减 少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的 时候，就会抛出OOM（Out of Memory）异常。 </p><h3 id="3-3-永久代"><a href="#3-3-永久代" class="headerlink" title="3.3. 永久代"></a>3.3. 永久代</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息,Class 在被加载的时候被 放入永久区域，它和和存放实例的区域不同,<strong>GC 不会在主程序运行期对永久区域进行清理</strong>。所以这 也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。 </p><h4 id="3-3-1-JAVA8与元数据"><a href="#3-3-1-JAVA8与元数据" class="headerlink" title="3.3.1. JAVA8与元数据"></a>3.3.1. JAVA8与元数据</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在Java8中，<u>永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代</u>。元空间 的本质和永久代类似，元空间与永久代之间最大的区别在于：<strong>元空间并不在虚拟机中，而是使用 本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制。<strong>类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中</strong>，这样可以加载多少类的元数据就不再由 MaxPermSize控制, 而由系统的实际可用空间来控制。 </p><h2 id="4-垃圾回收与算法"><a href="#4-垃圾回收与算法" class="headerlink" title="4.垃圾回收与算法"></a>4.垃圾回收与算法</h2><p><img src="/images/Java_heart_JVM/java_1_jvm_07.png" alt></p><h3 id="4-1-如何确定垃圾"><a href="#4-1-如何确定垃圾" class="headerlink" title="4.1. 如何确定垃圾"></a>4.1. 如何确定垃圾</h3><h4 id="4-1-1-引用计数法"><a href="#4-1-1-引用计数法" class="headerlink" title="4.1.1. 引用计数法"></a>4.1.1. 引用计数法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单 的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个<strong>对象如果没有任何与之关 联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。</strong> </p><h4 id="4-1-2-可达性分析"><a href="#4-1-2-可达性分析" class="headerlink" title="4.1.2. 可达性分析"></a>4.1.2. 可达性分析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的“GC roots” 对象作为起点搜索。如果<strong>在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;要注意的是，<strong>不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程</strong>。两次标记后仍然是可回收对象，则将面临回收。 </p><h3 id="4-2-标记清除算法（Mark-Sweep）"><a href="#4-2-标记清除算法（Mark-Sweep）" class="headerlink" title="4.2. 标记清除算法（Mark-Sweep）"></a>4.2. 标记清除算法（Mark-Sweep）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;最基础的垃圾回收算法，分为<strong>两个阶段，标注和清除</strong>。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间。如图:</p><p><img src="/images/Java_heart_JVM/java_1_jvm_08.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;从图中我们就可以发现，该算法<strong>最大的问题是内存碎片化严重</strong>，后续可能发生大对象不能找到可 利用空间的问题。 </p><h3 id="4-3-复制算法（copying）"><a href="#4-3-复制算法（copying）" class="headerlink" title="4.3. 复制算法（copying）"></a>4.3. 复制算法（copying）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;为了解决Mark-Sweep算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小 的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用 的内存清掉，如图： </p><p><img src="/images/Java_heart_JVM/java_1_jvm_09.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原 本的一半。且存活对象增多的话，Copying算法的效率会大大降低。 </p><h3 id="4-4-标记整理算法-Mark-Compact"><a href="#4-4-标记整理算法-Mark-Compact" class="headerlink" title="4.4. 标记整理算法(Mark-Compact)"></a>4.4. 标记整理算法(Mark-Compact)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;结合了以上两个算法，为了避免缺陷而提出。标记阶段和Mark-Sweep算法相同，标记后不是清 理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图： </p><p><img src="/images/Java_heart_JVM/java_1_jvm_10.png" alt></p><h3 id="4-5-分代收集算法"><a href="#4-5-分代收集算法" class="headerlink" title="4.5. 分代收集算法"></a>4.5. 分代收集算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;分代收集法是目前大部分JVM所采用的方法，其核心思想是根据对象存活的不同生命周期将内存 划分为不同的域，一般情况下将GC堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃 圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。 </p><h4 id="4-5-1-新生代与复制算法"><a href="#4-5-1-新生代与复制算法" class="headerlink" title="4.5.1. 新生代与复制算法"></a>4.5.1. 新生代与复制算法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;目前大部分JVM的GC 对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要 回收大部分对象，即要复制的操作比较少，但通常并不是按照1：1来划分新生代。一般将新生代 划分为一块较大的Eden空间和两个较小的Survivor空间(From Space, To Space)，每次使用 Eden空间和其中的一块Survivor空间，当进行回收时，将该两块空间中还存活的对象复制到另 一块Survivor空间中。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_11.1.png" alt></p><h4 id="4-5-2-老年代与标记复制算法"><a href="#4-5-2-老年代与标记复制算法" class="headerlink" title="4.5.2. 老年代与标记复制算法"></a>4.5.2. 老年代与标记复制算法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;而老年代因为每次只回收少量对象，因而采用Mark-Compact算法。 </p><ol><li>JAVA虚拟机提到过的处于<strong>方法区的永生代(Permanet Generation)，它用来存储class类， 常量，方法描述</strong>等。对永生代的回收主要包括废弃常量和无用的类。 </li><li>对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目 前存放对象的那一块)，少数情况会直接分配到老生代。 </li><li>当新生代的Eden Space和From Space空间不足时就会发生一次GC，进行GC后，Eden Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space进行清理。 </li><li>如果To Space无法足够存储某个对象，则将这个对象存储到老生代。 </li><li>在进行GC后，使用的便是Eden Space和To Space了，如此反复循环。 </li><li>当对象在Survivor区躲过一次GC 后，其年龄就会+1。<strong>默认情况下年龄到达15 的对象会被 移到老生代中。</strong> </li></ol><h2 id="5-JAVA-四中引用类型"><a href="#5-JAVA-四中引用类型" class="headerlink" title="5.JAVA 四中引用类型"></a>5.JAVA 四中引用类型</h2><h3 id="5-1-强引用"><a href="#5-1-强引用" class="headerlink" title="5.1. 强引用"></a>5.1. 强引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Java 中最常见的就是强引用，<strong>把一个对象赋给一个引用变量，这个引用变量就是一个强引 用。当一个对象被强引用变量引用时</strong>，它处于可达状态，它是不可能被垃圾回收机制回收的，即 使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成Java内存泄漏的主要原因之 一。 </p><h3 id="5-2-软引用"><a href="#5-2-软引用" class="headerlink" title="5.2. 软引用"></a>5.2. 软引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>软引用需要用 SoftReference 类来实现</strong>，对于只有软引用的对象来说，当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。 </p><h3 id="5-3-弱引用"><a href="#5-3-弱引用" class="headerlink" title="5.3. 弱引用"></a>5.3. 弱引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;弱引用需要用WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，总会回收该对象占用的内存。 </p><h3 id="5-4-虚引用"><a href="#5-4-虚引用" class="headerlink" title="5.4. 虚引用"></a>5.4. 虚引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;虚引用需要PhantomReference类来实现，它不能单独使用，必须和引用队列联合使用。<strong>虚引用的主要作用是跟踪对象被垃圾回收的状态</strong>。</p><h2 id="6-GC-分代收集算法-VS-分区收集算法"><a href="#6-GC-分代收集算法-VS-分区收集算法" class="headerlink" title="6.GC 分代收集算法  VS 分区收集算法"></a>6.GC 分代收集算法  VS 分区收集算法</h2><h3 id="6-1-分代收集算法"><a href="#6-1-分代收集算法" class="headerlink" title="6.1. 分代收集算法"></a>6.1. 分代收集算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当前主流VM垃圾收集都采用”分代收集”(Generational Collection)算法, 这种算法会根据 对象存活周期的不同将内存划分为几块, 如JVM中的 新生代、老年代、永久代，这样就可以根据 各年代特点分别采用最适当的GC 算法 </p><h4 id="6-1-1-在新生代-复制算法"><a href="#6-1-1-在新生代-复制算法" class="headerlink" title="6.1.1. 在新生代-复制算法"></a>6.1.1. 在新生代-复制算法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;每次垃圾收集都能发现大批对象已死, 只有少量存活. 因此选用复制算法, 只需要付出少量 存活对象的复制成本就可以完成收集. </p><h4 id="6-1-2-在老年代-标记整理算法"><a href="#6-1-2-在老年代-标记整理算法" class="headerlink" title="6.1.2. 在老年代-标记整理算法"></a>6.1.2. 在老年代-标记整理算法</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;因为对象存活率高、没有额外空间对它进行分配担保, 就必须采用<strong>“标记—清理”或“标 记—整理”</strong>算法来进行回收, 不必进行内存复制, 且直接腾出空闲内存. </p><h3 id="6-2-分区收集算法"><a href="#6-2-分区收集算法" class="headerlink" title="6.2. 分区收集算法"></a>6.2. 分区收集算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;分区算法则将整个堆空间划分为连续的不同小区间, 每个小区间独立使用, 独立回收. 这样做的 好处是可以控制一次回收多少个小区间 , 根据目标停顿时间, 每次合理地回收若干个小区间(而不是 整个堆), 从而减少一次GC 所产生的停顿。 </p><h2 id="7-GC-垃圾收集器"><a href="#7-GC-垃圾收集器" class="headerlink" title="7. GC 垃圾收集器"></a>7. GC 垃圾收集器</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法； 年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不 同的垃圾收集器，JDK1.6中Sun HotSpot虚拟机的垃圾收集器如下：</p><p> <img src="/images/Java_heart_JVM/java_1_jvm_11.png" alt></p><h3 id="7-1-Serial-垃圾收集器（单线程、复制算法）"><a href="#7-1-Serial-垃圾收集器（单线程、复制算法）" class="headerlink" title="7.1.  Serial 垃圾收集器（单线程、复制算法）"></a>7.1.  Serial 垃圾收集器（单线程、复制算法）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Serial（英文连续）是最基本垃圾收集器，使用复制算法</strong>，曾经是JDK1.3.1之前新生代唯一的垃圾 收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工 作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。 Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限 定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial 垃圾收集器依然是<strong>java虚拟机运行在Client模式下默认的新生代垃圾收集器</strong>。 </p><h3 id="7-2-ParNew-垃圾收集器（Serial-多线程）"><a href="#7-2-ParNew-垃圾收集器（Serial-多线程）" class="headerlink" title="7.2.  ParNew 垃圾收集器（Serial+多线程）"></a>7.2.  ParNew 垃圾收集器（Serial+多线程）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;ParNew垃圾收集器其实是<strong>Serial收集器的多线程版本</strong>，也使用复制算法，除了使用多线程进行垃 圾收集之外，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也 要暂停所有其他的工作线程。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过-XX:ParallelGCThreads 参数来限 制垃圾收集器的线程数。【Parallel：平行的】 ParNew虽然是除了多线程外和Serial收集器几乎完全一样，但是ParNew垃圾收集器是<strong>很多java 虚拟机运行在Server模式下新生代的默认垃圾收集器</strong>。 </p><h3 id="7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="7.3. Parallel Scavenge 收集器（多线程复制算法、高效）"></a>7.3. Parallel Scavenge 收集器（多线程复制算法、高效）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃 圾收集器，它<strong>重点关注的是程序达到一个可控制的吞吐量</strong>（Thoughput，CPU 用于运行用户代码 的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)）， 高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而 不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个 重要区别。 </p><h3 id="7-4-Serial-Old-收集器（单线程标记整理算法-）"><a href="#7-4-Serial-Old-收集器（单线程标记整理算法-）" class="headerlink" title="7.4. Serial Old 收集器（单线程标记整理算法 ）"></a>7.4. Serial Old 收集器（单线程标记整理算法 ）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>Serial Old 是 Serial 垃圾收集器年老代版本</strong>，它同样是个单线程的收集器，使用标记-整理算法， 这个收集器也主要是<strong>运行在Client默认的java虚拟机默认的年老代垃圾收集器</strong>。 在Server模式下，主要有两个用途： </p><ol><li>在JDK1.5之前版本中与新生代的Parallel Scavenge收集器搭配使用。</li><li>作为年老代中使用CMS收集器的后备垃圾收集方案。 新生代Serial与年老代Serial Old搭配垃圾收集过程图： </li></ol><p><img src="/images/Java_heart_JVM/java_1_jvm_12.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;新生代Parallel Scavenge收集器与ParNew收集器工作原理类似，都是多线程的收集器，都使 用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代Parallel Scavenge/ParNew与年老代Serial Old搭配垃圾收集过程图： </p><p><img src="/images/Java_heart_JVM/java_1_jvm_13.png" alt></p><h3 id="7-5-Parallel-Old-收集器（多线程标记整理算法）"><a href="#7-5-Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="7.5. Parallel Old 收集器（多线程标记整理算法）"></a>7.5. Parallel Old 收集器（多线程标记整理算法）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Parallel Old收集器是Parallel Scavenge的年老代版本，使用多线程的标记-整理算法，在JDK1.6 才开始提供。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只 能保证新生代的吞吐量优先，无法保证整体的吞吐量，<strong>Parallel Old 正是为了在年老代同样提供吞 吐量优先的垃圾收集器</strong>，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge 和年老代Parallel Old收集器的搭配策略。 新生代Parallel Scavenge和年老代Parallel Old收集器搭配运行过程图： </p><p><img src="/images/Java_heart_JVM/java_1_jvm_14.png" alt></p><h3 id="7-6-CMS-收集器（多线程标记清除算法）"><a href="#7-6-CMS-收集器（多线程标记清除算法）" class="headerlink" title="7.6. CMS 收集器（多线程标记清除算法）"></a>7.6. CMS 收集器（多线程标记清除算法）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最<strong>主要目标是获取最短垃圾回收停顿时间</strong>，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。  CMS工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下4个阶段： </p><h4 id="7-6-1-初始标记"><a href="#7-6-1-初始标记" class="headerlink" title="7.6.1. 初始标记"></a>7.6.1. 初始标记</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 </p><h4 id="7-6-2-并发标记"><a href="#7-6-2-并发标记" class="headerlink" title="7.6.2. 并发标记"></a>7.6.2. 并发标记</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。 </p><h4 id="7-6-3-重新标记"><a href="#7-6-3-重新标记" class="headerlink" title="7.6.3. 重新标记"></a>7.6.3. 重新标记</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记 记录，仍然需要暂停所有的工作线程。 </p><h4 id="7-6-4-并发清除"><a href="#7-6-4-并发清除" class="headerlink" title="7.6.4. 并发清除"></a>7.6.4. 并发清除</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并 发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以<strong>总体上来看 CMS收集器的内存回收和用户线程是一起并发地执行</strong>。 CMS收集器工作过程： </p><p><img src="/images/Java_heart_JVM/java_1_jvm_15.png" alt></p><h3 id="7-7-G1-收集器"><a href="#7-7-G1-收集器" class="headerlink" title="7.7. G1 收集器"></a>7.7. G1 收集器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与CMS 收集器，G1 收 集器两个最突出的改进是： </p><ol><li>基于标记-整理算法，不产生内存碎片。 </li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 <strong>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域</strong>，并且跟踪这些区域 的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，<strong>优先回收垃圾最多的区域</strong>。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收 集效率。 </li></ol><h2 id="8-JAVA-IO-NIO"><a href="#8-JAVA-IO-NIO" class="headerlink" title="8.  JAVA IO/NIO"></a>8.  JAVA IO/NIO</h2><h3 id="8-1-阻塞-IO-模型"><a href="#8-1-阻塞-IO-模型" class="headerlink" title="8.1. 阻塞 IO 模型"></a>8.1. 阻塞 IO 模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出IO 请求之后，内 核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用 户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。典型的阻塞IO模型的例子为：<strong>data = socket.read()</strong>;如果数据没有就 绪，就会一直阻塞在read方法。 </p><h3 id="8-2-非阻塞-IO-模型"><a href="#8-2-非阻塞-IO-模型" class="headerlink" title="8.2. 非阻塞 IO 模型"></a>8.2. 非阻塞 IO 模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备 好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO 不会交出CPU，而会一直占用CPU。典型的非阻塞IO模型一般如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">    data = socket.read();</span><br><span class="line">    <span class="keyword">if</span>(data!= error)&#123;  </span><br><span class="line">        处理数据  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;但是对于非阻塞IO就有一个非常严重的问题，<u>在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高</u>，因此一般情况下很少使用while循环这种方式来读取数据。 </p><h3 id="8-3-多路复用-IO-模型"><a href="#8-3-多路复用-IO-模型" class="headerlink" title="8.3. 多路复用 IO 模型"></a>8.3. 多路复用 IO 模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。在多路复用IO 模型中，<strong>会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真 正调用实际的IO读写操作</strong>。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。在Java NIO中，是通 过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这 种方式会导致用户线程的阻塞。多路复用IO 模式，通过一个线程就可以管理多个socket，只有当 socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO 比较适合连 接数比较多的情况。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO 中，不断地询问socket状态 时通过用户线程去进行的，而在多路复用IO 中，轮询每个socket状态是内核在进行的，这个效 率要比用户线程要高的多。</u> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;不过要注意的是，多路复用IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件 逐一进行响应。因此对于多路复用IO模型来说，<strong>一旦事件响应体很大，那么就会导致后续的事件 迟迟得不到处理，并且会影响新的事件轮询</strong>。 </p><h3 id="8-4-信号驱动-IO-模型"><a href="#8-4-信号驱动-IO-模型" class="headerlink" title="8.4. 信号驱动 IO 模型"></a>8.4. 信号驱动 IO 模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在信号驱动IO 模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函 数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到 信号之后，便在信号函数中调用IO 读写操作来进行实际的IO 请求操作。 </p><h3 id="8-5-异步-IO-模型"><a href="#8-5-异步-IO-模型" class="headerlink" title="8.5. 异步 IO 模型"></a>8.5. 异步 IO 模型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;异步IO模型才是最理想的IO 模型，在异步IO 模型中，当用户线程发起read操作之后，立刻就 可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后， 它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内 核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程 发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何 进行的，<strong>只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接 去使用数据了。</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完 成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO 函数进行具体的 读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据 已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号 表示IO操作已经完成，不需要再在用户线程中调用IO函数进行实际的读写操作。 </p><p><strong>注意，异步IO 是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。</strong> </p><h3 id="8-6-JAVA-IO-包"><a href="#8-6-JAVA-IO-包" class="headerlink" title="8.6. JAVA IO 包"></a>8.6. JAVA IO 包</h3><p><img src="/images/Java_heart_JVM/java_1_jvm_16.png" alt></p><h3 id="8-7-JAVA-NIO"><a href="#8-7-JAVA-NIO" class="headerlink" title="8.7. JAVA NIO"></a>8.7. JAVA NIO</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。传统IO 基于字节流和字 符流进行操作，而<strong>NIO基于 Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区 中，或者从缓冲区写入到通道中</strong>。Selector(选择区)用于监听多个通道的事件（比如：连接打开， 数据到达）。因此，单个线程可以监听多个数据通道。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_17.png" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;NIO和传统IO 之间第一个最大的区别是，<strong>IO是面向流的，NIO是面向缓冲区的</strong>。 </p><h4 id="8-7-1-NIO的缓冲区"><a href="#8-7-1-NIO的缓冲区" class="headerlink" title="8.7.1. NIO的缓冲区"></a>8.7.1. NIO的缓冲区</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何 地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓 存到一个缓冲区。NIO的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在 缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所 有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的 数据。 </p><h4 id="8-7-2-NIO的非阻塞"><a href="#8-7-2-NIO的非阻塞" class="headerlink" title="8.7.2. NIO的非阻塞"></a>8.7.2. NIO的非阻塞</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有 一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式， 使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可 用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以 继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它 完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上 执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_18.png" alt></p><h3 id="8-8-Channel"><a href="#8-8-Channel" class="headerlink" title="8.8. Channel"></a>8.8. Channel</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;首先说一下Channel，国内大多翻译成“通道”。Channel和IO 中的Stream(流)是差不多一个 等级的。<strong>只不过Stream是单向的</strong>，譬如：InputStream, OutputStream，而Channel是双向 的，既可以用来进行读操作，又可以用来进行写操作。 NIO中的Channel的主要实现有： </p><p>​    1.FileChannel </p><p>​    2.DatagramChannel </p><p>​    3.SocketChannel </p><p>​    4.ServerSocketChannel </p><p>​    这里看名字就可以猜出个所以然来：分别可以对应文件IO、UDP和TCP（Server和Client）。 下面演示的案例基本上就是围绕这4个类型的Channel进行陈述的。 </p><h3 id="8-9-Buffer"><a href="#8-9-Buffer" class="headerlink" title="8.9. Buffer"></a>8.9. Buffer</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Buffer，故名思意，<strong>缓冲区，实际上是一个容器，是一个连续数组</strong>。Channel提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer。</p><p><img src="/images/Java_heart_JVM/java_1_jvm_19.png" alt> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送 数据时，必须先将数据存入Buffer中，然后将Buffer中的内容写入通道。服务端这边接收数据必 须通过Channel将数据读入到Buffer中，然后再从Buffer中取出数据来处理。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在NIO中，Buffer是一个顶层父类，它是一个抽象类，常用的Buffer的子类有： ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、 ShortBuffer </p><h3 id="8-10-Selector"><a href="#8-10-Selector" class="headerlink" title="8.10. Selector"></a>8.10. Selector</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Selector类是NIO的核心类，<strong>Selector能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理</strong>。这样一来，只是用一个单线程就可 以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用 函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护 多个线程，并且避免了多线程之间的上下文切换导致的开销。 </p><h2 id="9-JVM-类加载机制"><a href="#9-JVM-类加载机制" class="headerlink" title="9. JVM 类加载机制"></a>9. JVM 类加载机制</h2><h3 id="9-1JVM-类加载"><a href="#9-1JVM-类加载" class="headerlink" title="9.1JVM 类加载"></a>9.1JVM 类加载</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这 五个过程。</p><p><img src="/images/Java_heart_JVM/java_1_jvm_20.png" alt></p><h4 id="9-1-1-加载"><a href="#9-1-1-加载" class="headerlink" title="9.1.1. 加载"></a>9.1.1. 加载</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;加载是类加载过程中的一个阶段，<strong>这个阶段会在内存中生成一个代表这个类java.lang.Class对象，作为方法区这个类的各种数据的入口</strong>。注意这里不一定非得要从一个Class文件获取，这里既 可以从ZIP包中读取（比如从jar包和war包中读取），也可以在运行时计算生成（动态代理）， 也可以由其它文件生成（比如将JSP文件转换成对应的Class类）。 </p><h4 id="9-1-2-验证"><a href="#9-1-2-验证" class="headerlink" title="9.1.2. 验证"></a>9.1.2. 验证</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这一阶段的主要目的是为了<strong>确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求</strong>，并 且不会危害虚拟机自身的安全。 </p><h4 id="9-1-3-准备"><a href="#9-1-3-准备" class="headerlink" title="9.1.3. 准备"></a>9.1.3. 准备</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即<strong>在方法区中分配这些变量所使用的内存空间</strong>。注意这里所说的初始值概念，比如一个类变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>实际上变量v在准备阶段过后的初始值为0而不是8080</strong>，将v赋值为8080的put static指令是程序被编译后，<strong>存放于类构造器<client>方法之中</client></strong>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;但是注意如果声明为： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;在编译阶段会为v生成ConstantValue属性，在<strong>准备阶段虚拟机会根据ConstantValue属性将v 赋值为8080。</strong> </p><h4 id="9-1-4-解析"><a href="#9-1-4-解析" class="headerlink" title="9.1.4. 解析"></a>9.1.4. 解析</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;解析阶段是指<strong>虚拟机将常量池中的符号引用替换为直接引用的过程</strong>。符号引用就是class文件中 的： </p><p>​    1.CONSTANT_Class_info </p><p>​    2.CONSTANT_Field_info </p><p>​    3.CONSTANT_Method_info </p><h4 id="9-1-5-符号引用"><a href="#9-1-5-符号引用" class="headerlink" title="9.1.5. 符号引用"></a>9.1.5. 符号引用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;符号引用与虚拟机实现的布局无关，<strong>引用的目标并不一定要已经加载到内存中。各种虚拟 机实现的内存布局可以各不相同</strong>，但是它们能接受的符号引用必须是一致的，因为符号引 用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。 </p><h4 id="9-1-6-直接引用"><a href="#9-1-6-直接引用" class="headerlink" title="9.1.6. 直接引用"></a>9.1.6. 直接引用</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;直接引用可以是<strong>指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄</strong>。如果有 了直接引用，那<strong>引用的目标必定已经在内存中存在</strong>。 </p><h4 id="9-1-7-初始化"><a href="#9-1-7-初始化" class="headerlink" title="9.1.7. 初始化"></a>9.1.7. 初始化</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载 器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。 </p><h4 id="9-1-8-类构造器client"><a href="#9-1-8-类构造器client" class="headerlink" title="9.1.8. 类构造器client"></a>9.1.8. 类构造器client</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>初始化阶段是执行类构造器client方法的过程</strong>。client方法是由编译器自动收集类中的类变 量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子client方法执行之前，父类 的client方法已经执行完毕，<strong>如果一个类中没有对静态变量赋值也没有静态语句块，那么编译 器可以不为这个类生成client()方法</strong>。 </p><p>注意以下几种情况不会执行类初始化： </p><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 </li><li>定义对象数组，不会触发该类的初始化。 </li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触 发定义常量所在的类。 </li><li>通过类名获取Class对象，不会触发类的初始化。 </li><li>通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初 始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li><li>通过ClassLoader默认的loadClass方法，也不会触发初始化动作。 </li></ol><h3 id="9-2-类加载器"><a href="#9-2-类加载器" class="headerlink" title="9.2. 类加载器"></a>9.2. 类加载器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提 供了3种类加载器： </p><h4 id="9-2-1-启动类加载器-Bootstrap-ClassLoader"><a href="#9-2-1-启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="9.2.1. 启动类加载器(Bootstrap ClassLoader)"></a>9.2.1. 启动类加载器(Bootstrap ClassLoader)</h4><p>​    1. 负责加载 <strong>JAVA_HOME\lib</strong> 目录中的，或通过-Xbootclasspath参数指定路径中的，且被 虚拟机认可（按文件名识别，如rt.jar）的类。 </p><h4 id="9-2-2-扩展类加载器-Extension-ClassLoader"><a href="#9-2-2-扩展类加载器-Extension-ClassLoader" class="headerlink" title="9.2.2. 扩展类加载器(Extension ClassLoader)"></a>9.2.2. 扩展类加载器(Extension ClassLoader)</h4><p>​    2. 负责加载 <strong>JAVA_HOME\lib\ext</strong> 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。 </p><h4 id="9-2-3-应用程序类加载器-Application-ClassLoader-："><a href="#9-2-3-应用程序类加载器-Application-ClassLoader-：" class="headerlink" title="9.2.3. 应用程序类加载器(Application ClassLoader)："></a>9.2.3. 应用程序类加载器(Application ClassLoader)：</h4><ol start="3"><li><p>负责<strong>加载用户路径（classpath）上的类库</strong>。 JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader 实现自定义的类加载器。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_21.png" alt></p></li></ol><h3 id="9-3-双亲委派"><a href="#9-3-双亲委派" class="headerlink" title="9.3. 双亲委派"></a>9.3. 双亲委派</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父 类去完成</strong>，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中， 只有当<strong>父类加载器反馈自己无法完成这个请求的时候</strong>（在它的加载路径下没有找到所需加载的 Class），<strong>子类加载器才会尝试自己去加载</strong>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载 器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就<strong>保证了使用不同的类加载 器最终得到的都是同样一个Object对象</strong>。<br><img src="/images/Java_heart_JVM/java_1_jvm_22.png" alt></p><h3 id="9-4-OSGI（动态模型系统）"><a href="#9-4-OSGI（动态模型系统）" class="headerlink" title="9.4. OSGI（动态模型系统）"></a>9.4. OSGI（动态模型系统）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;OSGi(Open Service Gateway Initiative)，是面向Java的动态模型系统，是Java动态化模块化系 统的一系列规范。 </p><h4 id="9-4-1-动态改变构造"><a href="#9-4-1-动态改变构造" class="headerlink" title="9.4.1. 动态改变构造"></a>9.4.1. 动态改变构造</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使 这些耦合度可管理，OSGi技术提供一种面向服务的架构，它能使这些组件动态地发现对方。 </p><h4 id="9-4-2-模块化编程与热插拔"><a href="#9-4-2-模块化编程与热插拔" class="headerlink" title="9.4.2. 模块化编程与热插拔"></a>9.4.2. 模块化编程与热插拔</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;OSGi旨在为实现Java程序的模块化编程提供基础条件，基于OSGi的程序很可能可以<strong>实现模块级的热插拔功能</strong>，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企 业级程序开发来说是非常具有诱惑力的特性。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时 也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大 功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。 </p><h2 id="10-最后"><a href="#10-最后" class="headerlink" title="10.最后"></a>10.最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;(1) 基本概念：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;JVM是可运行Java代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>查看ubuntu是32位还是64位</title>
    <link href="https://quietair.gitee.io/ubuntu-see-64or32bit/"/>
    <id>https://quietair.gitee.io/ubuntu-see-64or32bit/</id>
    <published>2019-10-17T07:56:33.000Z</published>
    <updated>2020-04-04T12:45:52.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看操作系统是32位的还是64位的"><a href="#1-查看操作系统是32位的还是64位的" class="headerlink" title="1.查看操作系统是32位的还是64位的"></a>1.查看操作系统是32位的还是64位的</h2><p>在控制台输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uname --m</span><br></pre></td></tr></table></figure><p><strong><em>回车后：</em></strong><br><strong><em>如果显示i686,则表示安装了32位操作系统</em></strong><br><strong><em>如果显示 x86_64，则表示安装了64位操作系统</em></strong></p><a id="more"></a><h2 id="2-如果想知道更多信息可以试试如下命令："><a href="#2-如果想知道更多信息可以试试如下命令：" class="headerlink" title="2.如果想知道更多信息可以试试如下命令："></a>2.如果想知道更多信息可以试试如下命令：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uname --s <span class="comment">#显示内核名字</span></span><br><span class="line">$ sudo uname --r <span class="comment">#显示内核版本</span></span><br><span class="line">$ sudo uname --n <span class="comment">#显示网络主机名</span></span><br><span class="line">$ sudo uname --p <span class="comment">#显示cpu</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-查看操作系统是32位的还是64位的&quot;&gt;&lt;a href=&quot;#1-查看操作系统是32位的还是64位的&quot; class=&quot;headerlink&quot; title=&quot;1.查看操作系统是32位的还是64位的&quot;&gt;&lt;/a&gt;1.查看操作系统是32位的还是64位的&lt;/h2&gt;&lt;p&gt;在控制台输入：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo uname --m&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;回车后：&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;如果显示i686,则表示安装了32位操作系统&lt;/em&gt;&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;&lt;em&gt;如果显示 x86_64，则表示安装了64位操作系统&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://quietair.gitee.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://quietair.gitee.io/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="https://quietair.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>jQuery.validator.addMethod自定义验证规则</title>
    <link href="https://quietair.gitee.io/jQuery-validator-addMethod/"/>
    <id>https://quietair.gitee.io/jQuery-validator-addMethod/</id>
    <published>2019-10-09T05:51:19.000Z</published>
    <updated>2020-04-05T14:07:26.009Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;jQuery.validate是一款非常不错的表单验证工具，简单易上手，而且能达到很好的体验效果</p><h2 id="1-用前必备"><a href="#1-用前必备" class="headerlink" title="1.用前必备"></a>1.用前必备</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;官方网站：<a href="http://bassistance.de/jquery-plugins/jquery-plugin-validation/" target="_blank" rel="noopener">http://bassistance.de/jquery-plugins/jquery-plugin-validation/</a>    （注意下载最新版）<br>&nbsp;&nbsp;&nbsp;&nbsp;需要JQuery版本：1.2.6+, 兼容 1.3.2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"../js/jquery.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"../js/jquery.validate.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-默认校验规则"><a href="#2-默认校验规则" class="headerlink" title="2.默认校验规则"></a>2.默认校验规则</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">required:<span class="literal">true</span> <span class="comment">#必输字段</span></span><br><span class="line">remote:<span class="string">"check.php"</span> <span class="comment">#使用ajax方法调用check.php验证输入值</span></span><br><span class="line">email:<span class="literal">true</span> <span class="comment">#必须输入正确格式的电子邮件</span></span><br><span class="line">url:<span class="literal">true</span> <span class="comment">#必须输入正确格式的网址</span></span><br><span class="line">date:<span class="literal">true</span> <span class="comment">#必须输入正确格式的日期</span></span><br><span class="line">dateISO:<span class="literal">true</span> <span class="comment">#必须输入正确格式的日期(ISO)，例如：2009-06-23，1998/01/22 只验证格式，不验证有效性</span></span><br><span class="line">number:<span class="literal">true</span> <span class="comment">#必须输入合法的数字(负数，小数)</span></span><br><span class="line">digits:<span class="literal">true</span> <span class="comment">#必须输入整数</span></span><br><span class="line">creditcard: <span class="comment">#必须输入合法的信用卡号</span></span><br><span class="line">equalTo:<span class="string">"#field"</span> <span class="comment">#输入值必须和#field相同</span></span><br><span class="line">accept: <span class="comment">#输入拥有合法后缀名的字符串（上传文件的后缀）</span></span><br><span class="line">maxlength:5 <span class="comment">#输入长度最多是5的字符串(汉字算一个字符)</span></span><br><span class="line">minlength:10 <span class="comment">#输入长度最小是10的字符串(汉字算一个字符)</span></span><br><span class="line">rangelength:[5,10] <span class="comment">#输入长度必须介于 5 和 10 之间的字符串")(汉字算一个字符)</span></span><br><span class="line">range:[5,10] <span class="comment">#输入值必须介于 5 和 10 之间</span></span><br><span class="line">max:5 <span class="comment">#输入值不能大于5</span></span><br><span class="line">min:10 <span class="comment">#输入值不能小于10</span></span><br></pre></td></tr></table></figure><h2 id="3-默认的提示"><a href="#3-默认的提示" class="headerlink" title="3.默认的提示"></a>3.默认的提示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">messages: &#123;</span><br><span class="line">required: <span class="string">"This field is required."</span>,</span><br><span class="line">remote: <span class="string">"Please fix this field."</span>,</span><br><span class="line">email: <span class="string">"Please enter a valid email address."</span>,</span><br><span class="line">url: <span class="string">"Please enter a valid URL."</span>,</span><br><span class="line">date: <span class="string">"Please enter a valid date."</span>,</span><br><span class="line">dateISO: <span class="string">"Please enter a valid date (ISO)."</span>,</span><br><span class="line">dateDE: <span class="string">"Bitte geben Sie ein g眉ltiges Datum ein."</span>,</span><br><span class="line">number: <span class="string">"Please enter a valid number."</span>,</span><br><span class="line">numberDE: <span class="string">"Bitte geben Sie eine Nummer ein."</span>,</span><br><span class="line">digits: <span class="string">"Please enter only digits"</span>,</span><br><span class="line">creditcard: <span class="string">"Please enter a valid credit card number."</span>,</span><br><span class="line">equalTo: <span class="string">"Please enter the same value again."</span>,</span><br><span class="line">accept: <span class="string">"Please enter a value with a valid extension."</span>,</span><br><span class="line">maxlength: $.validator.format(<span class="string">"Please enter no more than &#123;0&#125; characters."</span>),</span><br><span class="line">minlength: $.validator.format(<span class="string">"Please enter at least &#123;0&#125; characters."</span>),</span><br><span class="line">rangelength: $.validator.format(<span class="string">"Please enter a value between &#123;0&#125; and &#123;1&#125; characters long."</span>),</span><br><span class="line">range: $.validator.format(<span class="string">"Please enter a value between &#123;0&#125; and &#123;1&#125;."</span>),</span><br><span class="line">max: $.validator.format(<span class="string">"Please enter a value less than or equal to &#123;0&#125;."</span>),</span><br><span class="line">min: $.validator.format(<span class="string">"Please enter a value greater than or equal to &#123;0&#125;."</span>)</span><br><span class="line">&#125;,如需要修改，可在js代码中加入：jQuery.extend(jQuery.validator.messages, &#123;</span><br><span class="line">required: <span class="string">"必选字段"</span>,</span><br><span class="line">remote: <span class="string">"请修正该字段"</span>,</span><br><span class="line">email: <span class="string">"请输入正确格式的电子邮件"</span>,</span><br><span class="line">url: <span class="string">"请输入合法的网址"</span>,</span><br><span class="line">date: <span class="string">"请输入合法的日期"</span>,</span><br><span class="line">dateISO: <span class="string">"请输入合法的日期 (ISO)."</span>,</span><br><span class="line">number: <span class="string">"请输入合法的数字"</span>,</span><br><span class="line">digits: <span class="string">"只能输入整数"</span>,</span><br><span class="line">creditcard: <span class="string">"请输入合法的信用卡号"</span>,</span><br><span class="line">equalTo: <span class="string">"请再次输入相同的值"</span>,</span><br><span class="line">accept: <span class="string">"请输入拥有合法后缀名的字符串"</span>,</span><br><span class="line">maxlength: jQuery.validator.format(<span class="string">"请输入一个长度最多是 &#123;0&#125; 的字符串"</span>),</span><br><span class="line">minlength: jQuery.validator.format(<span class="string">"请输入一个长度最少是 &#123;0&#125; 的字符串"</span>),</span><br><span class="line">rangelength: jQuery.validator.format(<span class="string">"请输入一个长度介于 &#123;0&#125; 和 &#123;1&#125; 之间的字符串"</span>),</span><br><span class="line">range: jQuery.validator.format(<span class="string">"请输入一个介于 &#123;0&#125; 和 &#123;1&#125; 之间的值"</span>),</span><br><span class="line">max: jQuery.validator.format(<span class="string">"请输入一个最大为 &#123;0&#125; 的值"</span>),</span><br><span class="line">min: jQuery.validator.format(<span class="string">"请输入一个最小为 &#123;0&#125; 的值"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//推荐做法，将此文件放入messages_cn.js中，在页面中引入</span><br><span class="line">&lt;script src=<span class="string">"../js/messages_cn.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="4-使用方法"><a href="#4-使用方法" class="headerlink" title="4.使用方法"></a>4.使用方法</h2><p><strong>html:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//head里需要加入</span><br><span class="line"><span class="comment">#&lt;script src="../js/jquery.js" type="text/javascript"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">#&lt;script src="../js/jquery.validate.js" type="text/javascript"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">#&lt;script src="./js/messages_cn.js" type="text/javascript"&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">""</span> method=<span class="string">"post"</span> id=<span class="string">"registerForm"</span> onsubmit=<span class="string">"return toVaild()"</span>&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"userName"</span> class=<span class="string">"username"</span> placeholder=<span class="string">"您的用户名"</span> autocomplete=<span class="string">"off"</span>/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                        &lt;input <span class="built_in">type</span>=<span class="string">"password"</span> name=<span class="string">"userPw"</span> class=<span class="string">"password"</span> placeholder=<span class="string">"输入密码"</span> oncontextmenu=<span class="string">"return false"</span> onpaste=<span class="string">"return false"</span> /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                        &lt;input <span class="built_in">type</span>=<span class="string">"password"</span> name=<span class="string">"confirm_password"</span> class=<span class="string">"confirm_password"</span> placeholder=<span class="string">"再次输入密码"</span> oncontextmenu=<span class="string">"return false"</span> onpaste=<span class="string">"return false"</span> /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"userPhoneNum"</span> class=<span class="string">"phone_number"</span> placeholder=<span class="string">"输入手机号码"</span> autocomplete=<span class="string">"off"</span> id=<span class="string">"number"</span>/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                        &lt;input <span class="built_in">type</span>=<span class="string">"email"</span> name=<span class="string">"userMail"</span> class=<span class="string">"email"</span> placeholder=<span class="string">"输入邮箱地址"</span> oncontextmenu=<span class="string">"return false"</span> onpaste=<span class="string">"return false"</span> /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">&lt;button id=<span class="string">"submit"</span> <span class="built_in">type</span>=<span class="string">"submit"</span>&gt;注 册&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><strong>messages_cn.js:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//jquery.validate表单验证</span><br><span class="line">$(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">//注册表单验证</span><br><span class="line">        $(<span class="string">"#registerForm"</span>).validate(&#123;</span><br><span class="line">                rules:&#123;</span><br><span class="line">                        userName:&#123;</span><br><span class="line">                                required:<span class="literal">true</span>,//必填</span><br><span class="line">                                minlength:3, //最少3个字符</span><br><span class="line">                                maxlength:32,//最多20个字符</span><br><span class="line">                                uName:<span class="literal">true</span>,//自定义的规则</span><br><span class="line">                                /*remote:&#123;</span><br><span class="line">                                        url:<span class="string">"http://kouss.com/demo/Sharelink/remote.json"</span>,//用户名重复检查，别跨域调用</span><br><span class="line">                                        <span class="built_in">type</span>:<span class="string">"post"</span>,</span><br><span class="line">                                &#125;,*/</span><br><span class="line">                        &#125;,</span><br><span class="line">                        userPw:&#123;</span><br><span class="line">                                required:<span class="literal">true</span>,</span><br><span class="line">                                minlength:3,</span><br><span class="line">                                maxlength:32,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        userMail:&#123;</span><br><span class="line">                                required:<span class="literal">true</span>,</span><br><span class="line">                                email:<span class="literal">true</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        confirm_password:&#123;</span><br><span class="line">                                required:<span class="literal">true</span>,</span><br><span class="line">                                minlength:3,</span><br><span class="line">                                equalTo:<span class="string">'.password'</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        userPhoneNum:&#123;</span><br><span class="line">                                required:<span class="literal">true</span>,</span><br><span class="line">                                userPhoneNum:<span class="literal">true</span>,//自定义的规则</span><br><span class="line">                                digits:<span class="literal">true</span>,//整数</span><br><span class="line">                        &#125;</span><br><span class="line">&#125;,</span><br><span class="line">//错误信息提示</span><br><span class="line">                messages:&#123;</span><br><span class="line">                        userName:&#123;</span><br><span class="line">                                required:<span class="string">"必须填写用户名"</span>,</span><br><span class="line">                                minlength:<span class="string">"用户名至少为3个字符"</span>,</span><br><span class="line">                                maxlength:<span class="string">"用户名至多为32个字符"</span>,</span><br><span class="line">                                //remote: <span class="string">"用户名已存在"</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        userPw:&#123;</span><br><span class="line">                                required:<span class="string">"必须填写密码"</span>,</span><br><span class="line">                                minlength:<span class="string">"密码至少为3个字符"</span>,</span><br><span class="line">                                maxlength:<span class="string">"密码至多为32个字符"</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        userMail:&#123;</span><br><span class="line">                                required:<span class="string">"请输入邮箱地址"</span>,</span><br><span class="line">                                email: <span class="string">"请输入正确的email地址"</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        confirm_password:&#123;</span><br><span class="line">                                required: <span class="string">"请再次输入密码"</span>,</span><br><span class="line">                                minlength: <span class="string">"确认密码不能少于3个字符"</span>,</span><br><span class="line">                                equalTo: <span class="string">"两次输入密码不一致"</span>,//与另一个元素相同</span><br><span class="line">                        &#125;,</span><br><span class="line">                        userPhoneNum:&#123;</span><br><span class="line">                                required:<span class="string">"请输入手机号码"</span>,</span><br><span class="line">                                digits:<span class="string">"请输入正确的手机号码"</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">// 字母和数字的验证</span><br><span class="line">        jQuery.validator.addMethod(<span class="string">"uName"</span>, <span class="keyword">function</span>(value, element) &#123;</span><br><span class="line">                var uName = /^([a-zA-Z0-9]+)$/;</span><br><span class="line">                <span class="built_in">return</span> this.optional(element) || (uName.test(value));</span><br><span class="line">        &#125;, <span class="string">"用户名仅支持非空，数字和英文"</span>);</span><br><span class="line"></span><br><span class="line">        //添加自定义验证规则</span><br><span class="line">        jQuery.validator.addMethod(<span class="string">"userPhoneNum"</span>, <span class="keyword">function</span>(value, element) &#123;</span><br><span class="line">                var length = value.length;</span><br><span class="line">                var userPhoneNum = /^1[3456789]\d&#123;9&#125;$/</span><br><span class="line">                <span class="built_in">return</span> this.optional(element) || (length == 11 &amp;&amp; userPhoneNum.test(value));</span><br><span class="line">        &#125;, <span class="string">"手机号码格式错误"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>方法：$.validator.addMethod(name,function(value,element){  return true||false },message)；</strong></p><pre><code>参数：  第一个参数:用于type匹配的名称，自定义。  第二个参数:是一个function函数，决定了验证是否成功！里面是自定义验证。  第三个参数：当验证不成功时返回的提示错误信息。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;jQuery.validate是一款非常不错的表单验证工具，简单易上手，而且能达到很好的体验效果&lt;/p&gt;
&lt;h2 id=&quot;1-用前必备&quot;&gt;&lt;a href=&quot;#1-用前必备&quot; class=&quot;headerlink&quot; title=&quot;1.用前必备&quot;&gt;&lt;/a&gt;1.用前必备&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;官方网站：&lt;a href=&quot;http://bassistance.de/jquery-plugins/jquery-plugin-validation/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bassistance.de/jquery-plugins/jquery-plugin-validation/&lt;/a&gt;    （注意下载最新版）&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;需要JQuery版本：1.2.6+, 兼容 1.3.2&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&lt;span class=&quot;string&quot;&gt;&quot;../js/jquery.js&quot;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&lt;span class=&quot;string&quot;&gt;&quot;../js/jquery.validate.js&quot;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://quietair.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JQuery" scheme="https://quietair.gitee.io/tags/JQuery/"/>
    
      <category term="Html" scheme="https://quietair.gitee.io/tags/Html/"/>
    
      <category term="Validate" scheme="https://quietair.gitee.io/tags/Validate/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu配置Tomcat80端口</title>
    <link href="https://quietair.gitee.io/ubuntu-tomcat/"/>
    <id>https://quietair.gitee.io/ubuntu-tomcat/</id>
    <published>2019-09-30T03:01:10.000Z</published>
    <updated>2020-04-05T15:12:29.806Z</updated>
    
    <content type="html"><![CDATA[<p>本地环境：</p><ul><li>ubuntu 18.04 LTS</li><li>jdk 1.8.0_181</li><li>tomcat 9.0.26</li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp; 使用Ubuntu 18.04 环境部署 Java Web 应用，在配置 Tomcat时，发现8080端口没问题，改为80端口后就报错，然后自己网上找了些资料改去改来，不是[“http-nio-80”]，就APR，要么就拒绝连接。明天前面都用得好好的！后来又网上看了很多，才发现问题，然后就写这篇记忆下。</p><a id="more"></a><p>&nbsp;&nbsp;&nbsp;&nbsp;具体问题为在 Linux中对非root用户只能使用 1024 及以上的端口号，所以 80 端口对非 root 用户为禁用状态。第一种解决方法：使用 root 用户去配置并启动 Tomcat。这里讲的是第二种解决方法：使用 iptables 的转发功能，将 80 端口消息转发给 8080 端口。如果嫌麻烦，建议第一种。自己记住就行了。第二种教程如下：</p><h2 id="1-前期工作"><a href="#1-前期工作" class="headerlink" title="1.前期工作"></a>1.前期工作</h2><h3 id="1-1-系统是否安装防火墙："><a href="#1-1-系统是否安装防火墙：" class="headerlink" title="1.1.系统是否安装防火墙："></a>1.1.系统是否安装防火墙：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whereis iptables</span><br></pre></td></tr></table></figure><h3 id="1-2-安装则下面显示为："><a href="#1-2-安装则下面显示为：" class="headerlink" title="1.2.安装则下面显示为："></a>1.2.安装则下面显示为：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ iptables: </span><br><span class="line">$ /sbin/iptables /etc/iptables.rules /usr/share/iptables /usr/share/man/man8/iptables.8.gz</span><br></pre></td></tr></table></figure><h3 id="1-3-反之，安装防火墙："><a href="#1-3-反之，安装防火墙：" class="headerlink" title="1.3.反之，安装防火墙："></a>1.3.反之，安装防火墙：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install iptables</span><br></pre></td></tr></table></figure><h3 id="1-4-查看防火墙信息："><a href="#1-4-查看防火墙信息：" class="headerlink" title="1.4.查看防火墙信息："></a>1.4.查看防火墙信息：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -L -n</span><br></pre></td></tr></table></figure><h2 id="2-配置防火墙"><a href="#2-配置防火墙" class="headerlink" title="2.配置防火墙"></a>2.配置防火墙</h2><h3 id="2-1-创建-iptables-rules-文件："><a href="#2-1-创建-iptables-rules-文件：" class="headerlink" title="2.1.创建 iptables.rules 文件："></a>2.1.创建 iptables.rules 文件：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/iptables.rules</span><br></pre></td></tr></table></figure><h3 id="2-2-按-i-进入编辑模式，添加以下规则："><a href="#2-2-按-i-进入编辑模式，添加以下规则：" class="headerlink" title="2.2.按 i 进入编辑模式，添加以下规则："></a>2.2.按 i 进入编辑模式，添加以下规则：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">:syn-flood - [0:0]</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8443 -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 100/sec --<span class="built_in">limit</span>-burst 100 -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 1/s --<span class="built_in">limit</span>-burst 10 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j syn-flood</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A syn-flood -p tcp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 3/sec --<span class="built_in">limit</span>-burst 6 -j RETURN</span><br><span class="line">-A syn-flood -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">22   端口为 SSH 默认端口 </span><br><span class="line">80   端口为 HTTP 默认端口 </span><br><span class="line">443  端口为 HTTPS 默认端口 </span><br><span class="line">8080 端口为 Tomcat 默认的 HTTP 端口 </span><br><span class="line">8443 端口为 Tomcat 默认的 HTTPS 端口</span><br></pre></td></tr></table></figure><h3 id="2-3-使防火墙规则生效："><a href="#2-3-使防火墙规则生效：" class="headerlink" title="2.3.使防火墙规则生效："></a>2.3.使防火墙规则生效：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables-restore &lt; /etc/iptables.rules</span><br></pre></td></tr></table></figure><h3 id="2-4-配置防火墙规则开机启动："><a href="#2-4-配置防火墙规则开机启动：" class="headerlink" title="2.4.配置防火墙规则开机启动："></a>2.4.配置防火墙规则开机启动：</h3><p>创建 iptables 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/network/<span class="keyword">if</span>-pre-up.d/iptables</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ !/bin/bash</span><br><span class="line">$ iptables-restore &lt; /etc/iptables.rules</span><br></pre></td></tr></table></figure><h3 id="2-5-为-iptables-文件添加执行权限："><a href="#2-5-为-iptables-文件添加执行权限：" class="headerlink" title="2.5.为 iptables 文件添加执行权限："></a>2.5.为 iptables 文件添加执行权限：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x /etc/network/<span class="keyword">if</span>-pre-up.d/iptables</span><br></pre></td></tr></table></figure><h3 id="2-6-查看规则是否生效："><a href="#2-6-查看规则是否生效：" class="headerlink" title="2.6.查看规则是否生效："></a>2.6.查看规则是否生效：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -L -n</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>           destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0        0.0.0.0/0           </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0        0.0.0.0/0        state RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0        0.0.0.0/0        state NEW tcp dpt:22</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0        0.0.0.0/0        state NEW tcp dpt:80</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0        0.0.0.0/0        state NEW tcp dpt:443</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0        0.0.0.0/0        state NEW tcp dpt:8080</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0        0.0.0.0/0        state NEW tcp dpt:8443</span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0        0.0.0.0/0        <span class="built_in">limit</span>: avg 100/sec burst 100</span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0        0.0.0.0/0        <span class="built_in">limit</span>: avg 1/sec burst 10</span><br><span class="line">syn-flood  tcp  --  0.0.0.0/0        0.0.0.0/0        tcp flags:0x17/0x02</span><br><span class="line">REJECT     all  --  0.0.0.0/0        0.0.0.0/0        reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>           destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>           destination         </span><br><span class="line"></span><br><span class="line">Chain syn-flood (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>           destination         </span><br><span class="line">RETURN     tcp  --  0.0.0.0/0        0.0.0.0/0        <span class="built_in">limit</span>: avg 3/sec burst 6</span><br><span class="line">REJECT     all  --  0.0.0.0/0        0.0.0.0/0        reject-with icmp-port-unreachable</span><br></pre></td></tr></table></figure><h2 id="3-新增转发规则"><a href="#3-新增转发规则" class="headerlink" title="3.新增转发规则"></a>3.新增转发规则</h2><h3 id="3-1-将-80-端口转发至-8080-端口"><a href="#3-1-将-80-端口转发至-8080-端口" class="headerlink" title="3.1.将 80 端口转发至 8080 端口"></a>3.1.将 80 端口转发至 8080 端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080</span><br></pre></td></tr></table></figure><h3 id="3-2-查看-80-端口相关的转发规则"><a href="#3-2-查看-80-端口相关的转发规则" class="headerlink" title="3.2.查看 80 端口相关的转发规则"></a>3.2.查看 80 端口相关的转发规则</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -L -n | grep 80</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ REDIRECT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 redir ports 8080</span><br></pre></td></tr></table></figure><h3 id="3-3-配置-Tomcat-服务端口为-8080"><a href="#3-3-配置-Tomcat-服务端口为-8080" class="headerlink" title="3.3.配置 Tomcat 服务端口为 8080"></a>3.3.配置 Tomcat 服务端口为 8080</h3><p>找到 Tomcat 安装目录下的 ../conf/server.xml 配置文件并且打开编辑如下内容，改为 8080 端口即可。<br>&lt;Connector port=”8080” protocol=”HTTP/1.1”</p><h3 id="3-4-重启-Tomcat-服务，试一下应该就可以进行正常访问-80-端口了。"><a href="#3-4-重启-Tomcat-服务，试一下应该就可以进行正常访问-80-端口了。" class="headerlink" title="3.4.重启 Tomcat 服务，试一下应该就可以进行正常访问 80 端口了。"></a>3.4.重启 Tomcat 服务，试一下应该就可以进行正常访问 80 端口了。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service tomcat restart</span><br></pre></td></tr></table></figure><h2 id="4-删除转发规则"><a href="#4-删除转发规则" class="headerlink" title="4.删除转发规则"></a>4.删除转发规则</h2><h3 id="4-1-将转发规则以数字序号排列显示"><a href="#4-1-将转发规则以数字序号排列显示" class="headerlink" title="4.1.将转发规则以数字序号排列显示:"></a>4.1.将转发规则以数字序号排列显示:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -L -n --line-numbers</span><br></pre></td></tr></table></figure><ul><li>Chain PREROUTING (policy ACCEPT)</li><li>num target prot opt source destination</li><li>1 REDIRECT tcp – 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 redir ports 8080</li></ul><h3 id="4-2-删除-8080-端口对于的转发规则："><a href="#4-2-删除-8080-端口对于的转发规则：" class="headerlink" title="4.2.删除 8080 端口对于的转发规则："></a>4.2.删除 8080 端口对于的转发规则：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -D PREROUTING 1</span><br></pre></td></tr></table></figure><h2 id="5-相关问题"><a href="#5-相关问题" class="headerlink" title="5.相关问题"></a>5.相关问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;上述配置完成后，即可使用 IP 地址（或域名）+ 应用程序页面访问路径。如需直接使用 IP 地址（或域名）访问应用程序默认页面，应另外配置。另外，若参照上述配置时使用的是通过 域名 进行访问，则需要进行域名备案，同时需要指定访问的应用。当然可以暂且使用 域名:8080 进行访问，或是使用 https://域名 进行访问。</p><h2 id="6-文章参考"><a href="#6-文章参考" class="headerlink" title="6.文章参考"></a>6.文章参考</h2><p><a href="https://blog.csdn.net/xh_257/article/details/81982320" target="_blank" rel="noopener">Ubuntu如何配置Tomcat访问80端口</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ubuntu 18.04 LTS&lt;/li&gt;
&lt;li&gt;jdk 1.8.0_181&lt;/li&gt;
&lt;li&gt;tomcat 9.0.26&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; 使用Ubuntu 18.04 环境部署 Java Web 应用，在配置 Tomcat时，发现8080端口没问题，改为80端口后就报错，然后自己网上找了些资料改去改来，不是[“http-nio-80”]，就APR，要么就拒绝连接。明天前面都用得好好的！后来又网上看了很多，才发现问题，然后就写这篇记忆下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Linux" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Linux/"/>
    
    
      <category term="Tomcat" scheme="https://quietair.gitee.io/tags/Tomcat/"/>
    
      <category term="Ubuntu" scheme="https://quietair.gitee.io/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="https://quietair.gitee.io/tags/Linux/"/>
    
  </entry>
  
</feed>
