<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QuietAir</title>
  
  <subtitle>沉静的空气，环绕身边，让时间失衡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://quietair.gitee.io/"/>
  <updated>2020-06-07T04:48:38.806Z</updated>
  <id>https://quietair.gitee.io/</id>
  
  <author>
    <name>QuietAir</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java核心(十八)之数据结构</title>
    <link href="https://quietair.gitee.io/Java_heart_dataStructure/"/>
    <id>https://quietair.gitee.io/Java_heart_dataStructure/</id>
    <published>2020-06-06T07:50:43.000Z</published>
    <updated>2020-06-07T04:48:38.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-栈（stack）"><a href="#1-栈（stack）" class="headerlink" title="1. 栈（stack）"></a>1. 栈（stack）</h2><p>栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶（top）。它是后进先出（LIFO）的。对栈的基本操作只有 push（进栈）和 pop（出栈）两种，前者相当于插入，后者相当于删除最后的元素。</p><a id="more"></a><p><img src="/images/Java_heart_dataStructure/clip_image003.gif" alt="img"> </p><h2 id="2-队列（queue）"><a href="#2-队列（queue）" class="headerlink" title="2. 队列（queue）"></a>2. 队列（queue）</h2><p>队列是一种特殊的<a href="https://baike.baidu.com/item/线性表" target="_blank" rel="noopener">线性表</a>特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><p><img src="/images/Java_heart_dataStructure/clip_image005.jpg" alt="img"> </p><h2 id="3-链表（Link）"><a href="#3-链表（Link）" class="headerlink" title="3. 链表（Link）"></a>3. 链表（Link）</h2><p>链表是一种数据结构，和数组同级。比如，Java 中我们使用的 ArrayList，其实现原理是数组。而 LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。 </p><p><img src="/images/Java_heart_dataStructure/clip_image007.gif" alt="img"> </p><h2 id="4-散列表（Hash-Table）"><a href="#4-散列表（Hash-Table）" class="headerlink" title="4. 散列表（Hash Table）"></a>4. 散列表（Hash Table）</h2><p>散列表（Hash table，也叫哈希表）是一种查找算法，与链表、树等算法不同的是，散列表算法在查找时不需要进行一系列和关键字（关键字是数据元素中某个数据项的值，用以标识一个数据元素）的比较操作。 </p><p><strong>散列表算法希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素</strong>，因而必须要在数据元素的存储位置和它的关键字（可用key表示）之间建立一个确定的对应关系，使每个关键字和散列表中一个唯一的存储位置相对应。因此在查找时，只要根据这个对应关系找到给定关键字在散列表中的位置即可。这种对应关系被称为散列函数(可用 h(key)表示)。 </p><p>用的构造散列函数的方法有： </p><ol><li><p>直接定址法： 取关键字或关键字的某个线性函数值为散列地址。 即：h(key) = key  或 h(key) = a * key + b，其中 a 和 b 为常数。  </p></li><li><p>数字分析法 </p></li><li><p>平方取值法： 取关键字平方后的中间几位为散列地址。 </p></li><li><p>折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。</p></li><li><p>除留余数法：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址，即：h(key) = key MOD p  p ≤ m </p></li><li><p>随机数法：选择一个随机函数，取关键字的随机函数值为它的散列地址，即：h(key) = random(key) </p></li></ol><h2 id="5-排序二叉树"><a href="#5-排序二叉树" class="headerlink" title="5. 排序二叉树"></a>5. 排序二叉树</h2><p>首先如果普通二叉树每个节点满足：左子树所有节点值小于它的根节点值，且右子树所有节点值大于它的根节点值，则这样的二叉树就是排序二叉树。</p><h3 id="5-1-插入操作"><a href="#5-1-插入操作" class="headerlink" title="5.1. 插入操作"></a>5.1. 插入操作</h3><p>首先要从根节点开始往下找到自己要插入的位置（即新节点的父节点）；具体流程是：新节点与当前节点比较，如果相同则表示已经存在且不能再重复插入；如果小于当前节点，则到左子树中寻找，如果左子树为空则当前节点为要找的父节点，新节点插入到当前节点的左子树即可；如果大于当前节点，则到右子树中寻找，如果右子树为空则当前节点为要找的父节点，新节点插入到当前节点的右子树即可。</p><p><img src="/images/Java_heart_dataStructure/clip_image009.gif" alt="img"> </p><h3 id="5-2-删除操作"><a href="#5-2-删除操作" class="headerlink" title="5.2. 删除操作"></a>5.2. 删除操作</h3><p>删除操作主要分为三种情况，<strong>即要删除的节点无子节点，要删除的节点只有一个子节点，要删除的节点有两个子节点。</strong> </p><ol><li><p>对于要删除的节点无子节点可以直接删除，即让其父节点将该子节点置空即可。 </p></li><li><p>对于要删除的节点只有一个子节点，则替换要删除的节点为其子节点。 </p></li><li><p>对于要删除的节点有两个子节点，<strong>则首先找该节点的替换节点</strong>（即右子树中最小的节点），接着替换要删除的节点为替换节点，然后删除替换节点。</p></li></ol><p><img src="/images/Java_heart_dataStructure/clip_image011.jpg" alt="img"> </p><h3 id="5-3-查询操作"><a href="#5-3-查询操作" class="headerlink" title="5.3. 查询操作"></a>5.3. 查询操作</h3><p>查找操作的主要流程为：先和根节点比较，如果相同就返回，<strong>如果小于根节点则到左子树中递归查找，如果大于根节点则到右子树中递归查找</strong>。因此在排序二叉树中可以很容易获取最大（最右最深子节点）和最小（最左最深子节点）值。</p><h2 id="6-红黑树"><a href="#6-红黑树" class="headerlink" title="6. 红黑树"></a>6. 红黑树</h2><p>R-B Tree，全称是 Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 </p><h3 id="6-1-红黑树的特性"><a href="#6-1-红黑树的特性" class="headerlink" title="6.1. 红黑树的特性"></a>6.1. 红黑树的特性</h3><p>（1）每个节点或者是黑色，或者是红色。 </p><p>（2）根节点是黑色。 </p><p>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] </p><p>（4）如果一个节点是红色的，则它的子节点必须是黑色的。 </p><p>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p><h3 id="6-2-左旋"><a href="#6-2-左旋" class="headerlink" title="6.2. 左旋"></a>6.2. 左旋</h3><p>对 x 进行左旋，意味着，将“x 的右孩子”设为“x 的父亲节点”；即，将 x 变成了一个左节点( x 成了为 z 的左孩子)！。 因此，左旋中的“左”，意味着“被旋转的节点将变成一个左节点”。</p><p><img src="/images/Java_heart_dataStructure/clip_image013.jpg" alt="img"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LEFT-ROTATE(T, x)</span><br><span class="line">y ← right[x] // 前提：这里假设 x 的右孩子为 y。下面开始正式操作</span><br><span class="line">right[x] ← left[y] // 将 “y 的左孩子” 设为 “x 的右孩子”，即 将β设为 x 的右孩子</span><br><span class="line">p[left[y]] ← x // 将 “x” 设为 “y 的左孩子的父亲”，即 将β的父亲设为 x</span><br><span class="line">p[y] ← p[x] // 将 “x 的父亲” 设为 “y 的父亲”</span><br><span class="line">if p[x] = nil[T]</span><br><span class="line">then root[T] ← y // 情况 1：如果 “x 的父亲” 是空节点，则将 y 设为根节点</span><br><span class="line">else if x = left[p[x]]</span><br><span class="line"> then left[p[x]] ← y // 情况 2：如果 x 是它父节点的左孩子，则将 y 设为“x 的父节点</span><br><span class="line">的左孩子”</span><br><span class="line"> else right[p[x]] ← y // 情况 3：(x 是它父节点的右孩子) 将 y 设为“x 的父节点的右孩</span><br><span class="line">子”</span><br><span class="line">left[y] ← x // 将 “x” 设为 “y 的左孩子”</span><br><span class="line">p[x] ← y // 将 “x 的父节点” 设为 “y”</span><br></pre></td></tr></table></figure><p><img src="/images/Java_heart_dataStructure/clip_image015.gif" alt="img"> </p><h3 id="6-3-右旋"><a href="#6-3-右旋" class="headerlink" title="6.3. 右旋"></a>6.3. 右旋</h3><p>对 x 进行右旋，意味着，将“x 的左孩子”设为“x 的父亲节点”；即，将 x 变成了一个右节点( x 成了为 y 的右孩子)！ 因此，右旋中的“右”，意味着“被旋转的节点将变成一个右节点”。</p><p><img src="/images/Java_heart_dataStructure/clip_image017.gif" alt="img"> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RIGHT-ROTATE(T, y)</span><br><span class="line">x ← left[y] // 前提：这里假设 y 的左孩子为 x。下面开始正式操作</span><br><span class="line">left[y] ← right[x] // 将 “x 的右孩子” 设为 “y 的左孩子”，即 将β设为 y 的左孩子</span><br><span class="line">p[right[x]] ← y // 将 “y” 设为 “x 的右孩子的父亲”，即 将β的父亲设为 y</span><br><span class="line">p[x] ← p[y] // 将 “y 的父亲” 设为 “x 的父亲”</span><br><span class="line">if p[y] = nil[T]</span><br><span class="line">then root[T] ← x // 情况 1：如果 “y 的父亲” 是空节点，则将 x 设为根节点</span><br><span class="line">else if y = right[p[y]]</span><br><span class="line"> then right[p[y]] ← x // 情况 2：如果 y 是它父节点的右孩子，则将 x 设为“y 的父节点的左孩子”</span><br><span class="line"> else left[p[y]] ← x // 情况 3：(y 是它父节点的左孩子) 将 x 设为“y 的父节点的左孩子”</span><br><span class="line">right[x] ← y // 将 “y” 设为 “x 的右孩子”</span><br><span class="line">p[y] ← x // 将 “y 的父节点” 设为 “x”</span><br></pre></td></tr></table></figure><h3 id="6-4-添加"><a href="#6-4-添加" class="headerlink" title="6.4. 添加"></a>6.4. 添加</h3><p>第一步: 将红黑树当作一颗二叉查找树，将节点插入。 </p><p>第二步：将插入的节点着色为”红色”。  </p><p>根据被插入节点的父节点的情况，可以将”当节点 z 被着色为红色节点，并插入二叉树”划分为三种情况来处理。 </p><p>① 情况说明：被插入的节点是根节点。 处理方法：直接把此节点涂为黑色。 </p><p>② 情况说明：被插入的节点的父节点是黑色。 处理方法：什么也不需要做。节点被插入后，仍然是红黑树。 </p><p>③ 情况说明：被插入的节点的父节点是红色。这种情况下，被插入节点是一定存在非空祖父节点的；进一步的讲，被插入节点也一定存在叔叔节点(即使叔叔节点为空，我们也视之为存在，空节点本身就是黑色节点)。理解这点之后，我们依据”叔叔节点的情况”，将这种情况进一步划分为 3种情况(Case)。 </p><p><img src="/images/Java_heart_dataStructure/clip_image019.jpg" alt="img"> </p><p>第三步: 通过一系列的旋转或着色等操作，使之重新成为一颗红黑树。 </p><h3 id="6-5-删除"><a href="#6-5-删除" class="headerlink" title="6.5. 删除"></a>6.5. 删除</h3><p>第一步：将红黑树当作一颗二叉查找树，将节点删除。 </p><p>这和”删除常规二叉查找树中删除节点的方法是一样的”。分 3 种情况： </p><p>① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就 OK 了。 </p><p>② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。</p><p>③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 </p><p>第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。 因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。 </p><p>选择重着色 3 种情况。 </p><p>① 情况说明：x 是“红+黑”节点。 处理方法：直接把 x 设为黑色，结束。此时红黑树性质全部恢复。 </p><p>② 情况说明：x 是“黑+黑”节点，且 x 是根。 处理方法：什么都不做，结束。此时红黑树性质全部恢复。</p><p> ③ 情况说明：x 是“黑+黑”节点，且 x 不是根。 处理方法：这种情况又可以划分为 4 种子情况。这 4 种子情况如下表所示：</p><p> <img src="/images/Java_heart_dataStructure/clip_image021.gif" alt="img"> </p><p>参考：<a href="https://www.jianshu.com/p/038585421b73" target="_blank" rel="noopener">https://www.jianshu.com/p/038585421b73</a></p><p>代码实现：<a href="https://www.cnblogs.com/skywang12345/p/3624343.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3624343.html</a></p><h2 id="7-B-TREE"><a href="#7-B-TREE" class="headerlink" title="7. B-TREE"></a>7. B-TREE</h2><p>B-tree 又叫平衡多路查找树。一棵 m 阶的 B-tree (m 叉树)的特性如下（其中 ceil(x)是一个取上限的函数）： </p><ol><li><p>树中每个结点至多有 m 个孩子；</p></li><li><p>除根结点和叶子结点外，其它每个结点至少有有 ceil(m / 2)个孩子； </p></li><li><p>若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；</p></li><li><p>所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部结点或查询失败的结点，实际上这些结点不存在，指向这些结点的指针都为 null)； </p></li><li><p>每个非终端结点中包含有 n 个关键字信息： (n，P0，K1，P1，K2，P2，……，Kn，Pn)。 其中：</p></li></ol><ul><li><p>Ki (i=1…n)为关键字，且关键字按顺序排序 K(i-1)&lt; Ki。 </p></li><li><p>Pi 为指向子树根的接点，且指针 P(i-1)指向子树种所有结点的关键字均小于 Ki，但都大于 K(i-1)。 </p></li><li><p>关键字的个数 n 必须满足： ceil(m / 2)-1 &lt;= n &lt;= m-1。 </p></li></ul><p><img src="/images/Java_heart_dataStructure/clip_image023.gif" alt="img"> </p><p>一棵 m 阶的 B+tree 和 m 阶的 B-tree 的差异在于： </p><ol><li><p>有 n 棵子树的结点中含有 n 个关键字； (B-tree 是 n 棵子树有 n-1 个关键字) </p></li><li><p>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (B-tree 的叶子节点并没有包括全部需要查找的信息) </p></li><li><p>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。(B-tree 的非终节点也包含需要查找的有效信息) </p></li></ol><p><img src="/images/Java_heart_dataStructure/clip_image025.gif" alt="img"> </p><p>参考：<a href="https://www.jianshu.com/p/1ed61b4cca12" target="_blank" rel="noopener">https://www.jianshu.com/p/1ed61b4cca12</a></p><h2 id="8-位图"><a href="#8-位图" class="headerlink" title="8. 位图"></a>8. 位图</h2><p>位图的原理就是用一个 bit 来标识一个数字是否存在，采用一个 bit 来存储一个数据，所以这样可以大大的节省空间。 bitmap 是很常用的数据结构，比如用于 Bloom Filter 中；用于无重复整数的排序等等。bitmap 通常基于数组来实现，数组中每个元素可以看成是一系列二进制数，所有元素组成更大的二进制集合。</p><p>参考：<a href="https://www.cnblogs.com/polly333/p/4760275.html" target="_blank" rel="noopener">https://www.cnblogs.com/polly333/p/4760275.html</a></p><h2 id="9-最后"><a href="#9-最后" class="headerlink" title="9. 最后"></a>9. 最后</h2><p>java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-栈（stack）&quot;&gt;&lt;a href=&quot;#1-栈（stack）&quot; class=&quot;headerlink&quot; title=&quot;1. 栈（stack）&quot;&gt;&lt;/a&gt;1. 栈（stack）&lt;/h2&gt;&lt;p&gt;栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶（top）。它是后进先出（LIFO）的。对栈的基本操作只有 push（进栈）和 pop（出栈）两种，前者相当于插入，后者相当于删除最后的元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(十七)之Java算法</title>
    <link href="https://quietair.gitee.io/Java_heart_JavaAlgorithm/"/>
    <id>https://quietair.gitee.io/Java_heart_JavaAlgorithm/</id>
    <published>2020-05-31T05:12:08.000Z</published>
    <updated>2020-05-31T08:19:27.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。</p><a id="more"></a> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">biSearch</span><span class="params">(<span class="keyword">int</span> []array,<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lo=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> hi=array.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid;</span><br><span class="line"><span class="keyword">while</span>(lo&lt;=hi)&#123;</span><br><span class="line">mid=(lo+hi)/<span class="number">2</span>;<span class="comment">//中间位置</span></span><br><span class="line"><span class="keyword">if</span>(array[mid]==a)&#123;</span><br><span class="line"><span class="keyword">return</span> mid+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;a)&#123; <span class="comment">//向右查找</span></span><br><span class="line">lo=mid+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">//向左查找</span></span><br><span class="line">hi=mid-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-冒泡排序算法"><a href="#2-冒泡排序算法" class="headerlink" title="2. 冒泡排序算法"></a>2. 冒泡排序算法</h2><p>（1）比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。</p><p>（2）这样对数组的第 0 个数据到 N-1 个数据进行一次遍历后，最大的一个数据就“沉”到数组第 N-1 个位置。 </p><p>（3）N=N-1，如果 N 不为 0 就重复前面二步，否则排序完成。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span> [] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i, j;</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;<span class="comment">//表示 n 次排序过程。</span></span><br><span class="line"> <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;n-i; j++)&#123;</span><br><span class="line"> <span class="keyword">if</span>(a[j-<span class="number">1</span>] &gt; a[j])&#123;<span class="comment">//前面的数字大于后面的数字就交换</span></span><br><span class="line"> <span class="comment">//交换 a[j-1]和 a[j]</span></span><br><span class="line"> <span class="keyword">int</span> temp;</span><br><span class="line"> temp = a[j-<span class="number">1</span>];</span><br><span class="line"> a[j-<span class="number">1</span>] = a[j];</span><br><span class="line"> a[j]=temp;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-插入排序算法"><a href="#3-插入排序算法" class="headerlink" title="3. 插入排序算法"></a>3. 插入排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着<u>，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的</u>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函 数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是(n2)。</p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image005.gif" alt="img"> </p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i&lt;arr.length;i++)&#123;</span><br><span class="line"> <span class="comment">//插入的数</span></span><br><span class="line"> <span class="keyword">int</span> insertVal = arr[i];</span><br><span class="line"> <span class="comment">//被插入的位置(准备和前一个数比较)</span></span><br><span class="line"> <span class="keyword">int</span> index = i-<span class="number">1</span>;</span><br><span class="line"> <span class="comment">//如果插入的数比被插入的数小</span></span><br><span class="line"> <span class="keyword">while</span>(index&gt;=<span class="number">0</span>&amp;&amp;insertVal&lt;arr[index])&#123;</span><br><span class="line"> <span class="comment">//将把 arr[index] 向后移动</span></span><br><span class="line"> arr[index+<span class="number">1</span>]=arr[index];</span><br><span class="line"> <span class="comment">//让 index 向前移动</span></span><br><span class="line"> index--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//把插入的数放入合适位置</span></span><br><span class="line"> arr[index+<span class="number">1</span>]=insertVal;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-快速排序算法"><a href="#4-快速排序算法" class="headerlink" title="4. 快速排序算法"></a>4. 快速排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;快速排序的原理：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;一次循环：<strong>从后往前比较</strong>，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。<strong>找到这个值之后，又从前往后开始比较</strong>，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到<strong>从前往后的比较索引&gt;从后往前比较的索引</strong>，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> start = low;</span><br><span class="line"> <span class="keyword">int</span> end = high;</span><br><span class="line"> <span class="keyword">int</span> key = a[low];</span><br><span class="line"> <span class="keyword">while</span>(end&gt;start)&#123;</span><br><span class="line"> <span class="comment">//从后往前比较</span></span><br><span class="line"> <span class="keyword">while</span>(end&gt;start&amp;&amp;a[end]&gt;=key)</span><br><span class="line"><span class="comment">//如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较</span></span><br><span class="line"> end--;</span><br><span class="line"> <span class="keyword">if</span>(a[end]&lt;=key)&#123;</span><br><span class="line"> <span class="keyword">int</span> temp = a[end];</span><br><span class="line"> a[end] = a[start];</span><br><span class="line"> a[start] = temp;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//从前往后比较</span></span><br><span class="line"> <span class="keyword">while</span>(end&gt;start&amp;&amp;a[start]&lt;=key)</span><br><span class="line"><span class="comment">//如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置</span></span><br><span class="line"> start++;</span><br><span class="line"> <span class="keyword">if</span>(a[start]&gt;=key)&#123;</span><br><span class="line"> <span class="keyword">int</span> temp = a[start];</span><br><span class="line"> a[start] = a[end];</span><br><span class="line"> a[end] = temp;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的</span></span><br><span class="line"><span class="comment">//值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//递归</span></span><br><span class="line"> <span class="keyword">if</span>(start&gt;low) sort(a,low,start-<span class="number">1</span>);<span class="comment">//左边序列。第一个索引位置到关键值索引-1</span></span><br><span class="line"> <span class="keyword">if</span>(end&lt;high) sort(a,end+<span class="number">1</span>,high);<span class="comment">//右边序列。从关键值索引+1 到最后一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Java_heart_JavaAlgorithm/clip_image007.gif" alt="img"> </p><h2 id="6-希尔排序算法"><a href="#6-希尔排序算法" class="headerlink" title="6. 希尔排序算法"></a>6. 希尔排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 </p><ol><li><p>操作方法： 选择一个增量序列 t1，t2，…，tk，其中 ti&gt;tj，tk=1； </p></li><li><p>按增量序列个数 k，对序列进行 k 趟排序； </p></li><li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p></li></ol><p><img src="/images/Java_heart_JavaAlgorithm/clip_image009.gif" alt="img"> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> dk = a.length/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>( dk &gt;= <span class="number">1</span> )&#123;</span><br><span class="line"> ShellInsertSort(a, dk);</span><br><span class="line"> dk = dk/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ShellInsertSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> dk)</span> </span>&#123;</span><br><span class="line"><span class="comment">//类似插入排序，只是插入排序增量是 1，这里增量是 dk,把 1 换成 dk 就可以了</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=dk;i&lt;a.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&lt;a[i-dk])&#123;</span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">int</span> x=a[i];<span class="comment">//x 为待插入元素</span></span><br><span class="line">a[i]=a[i-dk];</span><br><span class="line"><span class="keyword">for</span>(j=i-dk; j&gt;=<span class="number">0</span> &amp;&amp; x&lt;a[j];j=j-dk)&#123;</span><br><span class="line"><span class="comment">//通过循环，逐个后移一位找到要插入的位置。</span></span><br><span class="line">a[j+dk]=a[j];</span><br><span class="line">&#125;</span><br><span class="line">a[j+dk]=x;<span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-归并排序算法"><a href="#7-归并排序算法" class="headerlink" title="7. 归并排序算法"></a>7. 归并排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。</p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image011.gif" alt="img"> </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSortTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span>[] data = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span> &#125;;</span><br><span class="line"> print(data);</span><br><span class="line"> mergeSort(data);</span><br><span class="line"> System.out.println(<span class="string">"排序后的数组："</span>);</span><br><span class="line"> print(data);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"> sort(data, <span class="number">0</span>, data.length - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> <span class="comment">// 找出中间索引</span></span><br><span class="line"> <span class="keyword">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line"> <span class="comment">// 对左边数组进行递归</span></span><br><span class="line"> sort(data, left, center);</span><br><span class="line"> <span class="comment">// 对右边数组进行递归</span></span><br><span class="line"> sort(data, center + <span class="number">1</span>, right);</span><br><span class="line"> <span class="comment">// 合并</span></span><br><span class="line"> merge(data, left, center, right);</span><br><span class="line"> print(data);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将两个数组进行归并，归并前面 2 个数组已有序，归并后依然有序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">     * 数组对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * 左数组的第一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> center</span></span><br><span class="line"><span class="comment">     * 左数组的最后一个元素的索引，center+1 是右数组第一个元素的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * 右数组最后一个元素的索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> left, <span class="keyword">int</span> center, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 临时数组</span></span><br><span class="line"> <span class="keyword">int</span>[] tmpArr = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line"> <span class="comment">// 右数组第一个元素索引</span></span><br><span class="line"> <span class="keyword">int</span> mid = center + <span class="number">1</span>;</span><br><span class="line"> <span class="comment">// third 记录临时数组的索引</span></span><br><span class="line"> <span class="keyword">int</span> third = left;</span><br><span class="line"> <span class="comment">// 缓存左数组第一个元素的索引</span></span><br><span class="line"> <span class="keyword">int</span> tmp = left;</span><br><span class="line"> <span class="keyword">while</span> (left &lt;= center &amp;&amp; mid &lt;= right) &#123;</span><br><span class="line"> <span class="comment">// 从两个数组中取出最小的放入临时数组</span></span><br><span class="line"> <span class="keyword">if</span> (data[left] &lt;= data[mid]) &#123;</span><br><span class="line"> tmpArr[third++] = data[left++];</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> tmpArr[third++] = data[mid++];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; </span><br><span class="line"> <span class="comment">// 剩余部分依次放入临时数组（实际上两个 while 只会执行其中一个）</span></span><br><span class="line"> <span class="keyword">while</span> (mid &lt;= right) &#123;</span><br><span class="line"> tmpArr[third++] = data[mid++]; </span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">while</span> (left &lt;= center) &#123;</span><br><span class="line"> tmpArr[third++] = data[left++];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 将临时数组中的内容拷贝回原数组中</span></span><br><span class="line"> <span class="comment">// （原 left-right 范围的内容被复制回原数组）</span></span><br><span class="line">    <span class="keyword">while</span> (tmp &lt;= right) &#123;</span><br><span class="line"> data[tmp] = tmpArr[tmp++];</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            System.out.print(data[i] + <span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> System.out.println();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="8-桶排序算法"><a href="#8-桶排序算法" class="headerlink" title="8. 桶排序算法"></a>8. 桶排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;桶排序的基本思想是： 把数组 arr 划分为 n 个大小相同子区间（桶），每个子区间各自排序，最后合并 。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。</p><p>1.找出待排序数组中的最大值 max、最小值 min </p><p>2.我们使用 动态数组 ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为(maxmin)/arr.length+1</p><p>3.遍历数组 arr，计算每个元素 arr[i] 放的桶 </p><p>4.每个桶各自排序 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">max = Math.max(max, arr[i]);</span><br><span class="line">min = Math.min(min, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建桶</span></span><br><span class="line"><span class="keyword">int</span> bucketNum = (max - min) / arr.length + <span class="number">1</span>;</span><br><span class="line">ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> ArrayList&lt;&gt;(bucketNum);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++)&#123;</span><br><span class="line">bucketArr.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将每个元素放入桶</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> num = (arr[i] - min) / (arr.length);</span><br><span class="line">bucketArr.get(num).add(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对每个桶进行排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bucketArr.size(); i++)&#123;</span><br><span class="line">Collections.sort(bucketArr.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-基数排序算法"><a href="#9-基数排序算法" class="headerlink" title="9. 基数排序算法"></a>9. 基数排序算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">radixSort</span> </span>&#123;</span><br><span class="line">inta[]=&#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">12</span>,<span class="number">64</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">62</span>,<span class="number">99</span>,<span class="number">98</span>,<span class="number">54</span>,<span class="number">101</span>,<span class="number">56</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">15</span>,<span class="number">35</span>,<span class="number">25</span>,<span class="number">53</span>,<span class="number">51</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">radixSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">sort(a);</span><br><span class="line"><span class="keyword">for</span>(inti=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line"><span class="comment">//首先确定排序的趟数;</span></span><br><span class="line"><span class="keyword">int</span> max=array[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(inti=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[i]&gt;max)&#123;</span><br><span class="line">max=array[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> time=<span class="number">0</span>;</span><br><span class="line"><span class="comment">//判断位数;</span></span><br><span class="line"><span class="keyword">while</span>(max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">max/=<span class="number">10</span>;</span><br><span class="line">time++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立 10 个队列;</span></span><br><span class="line">List&lt;ArrayList&gt; queue=newArrayList&lt;ArrayList&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">ArrayList&lt;Integer&gt;queue1=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">queue.add(queue1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进行 time 次分配和收集;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;time;i++)&#123;</span><br><span class="line"><span class="comment">//分配数组元素;</span></span><br><span class="line"><span class="keyword">for</span>(intj=<span class="number">0</span>;j&lt;array.length;j++)&#123;</span><br><span class="line"><span class="comment">//得到数字的第 time+1 位数;</span></span><br><span class="line"><span class="keyword">int</span> x=array[j]%(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,i+<span class="number">1</span>)/(<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, i);</span><br><span class="line">ArrayList&lt;Integer&gt;queue2=queue.get(x);</span><br><span class="line">queue2.add(array[j]);</span><br><span class="line">queue.set(x, queue2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//元素计数器;</span></span><br><span class="line"><span class="comment">//收集队列元素;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">10</span>;k++)&#123;</span><br><span class="line"><span class="keyword">while</span>(queue.get(k).size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">ArrayList&lt;Integer&gt;queue3=queue.get(k);</span><br><span class="line">array[count]=queue3.get(<span class="number">0</span>);</span><br><span class="line">queue3.remove(<span class="number">0</span>);</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-剪枝算法"><a href="#10-剪枝算法" class="headerlink" title="10. 剪枝算法"></a>10. 剪枝算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在搜索算法中优化中，剪枝，就是通过某种判断，避免一些不必要的遍历过程，形象的说，就是剪去了搜索树中的某些“枝条”，故称剪枝。应用剪枝优化的核心问题是设计剪枝判断方法，即确定哪些枝条应当舍弃，哪些枝条应当保留的方法。</p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image013.jpg" alt="img"> </p><h2 id="11-回溯算法"><a href="#11-回溯算法" class="headerlink" title="11. 回溯算法"></a>11. 回溯算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。 </p><h2 id="12-最短路径算法"><a href="#12-最短路径算法" class="headerlink" title="12. 最短路径算法"></a>12. 最短路径算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;从某顶点出发，沿图的边到达另一顶点所经过的路径中，各边上权值之和最小的一条路径叫做最短路径。解决最短路的问题有以下算法，Dijkstra 算法，Bellman-Ford 算法，Floyd 算法和 SPFA 算法等。 </p><h2 id="13-最大子数组算法"><a href="#13-最大子数组算法" class="headerlink" title="13. 最大子数组算法"></a>13. 最大子数组算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindMaxSubDoubleArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> MIN_VALUE = -<span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span>[] work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">double</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generate_work</span><span class="params">(<span class="keyword">double</span>[] a)</span></span>&#123;</span><br><span class="line">work = <span class="keyword">new</span> <span class="keyword">double</span>[a.length - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)&#123;</span><br><span class="line">work[i - <span class="number">1</span>] = a[i] - a[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(Arrays.toString(work));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">find</span><span class="params">(<span class="keyword">double</span>[] a)</span></span>&#123;</span><br><span class="line">generate_work(a);</span><br><span class="line">Result res = do_rec_find(<span class="number">0</span>, work.length - <span class="number">1</span>);</span><br><span class="line">res.end++;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Result <span class="title">do_rec_find</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start &lt; end)&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">Result rl = do_rec_find(start, mid);</span><br><span class="line">Result rh = do_rec_find(mid + <span class="number">1</span>, end);</span><br><span class="line">Result rc = do_cross_find(start, mid, end);</span><br><span class="line"><span class="keyword">if</span>(rl.max &gt;= rh.max &amp;&amp; rl.max &gt;= rc.max)&#123;</span><br><span class="line"><span class="keyword">return</span> rl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rh.max &gt;= rl.max &amp;&amp; rh.max &gt;= rc.max)&#123;</span><br><span class="line"><span class="keyword">return</span> rh;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rc.max &gt;= rl.max &amp;&amp; rc.max &gt;= rh.max)&#123;</span><br><span class="line"><span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Result res = <span class="keyword">new</span> Result();</span><br><span class="line">res.start = start;</span><br><span class="line">res.end = start;</span><br><span class="line">res.max = work[start];</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Result <span class="title">do_cross_find</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">double</span> add = <span class="number">0</span>;</span><br><span class="line">Result res = <span class="keyword">new</span> Result();</span><br><span class="line"><span class="keyword">double</span> maxl = MIN_VALUE;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &gt;= start; i--)&#123;</span><br><span class="line">add += work[i];</span><br><span class="line"><span class="keyword">if</span>(add &gt; maxl)&#123;</span><br><span class="line">res.start = i;</span><br><span class="line">maxl = add;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> maxh = MIN_VALUE;</span><br><span class="line">add = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= end; i++)&#123;</span><br><span class="line">add += work[i];</span><br><span class="line"><span class="keyword">if</span>(add &gt; maxh)&#123;</span><br><span class="line">res.end = i;</span><br><span class="line">maxh = add;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res.max = maxl + maxh;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">double</span>[] a = &#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">12</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">11</span>,<span class="number">9</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">//double[] a = &#123;9,10,8,12,10,6,12,11,9,1&#125;;</span></span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line">Result res = find(a);</span><br><span class="line">System.out.println(res.start + <span class="string">" "</span> + res.end + <span class="string">" "</span> + res.max);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-最长公共子序算法"><a href="#14-最长公共子序算法" class="headerlink" title="14. 最长公共子序算法"></a>14. 最长公共子序算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getLCSstring</span><span class="params">(<span class="keyword">char</span>[] str1, <span class="keyword">char</span>[] str2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i, j;</span><br><span class="line">       <span class="keyword">int</span> len1, len2;</span><br><span class="line">       len1 = str1.length;</span><br><span class="line">       len2 = str2.length;</span><br><span class="line">       <span class="keyword">int</span> maxLen = len1 &gt; len2 ? len1 : len2;</span><br><span class="line">       <span class="keyword">int</span>[] max = <span class="keyword">new</span> <span class="keyword">int</span>[maxLen];</span><br><span class="line">       <span class="keyword">int</span>[] maxIndex = <span class="keyword">new</span> <span class="keyword">int</span>[maxLen];</span><br><span class="line">       <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[maxLen];</span><br><span class="line">       List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">          <span class="comment">//生成矩阵</span></span><br><span class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len2; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (j = len1 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">               <span class="keyword">if</span> (str2[i] == str1[j]) &#123;</span><br><span class="line">                   <span class="keyword">if</span> ((i == <span class="number">0</span>) || (j == <span class="number">0</span>))</span><br><span class="line">                       c[j] = <span class="number">1</span>;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                       c[j] = c[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   c[j] = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line"> </span><br><span class="line">               <span class="keyword">if</span> (c[j] &gt; max[<span class="number">0</span>]) &#123;   <span class="comment">//如果是大于那暂时只有一个是最长的,而且要把后面的清0;</span></span><br><span class="line">                   max[<span class="number">0</span>] = c[j];</span><br><span class="line">                   maxIndex[<span class="number">0</span>] = j;</span><br><span class="line"> </span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; maxLen; k++) &#123;</span><br><span class="line">                       max[k] = <span class="number">0</span>;</span><br><span class="line">                       maxIndex[k] = <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c[j] == max[<span class="number">0</span>]) &#123;   <span class="comment">//有多个是相同长度的子串</span></span><br><span class="line">                   <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; maxLen; k++) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (max[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                           max[k] = c[j];</span><br><span class="line">                           maxIndex[k] = j;</span><br><span class="line">                           <span class="keyword">break</span>;  <span class="comment">//在后面加一个就要退出循环了</span></span><br><span class="line">                       &#125;</span><br><span class="line"> </span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; maxLen; j++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (max[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> </span><br><span class="line">               StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">               <span class="keyword">for</span> (i = maxIndex[j] - max[j] + <span class="number">1</span>; i &lt;= maxIndex[j]; i++) &#123;</span><br><span class="line">                   sb.append(str1[i]);</span><br><span class="line">               &#125;</span><br><span class="line">               String lcs = sb.toString();</span><br><span class="line">               list.add(lcs);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">       String str1 = <span class="keyword">new</span> String(<span class="string">"adbba12345"</span>);</span><br><span class="line">       String str2 = <span class="keyword">new</span> String(<span class="string">"adbbf1234sa"</span>);</span><br><span class="line">       List&lt;String&gt; list = getLCSstring(str1.toCharArray(), str2.toCharArray());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"个公共子串:"</span> + list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">       str1 = <span class="keyword">new</span> String(<span class="string">"adbab1234"</span>);</span><br><span class="line">       str2 = <span class="keyword">new</span> String(<span class="string">"adbbf123s4a"</span>);</span><br><span class="line">       list = getLCSstring(str1.toCharArray(), str2.toCharArray());</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"第"</span> + (i + <span class="number">1</span>) + <span class="string">"个公共子串:"</span> + list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line"> </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="15-最小生成树算法"><a href="#15-最小生成树算法" class="headerlink" title="15. 最小生成树算法"></a>15. 最小生成树算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;现在假设有一个很实际的问题：我们要在 n 个城市中建立一个通信网络，则连通这 n 个城市需要布置 n-1 一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？ </p><p>&nbsp;&nbsp;&nbsp;&nbsp;于是我们就可以引入连通图来解决我们遇到的问题，n 个城市就是图上的 n 个顶点，然后，边表示两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有n个顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：MST 性质（假设 N=(V,{E})是一个连通网，U 是顶点集 V 的一个非空子集，如果（u，v）是一条具有最小权值的边，其中 u 属于U，v 属于V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使用 MST 性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。 </p><p><img src="/images/Java_heart_JavaAlgorithm/clip_image015.gif" alt="img"> </p><h2 id="16-最后"><a href="#16-最后" class="headerlink" title="16. 最后"></a>16. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-二分查找&quot;&gt;&lt;a href=&quot;#1-二分查找&quot; class=&quot;headerlink&quot; title=&quot;1. 二分查找&quot;&gt;&lt;/a&gt;1. 二分查找&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(十六)之一致性算法</title>
    <link href="https://quietair.gitee.io/Java_heart_Algorithm/"/>
    <id>https://quietair.gitee.io/Java_heart_Algorithm/</id>
    <published>2020-05-24T04:43:31.000Z</published>
    <updated>2020-05-25T05:58:06.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Paxos"><a href="#1-Paxos" class="headerlink" title="1. Paxos"></a>1. Paxos</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。zookeeper 使用的 zab 算法是该算法的一个实现。 在 Paxos 算法中，有三种角色：Proposer，Acceptor，Learners </p><a id="more"></a><p><strong>Paxos</strong> 三种角色：<strong>Proposer</strong>，<strong>Acceptor</strong>，<strong>Learners</strong> </p><p><strong>Proposer</strong>： </p><p>只要 Proposer 发的提案被半数以上 Acceptor 接受，Proposer 就认为该提案里的 value 被选定了。 </p><p><strong>Acceptor</strong>： </p><p>只要 Acceptor 接受了某个提案，Acceptor 就认为该提案里的 value 被选定了。 </p><p><strong>Learner</strong>： </p><p>Acceptor 告诉 Learner 哪个 value 被选定，Learner 就认为那个 value 被选定。 </p><p><strong>Paxos</strong> 算法分为两个阶段。具体如下： </p><p><u>阶段一</u>（准<strong>leader</strong>确定 ）： </p><p>(a) Proposer选择一个提案编号N，然后向半数以上的Acceptor发送编号为N的Prepare请求。 </p><p>(b) 如果一个 Acceptor 收到一个编号为 N 的 Prepare 请求，且 N 大于该 Acceptor 已经响应过的所有 Prepare 请求的编号，那么它就会将它已经接受过的编号最大的提案（如果有的话）作为响应反馈给 Proposer，同时该 Acceptor 承诺不再接受任何编号小于 N 的提案。 </p><p><u>阶段二</u>（<strong>leader</strong>确认）： </p><p>(a) 如果 Proposer 收到半数以上 Acceptor 对其发出的编号为 N 的 Prepare 请求的响应，那么它就会发送一个针对[N,V]提案的 Accept 请求给半数以上的 Acceptor。注意：V 就是收到的响应中编号最大的提案的 value，如果响应中不包含任何提案，那么 V 就由 Proposer 自己决定。 </p><p>(b) 如果 Acceptor 收到一个针对编号为 N 的提案的 Accept 请求，只要该 Acceptor 没有对编号大于 N 的 Prepare 请求做出过响应，它就接受该提案。 </p><h2 id="2-Zab"><a href="#2-Zab" class="headerlink" title="2. Zab"></a>2. Zab</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;ZAB( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议）协议包括两种基本的模式：崩溃恢复和消息广播</p><ol><li><p>当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断崩溃退出与重启等异常情况时，ZAB 就会进入恢复模式并选举产生新的 Leader 服务器。 </p></li><li><p>当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该 Leader 服务器完成了状态同步之后，ZAB 协议就会退出崩溃恢复模式，进入消息广播模式。</p></li><li><p>当有新的服务器加入到集群中去，如果此时集群中已经存在一个 Leader 服务器在负责进行消息广播，那么新加入的服务器会自动进入数据恢复模式，找到 Leader 服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。 以上其实大致经历了三个步骤： </p></li></ol><p>1、<strong>崩溃恢复：主要就是Leader选举过程</strong> </p><p>2、<strong>数据同步：Leader服务器与其他服务器进行数据同步</strong> </p><p>3、<strong>消息广播：Leader服务器将数据发送给其他服务器 说明：zookeeper 章节对该协议有详细描述</strong>。 </p><h2 id="3-Raft"><a href="#3-Raft" class="headerlink" title="3. Raft"></a>3. Raft</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;与 Paxos 不同 Raft 强调的是易懂（Understandability），Raft 和 Paxos 一样只要保证 n/2+1 节点正常就能够提供服务；raft 把算法流程分为三个子问题：选举（Leader election）、日志复制（Log replication）、安全性（Safety）三个子问题。 </p><h3 id="3-1-角色"><a href="#3-1-角色" class="headerlink" title="3.1. 角色"></a>3.1. 角色</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Raft 把集群中的节点分为三种状态：<strong>Leader、 Follower 、Candidate</strong>，理所当然每种状态负责的任务也是不一样的，Raft 运行时提供服务的时候只存在 Leader 与 Follower 两种状态； </p><p><strong>Leader（领导者-日志管理）</strong> </p><p>负责日志的同步管理，处理来自客户端的请求，与 Follower 保持这 heartBeat 的联系； </p><p><strong>Follower （追随者-日志同步）</strong> </p><p>刚启动时所有节点为Follower状态，响应Leader的日志同步请求，响应Candidate的请求，</p><p>把请求到 Follower 的事务转发给 Leader； </p><p><strong>Candidate（候选者-负责选票）</strong> </p><p>负责选举投票，Raft 刚启动时由一个节点从 Follower 转为 Candidate 发起选举，选举出</p><p>Leader 后从 Candidate 转为 Leader 状态； </p><h3 id="3-2-Term（任期）"><a href="#3-2-Term（任期）" class="headerlink" title="3.2. Term（任期）"></a>3.2. Term（任期）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Raft 中使用了一个可以理解为周期（第几届、任期）的概念，用 Term 作为一个周期，每个 Term 都是一个连续递增的编号，每一轮选举都是一个 Term 周期，在一个 Term 中只能产生一个 Leader；当某节点收到的请求中 Term 比当前 Term 小时则拒绝该请求。 </p><h3 id="3-3-选举（Election）"><a href="#3-3-选举（Election）" class="headerlink" title="3.3. 选举（Election）"></a>3.3. 选举（Election）</h3><p><strong>选举定时器</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Raft 的选举由定时器来触发，<u>每个节点的选举定时器时间都是不一样的</u>，开始时状态都为Follower 某个节点定时器触发选举后 Term 递增，状态由 Follower 转为 Candidate，向其他节点发起 RequestVote RPC 请求，这时候有三种可能的情况发生：</p><p> 1：该RequestVote请求接收到n/2+1（过半数）个节点的投票，从Candidate 转为Leader，向其他节点发送 heartBeat 以保持 Leader 的正常运转。 </p><p> 2：在此期间如果收到其他节点发送过来的 AppendEntries RPC 请求，如该节点的 Term 大则当前节点转为 Follower，否则保持 Candidate 拒绝该请求。 </p><p> 3：Election timeout 发生则 Term 递增，重新发起选举 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在一个 Term 期间每个节点只能投票一次，<u>所以当有多个 Candidate 存在时就会出现每个 Candidate 发起的选举都存在接收到的投票数都不过半的问题，这时每个 Candidate 都将 Term 递增、重启定时器并重新发起选举，由于每个节点中定时器的时间都是随机的，所以就不会多次存在有多个 Candidate 同时发起投票的问题</u>。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Raft 中当接收到客户端的日志（事务请求）后先把该日志追加到本地的 Log 中，然后通过 heartbeat 把该 Entry 同步给其他 Follower，Follower 接收到日志后记录日志然后向 Leader 发送 ACK，当 Leader 收到大多数（n/2+1）Follower 的 ACK 信息后将该日志设置为已提交并追加到本地磁盘中，通知客户端并在下个 heartbeat 中 Leader 将通知所有的 Follower 将该日志存储在自己的本地磁盘中。 </p><h3 id="3-4-安全性（Safety）"><a href="#3-4-安全性（Safety）" class="headerlink" title="3.4. 安全性（Safety）"></a>3.4. 安全性（Safety）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;安全性是用于保证每个节点都执行相同序列的安全机制如当某个 <u>Follower 在当前 Leader commit Log 时变得不可用了，稍后可能该 Follower 又会倍选举为 Leader，这时新 Leader 可能会用新的 Log 覆盖先前已 committed 的 Log</u>，这就是导致节点执行不同序列；Safety 就是用于保证选举出来的 Leader 一定包含先前 commited Log 的机制；  </p><p>选举安全性（Election Safety）：每个 Term 只能选举出一个 Leader </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Leader 完整性（Leader Completeness）：这里所说的<strong>完整性是指 Leader 日志的完整性</strong>， Raft 在选举阶段就使用 Term 的判断用于保证完整性：当请求投票的该 Candidate 的 Term 较大或 Term 相同 Index 更大则投票，该节点将容易变成 leader。 </p><h3 id="3-5-raft-协议和-zab-协议区别"><a href="#3-5-raft-协议和-zab-协议区别" class="headerlink" title="3.5. raft 协议和 zab 协议区别"></a>3.5. raft 协议和 zab 协议区别</h3><p><strong>相同点</strong> </p><ul><li>采用 quorum 来确定整个系统的一致性,这个 quorum 一般实现是集群中半数以上的服务器, §    zookeeper 里还提供了带权重的 quorum 实现. </li><li>都由 leader 来发起写操作. </li><li>都采用心跳检测存活性 </li><li>leader election 都采用先到先得的投票方式 </li></ul><p><strong>不同点</strong> </p><ul><li>zab 用的是 epoch 和 count 的组合来唯一表示一个值, 而 raft 用的是 term 和 index </li><li>zab 的 follower 在投票给一个 leader 之前必须和 leader 的日志达成一致,而 raft 的 follower 则简单地说是谁的 term 高就投票给谁 </li><li>raft 协议的心跳是从 leader 到 follower, 而 zab 协议则相反 </li><li>raft 协议数据只有单向地从 leader 到 follower(成为 leader 的条件之一就是拥有最新的 log), 而 zab 协议在 discovery 阶段, 一个 prospective leader 需要将自己的 log 更新为 quorum 里面最新的 log,然后才好在 synchronization 阶段将 quorum 里的其他机器的 log 都同步到一致. </li></ul><h2 id="4-NWR"><a href="#4-NWR" class="headerlink" title="4. NWR"></a>4. NWR</h2><p><strong>N：在分布式存储系统中，有多少份备份数据</strong> </p><p><strong>W：代表一次成功的更新操作要求至少有W份数据写入成功</strong> </p><p><strong>R： 代表一次成功的读数据操作要求至少有R份数据成功读取</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;NWR值的不同组合会产生不同的一致性效果，当W+R&gt;N的时候，整个系统对于客户端来讲能保证强一致性。而如果 R+W&lt;=N，则无法保证数据的强一致性。以常见的 N=3、W=2、R=2 为例： </p><p>&nbsp;&nbsp;&nbsp;&nbsp;N=3，表示，任何一个对象都必须有三个副本（Replica），W=2 表示，对数据的修改操作（Write）只需要在 3 个 Replica 中的 2 个上面完成就返回，R=2 表示，从三个对象中要读取到 2 个数据对象，才能返回。 </p><p><img src="/images/Java_heart_Algorithm/clip_image003.gif" alt="img"> </p><h2 id="5-Gossip"><a href="#5-Gossip" class="headerlink" title="5. Gossip"></a>5. Gossip</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Gossip 算法又被称为反熵（Anti-Entropy），熵是物理学上的一个概念，<strong>代表杂乱无章，而反熵就是在杂乱无章中寻求一致</strong>，这充分说明了 Gossip 的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。每个节点可能知道所有其他节点，也可能仅知道几个邻居节点，只要这些节可以通过网络连通，最终他们的状态都是一致的，当然这也是疫情传播的特点。</p><h2 id="6-一致性-Hash"><a href="#6-一致性-Hash" class="headerlink" title="6. 一致性 Hash"></a>6. 一致性 Hash</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; 一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。 Memcached client 也选择这种算法，解决将 key-value 均匀分配到众多 Memcached server 上的问题。它可以取代传统的取模操作，解决了取模操作无法应对增删 Memcached Server 的问题</p><p>(增删 server 会导致同一个 key,在 get 操作时分配不到数据真正存储的 server，命中率会急剧下降)。 </p><h3 id="6-1-一致性-Hash-特性"><a href="#6-1-一致性-Hash-特性" class="headerlink" title="6.1. 一致性 Hash 特性"></a>6.1. 一致性 Hash 特性</h3><ul><li>平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。</li><li>单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。容易看到，上面的简单求余算法hash(object)%N 难以满足单调性要求。</li><li>平滑性(Smoothness)：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</li></ul><h3 id="6-2-一致性-Hash-原理"><a href="#6-2-一致性-Hash-原理" class="headerlink" title="6.2. 一致性 Hash 原理"></a>6.2. 一致性 Hash 原理</h3><p><strong>1、建构环形 hash 空间：</strong> </p><ol><li>考虑通常的 hash 算法都是将 value 映射到一个 32 为的 key 值，也即是 0~2^32-1 次方的数值空间；我们可以将这个空间想象成一个首（ 0 ）尾（ 2^32-1 ）相接的圆环。 </li></ol><p><strong>2、把需要缓存的内容(对象)映射到 hash 空间</strong> </p><ol start="2"><li>接下来考虑 4 个对象 object1~object4 ，通过 hash 函数计算出的 hash 值 key 在环上的分布 </li></ol><p><strong>3、把服务器(节点)\映射到 hash 空间</strong> </p><ol start="3"><li>Consistent hashing 的基本思想就是将对象和 cache 都映射到同一个 hash 数值空间中，并且使用相同的 hash 算法。一般的方法可以使用 服务器(节点) 机器的 IP 地址或者机器名作为 hash 输入。 </li></ol><p><strong>4、把对象映射到服务节点</strong> </p><ol start="4"><li>现在服务节点和对象都已经通过同一个 hash 算法映射到 hash 数值空间中了，首先确定对象 hash 值在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器。</li></ol><p><img src="/images/Java_heart_Algorithm/clip_image005.gif" alt="img"> </p><p><strong>考察 cache 的变动</strong> </p><ol start="5"><li>通过 hash 然后求余的方法带来的最大问题就在于不能满足单调性，当 cache 有所变动时， cache 会失效。 </li></ol><ul><li><strong>移除 cache</strong>：考虑假设 cache B 挂掉了，根据上面讲到的映射方法，这时受影响的将仅是那些沿 cache B 逆时针遍历直到下一个 cache （ cache C ）之间的对象。 </li><li><strong>添加 cache</strong>：再考虑添加一台新的 cache D 的情况，这时受影响的将仅是那些沿 cache D 逆时针遍历直到下一个 cache 之间的对象，将这些对象重新映射到 cache D 上即可。 </li></ul><p><strong>虚拟节点</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;hash 算法并不是保证绝对的平衡，如果 cache 较少的话，对象并不能被均匀的映射到 cache 上，为了解决这种情况， consistent hashing 引入了“虚拟节点”的概念，它可以如下定义： </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>虚拟节点（ virtual node ）是实际节点在 hash 空间的复制品（ replica ）</u>，一实际个节点对应了若干个“虚拟节点”，这个对应个数也成为“复制个数”，“虚拟节点”在 hash 空间中以 hash 值排列。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;仍以仅部署 cache A 和 cache C 的情况为例。现在我们引入虚拟节点，并设置“复制个数”为 2 ，这就意味着一共会存在 4 个“虚拟节点”， cache A1, cache A2 代表了 cache A； cache C1, cache C2 代表了 cache C 。此时，对象到“虚拟节点”的映射关系为： </p><p>objec1-&gt;cache A2 ； objec2-&gt;cache A1 ； objec3-&gt;cache C1 ； objec4-&gt;cache C2 ； </p><p>因此对象 object1 和 object2 都被映射到了 cache A 上，而 object3 和 object4 映射到了 cache C 上；平衡性有了很大提高。 </p><p>引入“虚拟节点”后，映射关系就从 { 对象 -&gt; 节点 } 转换到了 { 对象 -&gt; 虚拟节点 } 。查询物体所在 cache 时的映射关系如下图 所示。 </p><p><img src="/images/Java_heart_Algorithm/clip_image007.gif" alt="img"> </p><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7. 最后"></a>7. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Paxos&quot;&gt;&lt;a href=&quot;#1-Paxos&quot; class=&quot;headerlink&quot; title=&quot;1. Paxos&quot;&gt;&lt;/a&gt;1. Paxos&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。zookeeper 使用的 zab 算法是该算法的一个实现。 在 Paxos 算法中，有三种角色：Proposer，Acceptor，Learners &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(十五)之数据库</title>
    <link href="https://quietair.gitee.io/Java_heart_noSql/"/>
    <id>https://quietair.gitee.io/Java_heart_noSql/</id>
    <published>2020-05-16T07:22:49.000Z</published>
    <updated>2020-05-16T07:43:32.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-存储引擎"><a href="#1-存储引擎" class="headerlink" title="1. 存储引擎"></a>1. 存储引擎</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1. 概念"></a>1.1. 概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。存储引擎主要有： </p><ol><li>MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。 </li></ol><a id="more"></a><h3 id="1-2-InnoDB（B-树）"><a href="#1-2-InnoDB（B-树）" class="headerlink" title="1.2. InnoDB（B+树）"></a>1.2. InnoDB（B+树）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;InnoDB 底层存储结构为B+树， B树的每个节点对应innodb的一个page，page大小是固定的，一般设为 16k。其中非叶子节点只有键值，叶子节点包含完成数据。 </p><p><img src="/images/Java_heart_noSql/clip_image003.gif" alt="img"> </p><p>适用场景： </p><p>1）经常更新的表，适合处理多重并发的更新请求。 </p><p>2）支持事务。 </p><p>3）可以从灾难中恢复（通过 bin-log 日志等）。 </p><p>4）外键约束。只有他支持外键。 </p><p>5）支持自动增加列属性 auto_increment。 </p><h3 id="1-3-TokuDB（Fractal-Tree-节点带数据）"><a href="#1-3-TokuDB（Fractal-Tree-节点带数据）" class="headerlink" title="1.3. TokuDB（Fractal Tree-节点带数据）"></a>1.3. TokuDB（Fractal Tree-节点带数据）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;TokuDB 底层存储结构为 Fractal Tree,Fractal Tree 的结构与 B+树有些类似, 在 Fractal Tree 中，<strong>每一个 child 指针除了需要指向一个 child 节点外，还会带有一个 Message Buffer ，这个 Message Buffer 是一个 FIFO 的队列，用来缓存更新操作</strong>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;例如，一次插入操作只需要落在某节点的 Message Buffer 就可以马上返回了，并不需要搜索到叶子节点。这些缓存的更新会在查询时或后台异步合并应用到对应的节点中。</p><p><img src="/images/Java_heart_noSql/clip_image005.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;TokuDB 在线添加索引，不影响读写操作, 非常快的写入性能， Fractal-tree 在事务实现上有优势。 他主要适用于访问频率不高的数据或历史数据归档。</p><h3 id="1-4-MyIASM"><a href="#1-4-MyIASM" class="headerlink" title="1.4. MyIASM"></a>1.4. MyIASM</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当 INSERT(插入)或 UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;ISAM 执行<strong>读取操作的速度很快</strong>，而且不占用大量的内存和存储资源。在设计之初就预想数据组织成有固定长度的记录，按顺序存储的。—ISAM 是一种静态索引结构。 </p><p><strong>缺点是它不 支持事务处理</strong>。 </p><h3 id="1-5-Memory"><a href="#1-5-Memory" class="headerlink" title="1.5. Memory"></a>1.5. Memory</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Memory（也叫 HEAP）堆内存：使用存在内存中的内容来创建表。每个 MEMORY 表只实际对应一个磁盘文件。MEMORY 类型的表访问非常得快，因为它的数据是放在内存中的，并且默认使用 HASH 索引。但是一旦服务关闭，表中的数据就会丢失掉。 <strong>Memory 同时支持散列索引和 B 树索引，B树索引可以使用部分查询和通配查询</strong>，也可以使用&lt;,&gt;和&gt;=等操作符方便数据挖掘，散列索引相等的比较快但是对于范围的比较慢很多。</p><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;索引（Index）是帮助 MySQL 高效获取数据的数据结构。常见的查询算法,顺序查找,二分查找,二叉排序树查找,哈希散列法,分块查找,平衡多路搜索树 B 树（B-tree） </p><h3 id="2-1-常见索引原则有"><a href="#2-1-常见索引原则有" class="headerlink" title="2.1. 常见索引原则有"></a>2.1. 常见索引原则有</h3><p><strong>1、选择唯一性索引</strong> </p><p>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。 </p><p><strong>2、为经常需要排序、分组和联合操作的字段建立索引：</strong> </p><p><strong>3、为常作为查询条件的字段建立索引。</strong> </p><p><strong>4、限制索引的数目：</strong> </p><p>越多的索引，会使更新表变得很浪费时间。 </p><p><strong>尽量使用数据量少的索引</strong> </p><p>5、如果索引的值很长，那么查询的速度会受到影响。 </p><p><strong>尽量使用前缀来索引</strong> </p><p>6、如果索引字段的值很长，最好使用值的前缀来索引。 </p><p><strong>7、删除不再使用或者很少使用的索引</strong> </p><p><strong>8、最左前缀匹配原则，非常重要的原则。</strong> </p><p><strong>9、尽量选择区分度高的列作为索引</strong> </p><p>区分度的公式是表示字段不重复的比例 </p><p><strong>10、索引列不能参与计算，保持列“干净”：带函数的查询不参与索引。</strong> </p><p><strong>11、尽量的扩展索引，不要新建索引。</strong> </p><h2 id="3-数据库三范式"><a href="#3-数据库三范式" class="headerlink" title="3. 数据库三范式"></a>3. 数据库三范式</h2><p>范式是具有最小冗余的表结构。3 范式具体如下： </p><h3 id="3-1-第一范式-1st-NF－列都是不可再分"><a href="#3-1-第一范式-1st-NF－列都是不可再分" class="headerlink" title="3.1. 第一范式 (1st NF－列都是不可再分)"></a>3.1. 第一范式 (1st NF－列都是不可再分)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第一范式的目标是确保每列的原子性:如果<strong>每列都是不可再分</strong>的最小数据单元（也称为最小的原子单元），则满足第一范式（1NF） </p><p><img src="/images/Java_heart_noSql/clip_image007.jpg" alt="img"> </p><h3 id="3-2-第二范式-2nd-NF－每个表只描述一件事情"><a href="#3-2-第二范式-2nd-NF－每个表只描述一件事情" class="headerlink" title="3.2. 第二范式 (2nd NF－每个表只描述一件事情)"></a>3.2. 第二范式 (2nd NF－每个表只描述一件事情)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;首先满足第一范式，并且表中非主键列不存在对主键的部分依赖。 <strong>第二范式要求每个表只描述一件事情</strong>。 </p><p><img src="/images/Java_heart_noSql/clip_image009.jpg" alt="img"> </p><h3 id="3-3-第三范式-3rd-NF－-不存在对非主键列的传递依赖"><a href="#3-3-第三范式-3rd-NF－-不存在对非主键列的传递依赖" class="headerlink" title="3.3. 第三范式 (3rd NF－ 不存在对非主键列的传递依赖)"></a>3.3. 第三范式 (3rd NF－ 不存在对非主键列的传递依赖)</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第三范式定义是，满足第二范式，并且表中的列不存在对非主键列的传递依赖。除了主键订单编号外，顾客姓名依赖于非主键顾客编号。</p><p><img src="/images/Java_heart_noSql/clip_image011.gif" alt="img"> </p><h2 id="4-数据库是事务"><a href="#4-数据库是事务" class="headerlink" title="4. 数据库是事务"></a>4. 数据库是事务</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;事务(TRANSACTION)是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行 。事务是一个不可分割的工作逻辑单元 </p><p>事务必须具备以下四个属性，简称 ACID 属性： </p><p><strong>原子性（Atomicity）</strong> </p><ol><li>事务是一个完整的操作。事务的各步操作是不可分的（原子的）；要么都执行，要么都不执行。</li></ol><p><strong>一致性（Consistency）</strong> </p><ol start="2"><li>当事务完成时，数据必须处于一致状态。 </li></ol><p><strong>隔离性（Isolation）</strong> </p><ol start="3"><li>对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖于或影响其他事务。</li></ol><p><strong>永久性（Durability）</strong> </p><ol start="4"><li>事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。 </li></ol><h2 id="5-存储过程-特定功能的-SQL-语句集"><a href="#5-存储过程-特定功能的-SQL-语句集" class="headerlink" title="5. 存储过程 (特定功能的 SQL 语句集)"></a>5. 存储过程 (特定功能的 SQL 语句集)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译后再次调用不需要再次编译，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。</p><p><strong>存储过程优化思路：</strong> </p><ol><li><p>尽量利用一些 sql 语句来替代一些小循环，例如聚合函数，求平均函数等。</p></li><li><p>中间结果存放于临时表，加索引。 </p></li><li><p>少使用游标。sql 是个集合语言，对于集合运算具有较高性能。而 cursors 是过程运算。比如对一个 100 万行的数据进行查询。游标需要读表 100 万次，而不使用游标则只需要少量几次读取。 </p></li><li><p>事务越短越好。sqlserver 支持并发操作。如果事务过多过长，或者隔离级别过高，都会造成并发操作的阻塞，死锁。导致查询极慢，cpu 占用率极地。 </p></li><li><p>使用 try-catch 处理错误异常。</p></li><li><p>查找语句尽量不要放在循环内。 </p></li></ol><h2 id="6-触发器-一段能自动执行的程序"><a href="#6-触发器-一段能自动执行的程序" class="headerlink" title="6. 触发器 (一段能自动执行的程序)"></a>6. 触发器 (一段能自动执行的程序)</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;触发器是一段能自动执行的程序，是一种特殊的存储过程，触发器和普通的存储过程的区别是：<strong>触发器是当对某一个表进行操作时触发</strong>。诸如：update、insert、delete 这些操作的时候，系统会自动调用执行该表上对应的触发器。SQL Server 2005 中触发器可以分为两类：DML 触发器和 DDL 触发器，其中 DDL 触发器它们会影响多种数据定义语言语句而激发，这些语句有 create、 alter、drop 语句。 </p><h2 id="7-数据库并发策略"><a href="#7-数据库并发策略" class="headerlink" title="7. 数据库并发策略"></a>7. 数据库并发策略</h2><p>并发控制一般采用三种方法，分别是<strong>乐观锁和悲观锁以及时间戳</strong>。 </p><h3 id="7-1-乐观锁"><a href="#7-1-乐观锁" class="headerlink" title="7.1. 乐观锁"></a>7.1. 乐观锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；时间戳就是不加锁，通过时间戳来控制并发出现的问题。</p><h3 id="7-2-悲观锁"><a href="#7-2-悲观锁" class="headerlink" title="7.2. 悲观锁"></a>7.2. 悲观锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是<strong>自己修改某条数据的时候，不允许别人读取该数据</strong>，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</p><h3 id="7-3-时间戳"><a href="#7-3-时间戳" class="headerlink" title="7.3. 时间戳"></a>7.3. 时间戳</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，<strong>每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存</strong>，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量， 以上悲观锁所说的加“锁”，其实分为几种锁，分别是：<strong>排它锁（写锁）和共享锁（读锁）</strong>。 </p><h2 id="8-数据库锁"><a href="#8-数据库锁" class="headerlink" title="8. 数据库锁"></a>8. 数据库锁</h2><h3 id="8-1-行级锁"><a href="#8-1-行级锁" class="headerlink" title="8.1. 行级锁"></a>8.1. 行级锁</h3><p><strong>行级锁是一种排他锁，防止其他事务修改此行</strong>；在使用以下语句时，Oracle 会自动应用行级锁： </p><ol><li><p>INSERT、UPDATE、DELETE、SELECT … FOR UPDATE [OF columns] [WAIT n | NOWAIT]; </p></li><li><p>SELECT … FOR UPDATE 语句允许用户一次锁定多条记录进行更新 </p></li><li><p>使用 COMMIT 或 ROLLBACK 语句释放锁。 </p></li></ol><h3 id="8-2-表级锁"><a href="#8-2-表级锁" class="headerlink" title="8.2. 表级锁"></a>8.2. 表级锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分 MySQL 引擎支持。最常使用的 MYISAM 与 INNODB 都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。 </p><h3 id="8-3-页级锁"><a href="#8-3-页级锁" class="headerlink" title="8.3. 页级锁"></a>8.3. 页级锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;页级锁是 MySQL 中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB 支持页级锁 </p><h2 id="9-基于-Redis-分布式锁"><a href="#9-基于-Redis-分布式锁" class="headerlink" title="9. 基于 Redis 分布式锁"></a>9. 基于 Redis 分布式锁</h2><ol><li><p><strong>获取锁的时候，使用 setnx</strong>（SETNX key val：当且仅当 key 不存在时，set 一个 key 为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value 值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添加一个超时时间，超过该时间则自动释放锁。 </p></li><li><p>获取锁的时候调用 setnx，<strong>如果返回 0，则该锁正在被别人使用，返回 1 则成功获取锁</strong>。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p></li><li><p>释放锁的时候，通过 UUID <strong>判断是不是该锁</strong>，若是该锁，<strong>则执行 delete 进行锁释放</strong>。 </p></li></ol><h2 id="10-分区分表"><a href="#10-分区分表" class="headerlink" title="10. 分区分表"></a>10. 分区分表</h2><p>分库分表有垂直切分和水平切分两种。 </p><p><strong>垂直切分 (按照功能模块)</strong></p><ul><li><u>将表按照功能模块</u>、关系密切程度划分出来，<u>部署到不同的库上</u>。例如，我们会建立定义数据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于存储项目数据定义表、商品定义表、用户数据表、日志数据表等。 </li></ul><p><img src="/images/Java_heart_noSql/clip_image013.gif" alt="img"> </p><p><strong>水平切分 (按照规则划分存储)</strong></p><ul><li>当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行划分，然后存储到多个结构相同的表，和不同的库上。 </li></ul><p><img src="/images/Java_heart_noSql/clip_image015.gif" alt="img"> </p><h2 id="11-两阶段提交协议"><a href="#11-两阶段提交协议" class="headerlink" title="11. 两阶段提交协议"></a>11. 两阶段提交协议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。 </p><p> &nbsp;&nbsp;&nbsp;&nbsp;XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，<u>为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)</u>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;通常，二阶段提交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的 ACID 特性，<u>需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)</u>。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p><h3 id="11-1-准备阶段"><a href="#11-1-准备阶段" class="headerlink" title="11.1. 准备阶段"></a>11.1. 准备阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;事务协调者(事务管理器)给每个参与者(资源管理器)<strong>发送 Prepare 消息</strong>，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，<strong>写本地的 redo 和 undo 日志</strong>，但不提交，到达一种“万事俱备，只欠东风”的状态。 </p><h3 id="11-2-提交阶段"><a href="#11-2-提交阶段" class="headerlink" title="11.2. 提交阶段"></a>11.2. 提交阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源) </p><h3 id="11-3-缺点"><a href="#11-3-缺点" class="headerlink" title="11.3. 缺点"></a>11.3. 缺点</h3><p><strong>同步阻塞问题</strong> </p><p>1、 执行过程中，所有参与节点都是事务阻塞型的。 </p><p><strong>单点故障</strong> </p><p>2、 由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。 </p><p><strong>数据不一致（脑裂问题）</strong> </p><p>3、 在二阶段提交的阶段二中，当协调者向参与者<u>发送 commit 请求之后，发生了局部网络异常</u>或者在发送 commit 请求过程中协调者发生了故障，导致只有一部分参与者接受到了 commit 请求。于是整个分布式系统便出现了数据部一致性的现象(脑裂现象)。 </p><p><strong>二阶段无法解决的问题（数据状态不确定）</strong> </p><p>4、 协调者再发出 commit 消息之后宕机，<u>而唯一接收到这条消息的参与者同时也宕机了</u>。那么即使协调者通过选举协议产生了新的协调者，<u>这条事务的状态也是不确定的，没人知道事务是否被已经提交</u>。 </p><h2 id="12-三阶段提交协议"><a href="#12-三阶段提交协议" class="headerlink" title="12. 三阶段提交协议"></a>12. 三阶段提交协议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;三 阶 段 提 交 （ Three-phase commit ） ， 也 叫 三 阶 段 提 交 协 议 （ Three-phase commit protocol），是二阶段提交（2PC）的改进版本。 </p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。 </p><p>2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。也就是说，除了引入超时机制之外，<strong>3PC 把 2PC 的准备阶段再次一分为二</strong>，这样三阶段提交就有 CanCommit、PreCommit、DoCommit 三个阶段。 </p><h3 id="12-1-CanCommit-阶段"><a href="#12-1-CanCommit-阶段" class="headerlink" title="12.1. CanCommit 阶段"></a>12.1. CanCommit 阶段</h3><p>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。 </p><h3 id="12-2-PreCommit-阶段"><a href="#12-2-PreCommit-阶段" class="headerlink" title="12.2. PreCommit 阶段"></a>12.2. PreCommit 阶段</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;协调者根据参与者的反应情况来决定是否可以继续进行，有以下两种可能。假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行假如有任何一个参与者向协调者发送了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><h3 id="12-3-doCommit-阶段"><a href="#12-3-doCommit-阶段" class="headerlink" title="12.3. doCommit 阶段"></a>12.3. doCommit 阶段</h3><p>该阶段进行真正的事务提交，主要包含:</p><ol><li><p>协调这发送提交请求 </p></li><li><p>参与者提交事务 </p></li><li><p>参与者响应反馈（ 事务提交完之后，向协调者发送 Ack 响应。）</p></li><li><p>协调者确定完成事务。</p></li></ol><h2 id="13-柔性事务"><a href="#13-柔性事务" class="headerlink" title="13. 柔性事务"></a>13. 柔性事务</h2><h3 id="13-1-柔性事务"><a href="#13-1-柔性事务" class="headerlink" title="13.1. 柔性事务"></a>13.1. 柔性事务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于 CAP 理论以及 BASE 理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性（Eventual Consistency）。 </p><p>通常所说的柔性事务分为：<strong>两阶段型、补偿型、异步确保型、最大努力通知型</strong>几种。 </p><p><strong>两阶段型</strong> </p><p>1、 就是<u>分布式事务两阶段提交，对应技术上的 XA、JTA/JTS</u>。这是分布式环境下事务处理的典型模式。 </p><p><strong>补偿型</strong> </p><p>2、 TCC 型事务（Try/Confirm/Cancel）可以归为补偿型。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，服务器 B 参与事务，<u>服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行顺利，则事务 B 也提交，整个事务就算完成</u>。但是<u>如果事务 B 执行失败，事务 B 本身回滚，这时事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢复到未执行前事务 A 的状态</u>。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是提高了 long-running 事务的可用性。 </p><p><img src="/images/Java_heart_noSql/clip_image017.jpg" alt="img"> </p><p><strong>异步确保型</strong> </p><p>3、 通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响。 </p><p><img src="/images/Java_heart_noSql/clip_image019.gif" alt="img"> </p><p><strong>最大努力通知型（多次尝试）</strong> </p><p>4、 这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不同的一点是, 在消息由 MQ Server 投递到消费者之后, <u>允许在达到最大重试次数之后正常结束事务</u>。</p><h2 id="14-CAP"><a href="#14-CAP" class="headerlink" title="14. CAP"></a>14. CAP</h2><p>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability</p><p>（可用性）、Partition tolerance（分区容错性），三者不可得兼。 </p><p><strong>一致性（C）：</strong> </p><ol><li>在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li></ol><p><strong>可用性（A）：</strong> </p><ol start="2"><li>在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li></ol><p><strong>分区容忍性（P）：</strong></p><ol start="3"><li>以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。 </li></ol><h2 id="15-最后"><a href="#15-最后" class="headerlink" title="15. 最后"></a>15. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-存储引擎&quot;&gt;&lt;a href=&quot;#1-存储引擎&quot; class=&quot;headerlink&quot; title=&quot;1. 存储引擎&quot;&gt;&lt;/a&gt;1. 存储引擎&lt;/h2&gt;&lt;h3 id=&quot;1-1-概念&quot;&gt;&lt;a href=&quot;#1-1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.1. 概念&quot;&gt;&lt;/a&gt;1.1. 概念&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。存储引擎主要有： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MyIsam , 2. InnoDB, 3. Memory, 4. Archive, 5. Federated 。 &lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(十四)之负载均衡</title>
    <link href="https://quietair.gitee.io/Java_heart_LoadBalance/"/>
    <id>https://quietair.gitee.io/Java_heart_LoadBalance/</id>
    <published>2020-05-09T09:54:14.000Z</published>
    <updated>2020-05-09T10:07:46.675Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展<a href="https://baike.baidu.com/item/网络设备" target="_blank" rel="noopener">网络设备</a><a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">和</a><a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">服务器</a><a href="https://baike.baidu.com/item/服务器" target="_blank" rel="noopener">的</a>带宽、增加<a href="https://baike.baidu.com/item/吞吐量" target="_blank" rel="noopener">吞吐量</a><a href="https://baike.baidu.com/item/吞吐量" target="_blank" rel="noopener">、</a>加强网络数据处理能力、提高网络的灵活性和可用性。</p><a id="more"></a><h2 id="1-四层负载均衡-vs七层负载均衡"><a href="#1-四层负载均衡-vs七层负载均衡" class="headerlink" title="1. 四层负载均衡 vs七层负载均衡"></a>1. 四层负载均衡 vs七层负载均衡</h2><p><img src="/images%5CJava_heart_LoadBalance%5Cclip_image003.gif" alt="img"> </p><h3 id="1-1-四层负载均衡（目标地址和端口交换）"><a href="#1-1-四层负载均衡（目标地址和端口交换）" class="headerlink" title="1.1. 四层负载均衡（目标地址和端口交换）"></a>1.1. 四层负载均衡（目标地址和端口交换）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;以常见的 TCP 为例，<u>负载均衡设备在接收到第一个来自客户端的 SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标 IP 地址进行修改(改为后端服务器 IP），直接转发给该服务器</u>。TCP 的连接建立，即<strong>三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作</strong>。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。实现四层负载均衡的软件有：</p><ul><li>F5：硬件负载均衡器，功能很好，但是成本很高。 </li><li>lvs：重量级的四层负载软件。 </li><li>nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活。 </li><li>haproxy：模拟四层转发，较灵活。 </li></ul><h3 id="1-2-七层负载均衡（内容交换）"><a href="#1-2-七层负载均衡（内容交换）" class="headerlink" title="1.2. 七层负载均衡（内容交换）"></a>1.2. 七层负载均衡（内容交换）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;所谓七层负载均衡，也<u>称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。</u> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;七层应用负载的好处，是使得整个网络更智能化。例如访问一个网站的用户流量，<u>可以通过七层的方式，将对图片类的请求转发到特定的图片服务器并可以使用缓存技术；将对文字类的请求可以转发到特定的文字服务器并可以使用压缩技术</u>。实现七层负载均衡的软件有：</p><ul><li>haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移； </li><li>nginx：只在http协议和mail协议上功能比较好，性能与haproxy差不多； </li><li>apache：功能较差 ;</li><li>Mysql proxy：功能尚可。 </li></ul><h2 id="2-负载均衡算法-策略"><a href="#2-负载均衡算法-策略" class="headerlink" title="2. 负载均衡算法/策略"></a>2. 负载均衡算法<strong>/</strong>策略</h2><h3 id="2-1-轮循均衡（Round-Robin）"><a href="#2-1-轮循均衡（Round-Robin）" class="headerlink" title="2.1. 轮循均衡（Round Robin）"></a>2.1. 轮循均衡（Round Robin）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;每一次来自网络的<strong>请求轮流分配给内部中的服务器</strong>，从 1 至 N 然后重新开始。此种均衡算法适合于服务器组中的所有服务器都有相同的软硬件配置并且平均服务请求相对均衡的情况。</p><h3 id="2-2-权重轮循均衡（Weighted-Round-Robin）"><a href="#2-2-权重轮循均衡（Weighted-Round-Robin）" class="headerlink" title="2.2. 权重轮循均衡（Weighted Round Robin）"></a>2.2. 权重轮循均衡（Weighted Round Robin）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;根据<strong>服务器的不同处理能力，给每个服务器分配不同的权值</strong>，使其能够接受相应权值数的服务请求。例如：服务器 A 的权值被设计成 1，B 的权值是 3，C 的权值是 6，则服务器 A、B、C 将分别接受到 10%、30％、60％的服务请求。此种均衡算法能确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。</p><h3 id="2-3-随机均衡（Random）"><a href="#2-3-随机均衡（Random）" class="headerlink" title="2.3. 随机均衡（Random）"></a>2.3. 随机均衡（Random）</h3><p>把来自网络的请求随机分配给内部中的多个服务器。 </p><h3 id="2-4-权重随机均衡（Weighted-Random）"><a href="#2-4-权重随机均衡（Weighted-Random）" class="headerlink" title="2.4. 权重随机均衡（Weighted Random）"></a>2.4. 权重随机均衡（Weighted Random）</h3><p>此种均衡算法类似于权重轮循算法，不过在处理请求分担时是个随机选择的过程。 </p><h3 id="2-5-响应速度均衡（Response-Time-探测时间）"><a href="#2-5-响应速度均衡（Response-Time-探测时间）" class="headerlink" title="2.5. 响应速度均衡（Response Time 探测时间）"></a>2.5. 响应速度均衡（Response Time 探测时间）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>负载均衡设备对内部各服务器发出一个探测请求（例如 Ping），然后根据内部中各服务器对探测请求的最快响应时间来决定哪一台服务器来响应客户端的服务请求。</u>此种均衡算法能较好的反映服务器的当前运行状态，但这最快响应时间仅仅指的是负载均衡设备与服务器间的最快响应时间，而不是客户端与服务器间的最快响应时间。</p><h3 id="2-6-最少连接数均衡（Least-Connection）"><a href="#2-6-最少连接数均衡（Least-Connection）" class="headerlink" title="2.6. 最少连接数均衡（Least Connection）"></a>2.6. 最少连接数均衡（Least Connection）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;最少连接数均衡算法对内部中需负载的每一台服务器都有一个数据记录，记录当前该服务器正在处理的连接数量，当有新的服务连接请求时，将把当前请求分配给连接数最少的服务器，使均衡更加符合实际情况，负载更加均衡。此种均衡算法适合长时处理的请求服务，如 FTP。 </p><h3 id="2-7-处理能力均衡（CPU、内存）"><a href="#2-7-处理能力均衡（CPU、内存）" class="headerlink" title="2.7. 处理能力均衡（CPU、内存）"></a>2.7. 处理能力均衡（CPU、内存）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;此种均衡算法将把服务请求分配给内<u>部中处理负荷（根据服务器 CPU 型号、CPU 数量、内存大小及当前连接数等换算而成）最轻的服务器，由于考虑到了内部服务器的处理能力及当前网络运行状况，所以此种均衡算法相对来说更加精确</u>，尤其适合运用到第七层（应用层）负载均衡的情况</p><p>下。 </p><h3 id="2-8-DNS-响应均衡（Flash-DNS）"><a href="#2-8-DNS-响应均衡（Flash-DNS）" class="headerlink" title="2.8. DNS 响应均衡（Flash DNS）"></a>2.8. DNS 响应均衡（Flash DNS）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在此均衡算法下，分处在不同地理位置的负载均衡设备收到同一个客户端的域名解析请求，并在同一时间内把此域名解析成各自相对应服务器的 IP 地址并返回给客户端，<u>则客户端将以最先收到的域名解析 IP 地址来继续请求服务，而忽略其它的 IP 地址响应</u>。在种均衡策略适合应用在全局负载均衡的情况下，对本地负载均衡是没有意义的。</p><h3 id="2-9-哈希算法"><a href="#2-9-哈希算法" class="headerlink" title="2.9. 哈希算法"></a>2.9. 哈希算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一致性哈希一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p><h3 id="2-10-IP-地址散列（保证客户端服务器对应关系稳定）"><a href="#2-10-IP-地址散列（保证客户端服务器对应关系稳定）" class="headerlink" title="2.10.  IP 地址散列（保证客户端服务器对应关系稳定）"></a>2.10.  IP 地址散列（保证客户端服务器对应关系稳定）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;通过管理发送方 IP 和目的地 IP 地址的散列，将来自同一发送方的分组(或发送至同一目的地的分组)统一转发到相同服务器的算法。当客户端有一系列业务需要处理而必须和一个服务器反复通信时，该算法能够以流(会话)为单位，<u>保证来自相同客户端的通信能够一直在同一服务器中进行处理</u>。 </p><h3 id="2-11-URL-散列"><a href="#2-11-URL-散列" class="headerlink" title="2.11. URL 散列"></a>2.11. URL 散列</h3><p>通过管理客户端请求 URL 信息的散列，将发送至相同 URL 的请求转发至同一服务器的算法。</p><h2 id="3-LVS"><a href="#3-LVS" class="headerlink" title="3. LVS"></a>3. LVS</h2><h3 id="3-1-LVS-原理"><a href="#3-1-LVS-原理" class="headerlink" title="3.1. LVS 原理"></a>3.1. LVS 原理</h3><p><strong>IPVS</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;LVS 的 IP 负载均衡技术是通过 IPVS 模块来实现的，IPVS 是 LVS 集群系统的核心软件，它的主要作用是：安装在 Director Server 上，同时在 Director Server 上虚拟出一个 IP 地址，用户必须通过这个虚拟的 IP 地址访问服务器。这个虚拟 IP 一般称为 LVS 的 VIP，即 Virtual IP。访问的请求首先经过 VIP 到达负载调度器，然后由负载调度器从 Real Server 列表中选取一个服务节点响应用户的请求。 在用户的请求到达负载调度器后，调度器如何将请求发送到提供服务的 Real Server 节点，而 Real Server 节点如何返回数据给用户，是 IPVS 实现的重点技术。</p><p><strong>ipvs ： 工作于内核空间，主要用于使用户定义的策略生效</strong> </p><p><strong>ipvsadm : 工作于用户空间，主要用于用户定义和管理集群服务的工具</strong> </p><p><img src="/images/Java_heart_LoadBalance/clip_image005.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>ipvs 工作于内核空间的 INPUT 链上</u>，当收到用户请求某集群服务时，经过 PREROUTING 链，经检查本机路由表，送往 INPUT 链；在进入 netfilter 的 INPUT 链时，ipvs 强行将请求报文通过 ipvsadm 定义的集群服务策略的路径改为 FORWORD 链，将报文转发至后端真实提供服务的主机。 </p><h3 id="3-2-LVS-NAT-模式"><a href="#3-2-LVS-NAT-模式" class="headerlink" title="3.2. LVS NAT 模式"></a>3.2. LVS NAT 模式</h3><p><img src="/images/Java_heart_LoadBalance/clip_image007.jpg" alt="img"> </p><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP(客户端 IP),后面统称为 CIP)，目标地址为 VIP(负载均衡器前端地址，后面统称为 VIP)。 </p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它将<u>客户端请求报文的目标地址改为了后端服务器的 RIP 地址并将报文根据算法发送出去。</u> </p><p>③.报文送到 Real Server 后，由于报文的目标地址是自己，所以会响应该请求，<u>并将响应报文返还给 LVS</u>。 </p><p>④.然后 lvs 将此报文的源地址修改为本机并发送给客户端。 </p><p><strong>注意：在 NAT 模式中，Real Server 的网关必须指向 LVS，否则报文无法送达客户端</strong> </p><p><strong>特点：</strong> </p><p>1、NAT 技术将请求的报文和响应的报文都需要通过 LB 进行地址改写，因此网站访问量比较大的时候 LB 负载均衡调度器有比较大的瓶颈，一般要求最多之能 10-20 台节点 </p><p>2、<strong>只需要在 LB 上配置一个公网 IP 地址就可以了</strong>。 </p><p>3、每台内部的 realserver 服务器的网关地址必须是调度器 LB 的内网地址。 </p><p>4、NAT 模式支持对 IP 地址和端口进行转换。即用户请求的端口和真实服务器的端口可以不一致。 </p><p><strong>优点：</strong> </p><p>集群中的物理服务器可以使用任何支持 TCP/IP 操作系统，只有负载均衡器需要一个合法的 IP 地址。 </p><p><strong>缺点：</strong> </p><p>扩展性有限。当服务器节点（普通 PC 服务器）增长过多时,负载均衡器将成为整个系统的瓶颈，因为所有的请求包和应答包的流向都经过负载均衡器。当服务器节点过多时，大量的数据包都交汇在负载均衡器那，速度就会变慢！</p><h3 id="3-3-LVS-DR-模式（局域网改写-mac-地址）"><a href="#3-3-LVS-DR-模式（局域网改写-mac-地址）" class="headerlink" title="3.3. LVS DR 模式（局域网改写 mac 地址）"></a>3.3. LVS DR 模式（局域网改写 mac 地址）</h3><p><img src="/images/Java_heart_LoadBalance/clip_image009.gif" alt="img"> </p><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。 </p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它<u>将客户端请求报文的源MAC地址改为自己DIP的MAC地址，目标MAC改为了RIP的MAC地址</u>，并将此包发送给RS。 </p><p>③.RS 发现请求报文中的目的 MAC 是自己，就会将次报文接收下来，<u>处理完请求报文后，将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端</u>。 </p><p><strong>注意：需要设置 lo 接口的 VIP 不能响应本地网络内的 arp 请求。</strong> </p><p><strong>总结：</strong> </p><p>1、通过在调度器 LB 上<u>修改数据包的目的 MAC 地址实现转发。注意源地址仍然是 CIP，目的地址仍然是 VIP 地址</u>。 </p><p>2、<u>请求的报文经过调度器，而 RS 响应处理后的报文无需经过调度器 LB，因此并发访问量大时使用效率很高</u>（和 NAT 模式比） </p><p>3、因为 DR 模式是<u>通过 MAC 地址改写机制实现转发，因此所有 RS 节点和调度器 LB 只能在一个局域网里面</u> </p><p>4、RS 主机需要绑定 VIP 地址在 LO 接口（掩码 32 位）上，并且需要配置 ARP 抑制。 </p><p>5、RS 节点的默认网关不需要配置成 LB，而是直接配置为上级路由的网关，能让 RS 直接出网就可以。 </p><p>6、由于 DR 模式的调度器仅做 MAC 地址的改写，所以调度器 LB 就不能改写目标端口，那么 RS 服务器就得使用和 VIP <u>相同的端口提供服务</u>。 </p><p>7、直接对外的业务比如 WEB 等，<u>RS 的 IP 最好是使用公网 IP</u>。对外的服务，比如数据库等最好使用内网 IP。 </p><p><strong>优点：</strong> </p><p>和 TUN（隧道模式）一样，负载均衡器也只是分发请求，应答包通过单独的路由方法返回给客户端。与 VS-TUN 相比，<u>VS-DR 这种实现方式不需要隧道结构</u>，因此可以使用大多数操作系统做为物理服务器。 </p><p>DR 模式的效率很高，但是配置稍微复杂一点，因此对于访问量不是特别大的公司可以用haproxy/nginx取代。日1000-2000W PV或者并发请求1万一下都可以考虑用haproxy/nginx。 </p><p><strong>缺点：</strong> <u>所有 RS 节点和调度器 LB 只能在一个局域网里面</u></p><h3 id="3-4-LVS-TUN-模式（IP-封装、跨网段）"><a href="#3-4-LVS-TUN-模式（IP-封装、跨网段）" class="headerlink" title="3.4. LVS TUN 模式（IP 封装、跨网段）"></a>3.4. LVS TUN 模式（IP 封装、跨网段）</h3><p><img src="/images/Java_heart_LoadBalance/clip_image011.jpg" alt="img"> </p><p>①.客户端将请求发往前端的负载均衡器，请求报文源地址是 CIP，目标地址为 VIP。 </p><p>②.负载均衡器收到报文后，发现请求的是在规则里面存在的地址，那么它<u>将在客户端请求报文的首部再封装一层 IP 报文,将源地址改为 DIP，目标地址改为 RIP,并将此包发送给 RS</u>。 </p><p>③.RS 收到请求报文后，会首先拆开第一层封装,然后<u>发现里面还有一层 IP 首部的目标地址是自己 lo 接口上的 VIP</u>，所以会处理次请求报文，并将响应报文通过 lo 接口送给 eth0 网卡直接发送给客户端。 </p><p><strong>注意：需要设置 lo 接口的 VIP 不能在共网上出现。</strong> </p><p><strong>总结：</strong> </p><p>1、TUNNEL 模式<u>必须在所有的 realserver 机器上面绑定 VIP 的 IP 地址</u> </p><p>2、TUNNEL 模式的 vip ——&gt;realserver 的包通信通过 TUNNEL 模式，<u>不管是内网和外网都能通信，所以不需要 lvs vip 跟 realserver 在同一个网段内</u>。 </p><p>3、TUNNEL 模式 realserver 会把 packet 直接发给 client 不会给 lvs 了 </p><p>4、TUNNEL 模式走的隧道模式，所以运维起来比较难，所以一般不用。 </p><p><strong>优点：</strong> </p><p>负载均衡器只负责将请求包分发给后端节点服务器，而 RS 将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，就能处理很巨大的请求量，这种方式，一台负载均衡器能够为很多 RS 进行分发。而且跑在公网上就能进行不同地域的分发。 </p><p><strong>缺点：</strong> </p><p><u>隧道模式的 RS 节点需要合法 IP，这种方式需要所有的服务器支持”IPTunneling”(IP Encapsulation)协议，服务器可能只局限在部分 Linux 系统上</u>。 </p><h3 id="3-5-LVS-FULLNAT-模式"><a href="#3-5-LVS-FULLNAT-模式" class="headerlink" title="3.5. LVS FULLNAT 模式"></a>3.5. LVS FULLNAT 模式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;无论是 DR 还是 NAT 模式，不可避免的都有一个问题：LVS 和 RS 必须在同一个 VLAN 下，否则 LVS 无法作为 RS 的网关。这引发的两个问题是：</p><p>1、同一个 VLAN 的限制导致运维不方便，跨 VLAN 的 RS 无法接入。 </p><p>2、LVS 的水平扩展受到制约。当 RS 水平扩容时，总有一天其上的单点 LVS 会成为瓶颈。 </p><p><strong>Full-NAT 由此而生，解决的是 LVS 和 RS 跨 VLAN 的问题</strong>，而跨 VLAN 问题解决后，LVS 和 RS 不再存在 VLAN 上的从属关系，可以做到多个 LVS 对应多个 RS，解决水平扩容的问题。 </p><p>Full-NAT 相比 NAT 的主要改进是，在 SNAT/DNAT 的基础上，加上另一种转换，转换过程如下： </p><p><img src="/images/Java_heart_LoadBalance/clip_image013.gif" alt="img"> </p><ol><li><p>在包从 LVS 转到 RS 的过程中，源地址从客户端 IP 被替换成了 LVS 的内网 IP。内网 IP 之间可以通过多个交换机跨 VLAN 通信。目标地址从 VIP 修改为 RS IP.</p></li><li><p>当 RS 处理完接受到的包，处理完成后返回时，将目标地址修改为 LVS ip，原地址修改为 RS IP，最终将这个包返回给 LVS 的内网 IP，这一步也不受限于 VLAN。 </p></li><li><p>LVS 收到包后，在 NAT 模式修改源地址的基础上，再把 RS 发来的包中的目标地址从 LVS 内网 IP 改为客户端的 IP,并将原地址修改为 VIP。 </p></li></ol><p>Full-NAT 主要的思想是把网关和其下机器的通信，改为了普通的网络通信，从而解决了跨 VLAN 的问题。采用这种方式，LVS 和 RS 的部署在 VLAN 上将不再有任何限制，大大提高了运维部署的便利性。</p><p><strong>总结</strong> </p><ol><li><p>FULL NAT 模式不需要 LBIP 和 realserver ip 在同一个网段； </p></li><li><p>full nat 因为要更新 sorce ip 所以性能正常比 nat 模式下降 10% 。</p></li></ol><h2 id="4-Keepalive"><a href="#4-Keepalive" class="headerlink" title="4. Keepalive"></a>4. Keepalive</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;keepalive 起初是为 LVS 设计的，专门用来<strong>监控 lvs 各个服务节点的状态</strong>，后来加入了 vrrp 的功能，因此除了 lvs，也可以作为其他服务（nginx，haproxy）的高可用软件。VRRP 是 virtual router redundancy protocal（虚拟路由器冗余协议）的缩写。VRRP 的出现就是为了解决静态路由出现的单点故障，它能够保证网络可以不间断的稳定的运行。所以 keepalive 一方面具有 LVS cluster node healthcheck 功能，另一方面也具有 LVS director failover。 </p><h2 id="5-Nginx-反向代理负载均衡"><a href="#5-Nginx-反向代理负载均衡" class="headerlink" title="5. Nginx 反向代理负载均衡"></a>5. Nginx 反向代理负载均衡</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;普通的负载均衡软件，如LVS，<strong>其实现的功能只是对请求数据包的转发、传递</strong>，从负载均衡下的节点服务器来看，接收到的请求还是来自访问负载均衡器的客户端的真实用户；而反向代理就不一样了，<strong>反向代理服务器在接收访问用户请求后，会代理用户 重新发起请求代理下的节点服务器，最后把数据返回给客户端用户</strong>。在节点服务器看来，访问的节点服务器的客户端用户就是反向代理服务器，而非真实的网站访问用户。</p><h3 id="5-1-upstream-module-和健康检测"><a href="#5-1-upstream-module-和健康检测" class="headerlink" title="5.1. upstream_module 和健康检测"></a>5.1. upstream_module 和健康检测</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>ngx_http_upstream_module 是负载均衡模块，可以实现网站的负载均衡功能即节点的健康检查</strong>，upstream 模块允许 Nginx 定义一组或多组节点服务器组，使用时可通过 proxy_pass 代理方式把网站的请求发送到事先定义好的对应 Upstream 组 的名字上。 </p><table><thead><tr><th><strong>upstream</strong> <strong>模块内参数</strong></th><th><strong>参数说明</strong></th></tr></thead><tbody><tr><td>weight</td><td>服务器权重</td></tr><tr><td>max_fails</td><td>Nginx 尝试连接后端主机失败的此时，这是值是配合 proxy_next_upstream、  fastcgi_next_upstream 和 memcached_next_upstream 这三个参数来使用的。当 Nginx 接收后端服务器返回这三个参数定义的状态码时，会将这个请求转发给正常工作的的后端服务器。如 404、503、503,max_files=1</td></tr><tr><td>fail_timeout</td><td>max_fails  和 fail_timeout 一般会关联使用，如果某台 server 在 fail_timeout 时间内出现了 max_fails 次连接失败，那么 Nginx 会认为其已经挂掉，从而在 fail_timeout 时间内不再去请求它，fail_timeout 默认是 10s，max_fails 默认是 1，即默认情况只要是发生错误就认为服务器挂了，如果将 max_fails 设置为 0，则表示取消这项检查</td></tr><tr><td>backup</td><td>表示当前 server 是备用服务器，只有其它非 backup 后端服务器都挂掉了或很忙才会分配请求给它</td></tr><tr><td>down</td><td>标志服务器永远不可用，可配合 ip_hash 使用</td></tr></tbody></table> <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> lvsServer&#123;  </span><br><span class="line"><span class="attribute">server</span>  <span class="number">191.168.1.11</span> weight=<span class="number">5</span> ;  </span><br><span class="line"><span class="attribute">server</span>  <span class="number">191.168.1.22:82</span>;  </span><br><span class="line"><span class="attribute">server</span> example.com:<span class="number">8080</span>  max_fails=<span class="number">2</span> fail_timeout=<span class="number">10s</span> backup;      <span class="comment">#域名的话需要解析的哦，内网记得 hosts   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-proxy-pass-请求转发"><a href="#5-2-proxy-pass-请求转发" class="headerlink" title="5.2. proxy_pass 请求转发"></a>5.2. proxy_pass 请求转发</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;proxy_pass 指令属于 ngx_http_proxy_module 模块，此模块可以将请求转发到另一台服务器，在实际的反向代理工作中，<strong>会通过 location 功能匹配指定的 URI，然后把接收到服务匹配 URI 的请求通过 proyx_pass 抛给定义好的 upstream 节点池</strong>。 </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /download/ &#123;  <span class="attribute">proxy_pass</span> http://download/vedio/;   &#125;    <span class="comment">#这是前端代理节点的设置</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"></th><th></th></tr></thead><tbody><tr><td align="left">#交给后端 upstream 为 download 的节点</td><td></td></tr><tr><td align="left"><strong>proxy</strong> <strong>模块参数</strong></td><td><strong>说明</strong></td></tr><tr><td align="left">proxy_next_upstream</td><td>什么情况下将请求传递到下一个 upstream</td></tr><tr><td align="left">proxy_limite_rate</td><td>限制从后端服务器读取响应的速率</td></tr><tr><td align="left">proyx_set_header</td><td>设置 http 请求  header 传给后端服务器节点，如：可实现让代理后端的服务器节点获取访问客户端的这是 ip</td></tr><tr><td align="left">client_body_buffer_size</td><td>客户端请求主体缓冲区大小</td></tr><tr><td align="left">proxy_connect_timeout</td><td>代理与后端节点服务器连接的超时时间</td></tr><tr><td align="left">proxy_send_timeout</td><td>后端节点数据回传的超时时间</td></tr><tr><td align="left">proxy_read_timeout</td><td>设置 Nginx 从代理的后端服务器获取信息的时间，表示连接成功建立后，Nginx 等待后端服务器的响应时间</td></tr><tr><td align="left">proxy_buffer_size</td><td>设置缓冲区大小</td></tr><tr><td align="left">proxy_buffers</td><td>设置缓冲区的数量和大小</td></tr><tr><td align="left">proyx_busy_buffers_size</td><td>用于设置系统很忙时可以使用的 proxy_buffers 大小，推荐为 proxy_buffers*2</td></tr><tr><td align="left">proxy_temp_file_write_size</td><td>指定 proxy 缓存临时文件的大小</td></tr></tbody></table><h2 id="6-HAProxy"><a href="#6-HAProxy" class="headerlink" title="6. HAProxy"></a>6. HAProxy</h2><p>参考一下链接：</p><p><a href="https://baike.baidu.com/item/haproxy/5825820?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/haproxy/5825820?fr=aladdin</a></p><p><a href="https://www.jianshu.com/p/baa296770bd5" target="_blank" rel="noopener">https://www.jianshu.com/p/baa296770bd5</a></p><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7. 最后"></a>7. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展&lt;a href=&quot;https://baike.baidu.com/item/网络设备&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网络设备&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/服务器&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;和&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/服务器&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;服务器&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/服务器&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;的&lt;/a&gt;带宽、增加&lt;a href=&quot;https://baike.baidu.com/item/吞吐量&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;吞吐量&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/吞吐量&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;、&lt;/a&gt;加强网络数据处理能力、提高网络的灵活性和可用性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Nginx" scheme="https://quietair.gitee.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(十三)之Cassandra</title>
    <link href="https://quietair.gitee.io/Java_heart_Cassandra/"/>
    <id>https://quietair.gitee.io/Java_heart_Cassandra/</id>
    <published>2020-05-03T06:26:42.000Z</published>
    <updated>2020-05-04T07:04:49.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Apache Cassandra 是高度可扩展的，高性能的分布式 NoSQL 数据库。 Cassandra 旨在处理许多商品服务器上的大量数据，提供高可用性而无需担心单点故障。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Cassandra 具有能够处理大量数据的分布式架构。 数据放置在具有多个复制因子的不同机器上，以获得高可用性，而无需担心单点故障。 </p><a id="more"></a><h2 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2. 数据模型"></a>2. 数据模型</h2><p><strong>Key Space（对应SQL数据库中的database）</strong></p><ol><li>一个 Key Space 中可包含若干个 CF，如同 SQL 数据库中一个 database 可包含多个 table </li></ol><p><strong>Key（对应 SQL 数据库中的主键）</strong> </p><ol start="2"><li>在 Cassandra 中，每一行数据记录是以 key/value 的形式存储的，其中 key 是唯一标识。 </li></ol><p><strong>column（对应 SQL数据库中的列）</strong> </p><ol start="3"><li>Cassandra 中每个 key/value 对中的 value 又称为 column，它是一个三元组，即：name， value 和 timestamp，其中 name 需要是唯一的。 </li></ol><p><strong>super column（SQL数据库不支持）</strong> </p><ol start="4"><li>cassandra 允许 key/value 中的 value 是一个 map(key/value_list)，即某个 column 有多个子列。 </li></ol><p><strong>Standard Column Family（相对应 SQL数据库中的 table）</strong> </p><ol start="5"><li>每个 CF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 column。 </li></ol><p><strong>Super Column Family（SQL 数据库不支持）</strong> </p><ol start="6"><li>每个 SCF 由一系列 row 组成，每个 row 包含一个 key 以及其对应的若干 super column。 </li></ol><h2 id="3-Cassandra一致Hash和虚拟节点"><a href="#3-Cassandra一致Hash和虚拟节点" class="headerlink" title="3. Cassandra一致Hash和虚拟节点"></a>3. Cassandra一致Hash和虚拟节点</h2><p><strong>一致性Hash（多米诺down机）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;为每个节点分配一个 token，根据这个 token 值来决定节点在集群中的位置以及这个节点所存储的数据范围。 </p><p><strong>虚拟节点（down机多节点托管）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于这种方式会造成数据分布不均的问题，<u>在 Cassandra1.2 以后采用了虚拟节点的思想：不需要为每个节点分配 token，把圆环分成更多部分，让每个节点负责多个部分的数据，这样一个节点移除后，它所负责的多个 token 会托管给多个节点处理，这种思想解决了数据分布不均的问题。</u> </p><p><img src="/images/Java_heart_Cassandra/clip_image003.jpg" alt></p><p>&nbsp;&nbsp;&nbsp;&nbsp;如图所示，<strong>上面部分是标准一致性哈希</strong>，每个节点负责圆环中连续的一段，如果 Node2 突然 down 掉，Node2 负责的数据托管给 Node1，即 Node1 负责 EFAB 四段，如果 Node1 里面有很多热点用户产生的数据导致 Node1 已经有点撑不住了，恰巧 B 也是热点用户产生的数据，这样一来 Node1 可能会接着 down 机，Node1down 机，Node6 还 hold 住吗？ </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>下面部分是虚拟节点实现，每个节点不再负责连续部分，且圆环被分为更多的部分。如果 Node2 突然down掉，Node2负责的数据不全是托管给Node1，而是托管给多个节点。而且也保持了一致性哈希的特点。</u> </p><h2 id="4-Gossip协议"><a href="#4-Gossip协议" class="headerlink" title="4. Gossip协议"></a>4. Gossip协议</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Gossip 算法如其名，灵感来自办公室八卦，只要一个人八卦一下，在有限的时间内所有的人都会知道该八卦的信息，这种方式也与病毒传播类似，因此 Gossip 有众多的别名“闲话算法”、 “疫情传播算法”、“病毒感染算法”、“谣言传播算法”。 Gossip 的特点：在一个有界网络中，每个节点都随机地与其他节点通信，经过一番杂乱无章的通信，最终所有节点的状态都会达成一致。因为 Gossip 不要求节点知道所有其他节点，<u>因此又具有去中心化的特点</u>，节点之间完全对等，不需要任何的中心节点。实际上 Gossip 可以用于众多能接受“最终一致性”的领域：失败检测、路由同步、Pub/Sub、动态负载均衡。 </p><p><strong>Gossip节点的通信方式及收敛性</strong> </p><p><strong>Gossip两个节点（A、B）之间存在三种通信方式（push、pull、push&amp;pull）</strong> </p><ol><li><p>push: A 节点将数据(key,value,version)及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据。 </p></li><li><p>pull：A 仅将数据 key,version 推送给 B，B 将本地比 A 新的数据（Key,value,version）推送给 A，A 更新本地。 </p></li><li><p>push/pull：与 pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 更新本地。 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;如果把两个节点数据同步一次定义为一个周期，则在一个周期内，push 需通信 1 次，pull 需 2 次， push/pull 则需 3 次，从效果上来讲，push/pull 最好，理论上一个周期内可以使两个节点完全一致。直观上也感觉，push/pull 的收敛速度是最快的。 </p><p><strong>gossip 的协议和seed list（防止集群分列）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;cassandra 使用称为 gossip 的协议来发现加入 C 集群中的其他节点的位置和状态信息。<u>gossip 进程每秒都在进行，并与至多三个节点交换状态信息</u>。节点交换他们自己和所知道的信息，于是所有的节点很快就能学习到整个集群中的其他节点的信息。gossip 信息有一个相关的版本号，于是在一次gossip信息交换中，旧的信息会被新的信息覆盖重写。要阻止分区进行gossip交流，那么在集群中的所有节点中使用相同的 seed list，<u>种子节点的指定除了启动起 gossip 进程外，没有其他的目的。</u>种子节点不是一个单点故障，他们在集群操作中也没有其他的特殊目的，除了引导节点以外</p><h2 id="5-数据复制"><a href="#5-数据复制" class="headerlink" title="5. 数据复制"></a>5. 数据复制</h2><p><strong>Partitioners</strong>（计算 <strong>primary key token</strong> 的 <strong>hash</strong> 函数） </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Cassandra 中，table 的每行由唯一的 primarykey 标识，<u>partitioner 实际上为一 hash 函数用以计算 primary key 的 token</u>。Cassandra 依据这个 token 值在集群中放置对应的行 </p><p>两种可用的复制策略： </p><p><strong>SimpleStrategy</strong>：<u>仅用于单数据中心</u>， </p><p>&nbsp;&nbsp;&nbsp;&nbsp;将第一个 replica 放在由 partitioner 确定的节点中，其余的 replicas 放在上述节点顺时针方向的后续节点中。</p><p><strong>NetworkTopologyStrategy：可用于较复杂的多数据中心。</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;可以指定在每个数据中心分别存储多少份 replicas。 复制策略在创建 keyspace 时指定，如 </p><p>CREATE KEYSPACE Excelsior WITH REPLICATION = { ‘class’ : ‘SimpleStrategy’,’replication_factor’ : 3 };  </p><p>CREATE KEYSPACE Excalibur WITH REPLICATION = {‘class’ :’NetworkTopologyStrategy’, ‘dc1’ : 3, ‘dc2’ : 2}; </p><h2 id="6-数据写请求和协调者"><a href="#6-数据写请求和协调者" class="headerlink" title="6. 数据写请求和协调者"></a>6. 数据写请求和协调者</h2><p><strong>协调者(coordinator)</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>协调者(coordinator)将 write 请求发送到拥有对应row 的所有 replica 节点</u>，只要节点可用便获取并执行写请求。<u>写一致性级别(write consistency level)确定要有多少个 replica 节点必须返回成功的确认信息。成功意味着数据被正确写入了 commit log 和 memtable。</u> </p><p><img src="/images/Java_heart_Cassandra/image-20200504140944886.png" alt="image"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;其中 dc1、dc2 这些数据中心名称要与 snitch 中配置的名称一致.上面的拓扑策略表示在 dc1 配置 3 个副本,在 dc2 配置 2 个副本 </p><h2 id="7-数据读请求和后台修复"><a href="#7-数据读请求和后台修复" class="headerlink" title="7. 数据读请求和后台修复"></a>7. 数据读请求和后台修复</h2><ol><li><p>协调者首先与一致性级别确定的所有 replica 联系，<u>被联系的节点返回请求的数据</u>。</p></li><li><p>若多个节点被联系，<u>则来自各 replica 的 row 会在内存中作比较，若不一致，则协调者使用含最新数据的 replica 向 client 返回结果</u>。那么比较操作过程中只需要传递时间戳就可以,因为要比较的只是哪个副本数据是最新的。 </p></li><li><p><u>协调者在后台联系和比较来自其余拥有对应 row 的 replica 的数据，若不一致，会向过时的 replica 发写请求用最新的数据进行更新 read repair。</u> </p></li></ol><p><img src="/images/Java_heart_Cassandra/image-20200504141133102.png" alt="image"> </p><h2 id="8-数据存储（CommitLog、MemTable、SSTable）"><a href="#8-数据存储（CommitLog、MemTable、SSTable）" class="headerlink" title="8. 数据存储（CommitLog、MemTable、SSTable）"></a>8. 数据存储（CommitLog、MemTable、SSTable）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;写请求分别到 CommitLog 和 MemTable, 并且 MemTable 的数据会刷写到磁盘 SSTable 上. 除了写数据,还有索引也会保存到磁盘上. </p><p>&nbsp;&nbsp;&nbsp;&nbsp;先将数据写到磁盘中的 commitlog，同时追加到中内存中的数据结构 memtable 。这个时候就会返 回 客 户 端 状 态 ， memtable 内 容 超 出 指 定 容 量 后 会 被 放 进 将 被 刷 入 磁 盘 的 队 列(memtable_flush_queue_size 配置队列长度)。若将被刷入磁盘的数据超出了队列长度，将内存数据刷进磁盘中的 SSTable,之后 commit log 被清空。 </p><p><strong>SSTable文件构成（BloomFilter、index、data、static）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;SSTable 文件有<strong>fileer</strong>（判断数据key是否存在，这里使用了BloomFilter提高效率），<strong>index</strong>（寻找对应 column 值所在 data 文件位置）文件，data（存储真实数据）文件，static（存储和统计 column 和 row 大小）文件。 </p><h2 id="9-二级索引（对要索引的value摘要，生成RowKey）"><a href="#9-二级索引（对要索引的value摘要，生成RowKey）" class="headerlink" title="9. 二级索引（对要索引的value摘要，生成RowKey）"></a>9. 二级索引（对要索引的value摘要，生成RowKey）</h2><p>在 Cassandra 中，数据都是以 Key-value 的形式保存的。 </p><p><img src="/images/Java_heart_Cassandra/image-20200504141356241.png" alt="image"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;KeysIndex 所创建的二级索引也被保存在一张 ColumnFamily 中。<u>在插入数据时，对需要进行索引的value进行摘要，生成独一无二的key，将其作为RowKey保存在索引的ColumnFamily中</u>；同时在 RowKey 上添加一个 Column，将插入数据的 RowKey 作为 name 域的值，value 域则赋空值，timestamp 域则赋为插入数据的时间戳。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果有相同的 value 被索引了，则会在索引 ColumnFamily 中相同的 RowKey 后再添加新的 Column。如果有新的 value 被索引，则会在索引 ColumnFamily 中添加新的 RowKey 以及对应新的 Column。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;当对 value 进行查询时，只需计算该 value 的 RowKey，在索引 ColumnFamily 中的查找该 RowKey，对其 Columns 进行遍历就能得到该 value 所有数据的 RowKey。 </p><h2 id="10-数据读写"><a href="#10-数据读写" class="headerlink" title="10. 数据读写"></a>10. 数据读写</h2><p><strong>数据写入和更新（数据追加）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Cassandra 的设计思路与这些系统不同，无论是 insert 还是 remove 操作，<u>都是在已有的数据后面进行追加，而不修改已有的数据</u>。这种设计称为 Log structured 存储，顾名思义就是系统中的数据是以日志的形式存在的，所以只会将新的数据追加到已有数据的后面。Log structured 存储系统有两个主要优点： </p><p><strong>数据的写和删除效率极高</strong> </p><ul><li>传统的存储系统需要更新元信息和数据，因此磁盘的磁头需要反复移动，这是一个比较耗时的操作，而 Log structured 的系统则是顺序写，可以充分利用文件系统的 cache，所以效率很高。 </li></ul><p><strong>错误恢复简单</strong> </p><ul><li>由于数据本身就是以日志形式保存，老的数据不会被覆盖，所以在设计 journal 的时候不需要考虑 undo，简化了错误恢复。 </li></ul><p><strong>读的复杂度高</strong> </p><ul><li>但是，Log structured 的存储系统也引入了一个重要的问题：读的复杂度和性能。理论上说，读操作需要从后往前扫描数据，以找到某个记录的最新版本。相比传统的存储系统，这是比较耗时的。</li></ul><p>参考：<a href="https://blog.csdn.net/fs1360472174/article/details/55005335" target="_blank" rel="noopener">https://blog.csdn.net/fs1360472174/article/details/55005335</a></p><p><strong>数据删除（column的墓碑）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果一次删除操作在一个节点上失败了（总共 3 个节点，副本为 3， RF=3).整个删除操作仍然被认为成功的（因为有两个节点应答成功，使用 CL.QUORUM 一致性）。接下来如果读发生在该节点上就会变的不明确，因为结果返回是空，还是返回数据，没有办法确定哪一种是正确的。 Cassandra 总是认为返回数据是对的，那就会发生删除的数据又出现了的事情，这些数据可以叫” 僵尸”，并且他们的表现是不可预见的。 </p><p><strong>墓碑</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>删除一个 column 其实只是插入一个关于这个 column 的墓碑（tombstone），并不直接删除原有的 column。</u>该墓碑被作为对该 CF 的一次修改记录在 Memtable 和 SSTable 中。墓碑的内容是删除请求被执行的时间，该时间是接受客户端请求的存储节点在执行该请求时的本地时间（local delete time），称为本地删除时间。需要注意区分本地删除时间和时间戳，每个 CF 修改记录都有一个时间戳，这个时间戳可以理解为该 column 的修改时间，是由客户端给定的。</p><p><strong>垃圾回收compaction</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于被删除的 column 并不会立即被从磁盘中删除，所以系统占用的磁盘空间会越来越大，这就需要有一种垃圾回收的机制，定期删除被标记了墓碑的 column。垃圾回收是在 compaction 的过程中完成的。 </p><p><strong>数据读取（memtable+SStables）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;为了满足读 cassandra 读取的数据是 <u>memtable 中的数据和 SStables 中数据的合并结果</u>。读取 SSTables 中的数据就是查找到具体的哪些的 SSTables 以及数据在这些 SSTables 中的偏移量 (SSTables 是按主键排序后的数据块)。首先如果 <strong>row cache enable</strong> 了话，会检测缓存。缓存命中直接返回数据，没有则查找 <strong>Bloom filter</strong>，查找可能的 SSTable。然后有一层 Partition key cache，找 partition key 的位置。如果有根据找到的 partition 去压缩偏移量映射表找具体的数据块。如果缓存没有，则要经过 <strong>Partition summary,Partition index</strong> 去找 partition key。然后经过压缩偏移量映射表找具体的数据块。 </p><ol><li><p>检查 memtable </p></li><li><p>如果 enabled 了,检查 row cache </p></li><li><p>检查 Bloom filter </p></li><li><p>如果 enable 了,检查 partition key 缓存 </p></li><li><p>如果在 partition key 缓存中找到了 partition key,直接去 compression offset 命中，如果没有，检查 partition summary </p></li><li><p>根据 compression offset map 找到数据位置 </p></li><li><p>从磁盘的 SSTable 中取出数据</p></li></ol><p><img src="/images/Java_heart_Cassandra/image-20200504141924818.png" alt="image"> </p><p><strong>行缓存和键缓存请求流程图</strong> </p><p> <img src="/images/Java_heart_Cassandra/image-20200504142002332.png" alt="image"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>MemTable</strong>：如果 memtable 有目标分区数据，这个数据会被读出来并且和从 SSTables 中读出来的数据进行合并。SSTable 的数据访问如下面所示的步骤。 </p><p><strong>Row Cache（SSTables中频繁被访问的数据）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>在 Cassandra2.2+，它们被存储在堆外内存，使用全新的实现避免造成垃圾回收对 JVM 造成压力</u>。存在在 row cache 的子集数据可以在特定的一段时间内配置一定大小的内存。row cache 使用LRU(least-recently-userd)进行回收在申请内存。<u>存储在 row cache 中的数据是SSTables 中频繁被访问的数据</u>。存储到row cache中后，数据就可以被后续的查询访问。<u>row cache不是写更新。如果写某行了，这行的缓存就会失效，并且不会被继续缓存，直到这行被读到。类似的，如果一个partition更新了，整个partition的cache都会被移除，但目标的数据在row cache中找不到，就会去检查 Bloom filter。</u> </p><p><strong>Bloom Filter（查找数据可能对应的SSTable）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;首先，Cassandra 检查 Bloom filter 去发现哪个 SSTables 中有可能有请求的分区数据。<u>Bloom filter 是存储在堆外内存。每个 SSTable 都有一个关联的 Bloom filter</u>。一个 Bloom filter 可以建立一个 SSTable 没有包含的特定的分区数据。同样也可以找到分区数据存在 SSTable 中的可能性。它可以加速查找 partition key 的查找过程。然而，因为 Bloom filter 是一个概率函数，所以可能会得到错误的结果，并不是所有的 SSTables 都可以被 Bloom filter 识别出是否有数据。如果Bloom filter 不能够查找到 SSTable，Cassandra 会检查 partition key cache。Bloom filter 大小增长很适宜，每 10 亿数据 1~2GB。在极端情况下，可以一个分区一行。都可以很轻松的将数十亿的 entries 存储在单个机器上。Bloom filter 是可以调节的，如果你愿意用内存来换取性能。 </p><p><strong>Partition Key Cache（查找数据可能对应的Partition key）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;partition key 缓存如果开启了，将 partition index 存储在堆外内存。key cache 使用一小块可配置大小的内存。在读的过程中，<u>每个”hit”保存一个检索。如果在 key cache 中找到了 partition key。就直接到 compression offset map 中招对应的块</u>。partition key cache 热启动后工作的更好，相比较冷启动，有很大的性能提升。如果一个节点上的内存非常受限制，可能的话，需要限制保存在 key cache 中的 partition key 数目。如果一个在 key cache 中没有找到 partition key。就会去partition summary中去找。partition key cache 大小是可以配置的，意义就是存储在key cache 中的 partition keys 数目。 </p><p><strong>Partition Summary（内存中存储一些partition index 的样本）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;partition summary 是存储在堆外内存的结构，<u>存储一些 partition index 的样本</u>。如果一个 partition index 包含所有的 partition keys。鉴于一个 partition summary 从每 X 个 keys 中取样，然后将每X个key map到index 文件中。例如，如果一个partition summary设置了20keys 进行取样。它就会存储 SSTable file 开始的一个 key,20th 个 key，以此类推。尽管并不知道 partition key 的具体位置，partition summary 可以缩短找到 partition 数据位置。当找到了 partition key 值可能的范围后，就会去找 partition index。通过配置取样频率，你可以用内存来换取性能，当 partition summary 包含的数据越多，使用的内存越多。可以通过表定义的 <a href="http://docs.datastax.com/en/cql/3.3/cql/cql_reference/cqlCreateTable.html#tabProp" target="_blank" rel="noopener">index </a><a href="http://docs.datastax.com/en/cql/3.3/cql/cql_reference/cqlCreateTable.html#tabProp" target="_blank" rel="noopener">interval</a> <a href="http://docs.datastax.com/en/cql/3.3/cql/cql_reference/cqlCreateTable.html#tabProp" target="_blank" rel="noopener">属</a>性来改变样本频率。固定大小的内存可以通过 <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configCassandra_yaml.html#configCassandra_yaml__index_summary_capacity_in_mb" target="_blank" rel="noopener">index_summary_capacity_in_mb</a> <a href="http://docs.datastax.com/en/cassandra/3.0/cassandra/configuration/configCassandra_yaml.html#configCassandra_yaml__index_summary_capacity_in_mb" target="_blank" rel="noopener">属</a>性来设置，默认是堆大小的 5%。 </p><p><strong>Partition Index（磁盘中）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;partition index 驻扎在磁盘中，索引所有 partition keys 和偏移量的映射。如果 partition summary 已经查到 partition keys 的范围，现在的检索就是根据这个范围值来检索目标 partition key。需要进行单次检索和顺序读。根据找到的信息。然后去 compression offset map 中去找磁盘中有这个数据的块。如果 partition index 必须要被检索，则需要检索两次磁盘去找到目标数据。 </p><p><strong>Compression offset map（磁盘中）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>compression offset map 存储磁盘数据准确位置的指针</u>。存储在堆外内存，可以被 partition key cache 或者 partition index 访问。一旦 compression offset map 识别出来磁盘中的数据位置，就会从正确的 SStable(s)中取出数据。查询就会收到结果集。 </p><h2 id="11-最后"><a href="#11-最后" class="headerlink" title="11. 最后"></a>11. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Apache Cassandra 是高度可扩展的，高性能的分布式 NoSQL 数据库。 Cassandra 旨在处理许多商品服务器上的大量数据，提供高可用性而无需担心单点故障。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Cassandra 具有能够处理大量数据的分布式架构。 数据放置在具有多个复制因子的不同机器上，以获得高可用性，而无需担心单点故障。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Cassandra" scheme="https://quietair.gitee.io/tags/Cassandra/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(十二)之RabbitMQ、MongoDB、设计模式</title>
    <link href="https://quietair.gitee.io/Java_heart_RabbitMQorMongoDB/"/>
    <id>https://quietair.gitee.io/Java_heart_RabbitMQorMongoDB/</id>
    <published>2020-05-01T06:36:58.000Z</published>
    <updated>2020-05-04T07:04:49.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ-架构"><a href="#RabbitMQ-架构" class="headerlink" title="RabbitMQ 架构"></a>RabbitMQ 架构</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。 </p><p><strong>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准</strong>，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p><p><strong>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</strong>具体特点包括：</p><a id="more"></a><ol><li><p><strong>可靠性（Reliability）</strong>：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。 </p></li><li><p>灵活的路由（Flexible Routing）：在消息进入队列之前，通过 Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个 Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</p></li><li><p>消息集群（Clustering）：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</p></li><li><p>高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。 </p></li><li><p>多种协议（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。 </p></li><li><p>多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、 Ruby 等等。 </p></li><li><p><strong>管理界面（Management UI）</strong>:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。 </p></li><li><p><strong>跟踪机制（Tracing）</strong>:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。 </p></li><li><p>插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。 </p></li></ol><h2 id="2-RabbitMQ架构"><a href="#2-RabbitMQ架构" class="headerlink" title="2. RabbitMQ架构"></a>2. RabbitMQ架构</h2><p><img src="/images/Java_heart_RabbitMQorMongoDB/clip_image003.gif" alt="img"> </p><h3 id="2-1-Message"><a href="#2-1-Message" class="headerlink" title="2.1. Message"></a>2.1. Message</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 </p><h3 id="2-2-Publisher"><a href="#2-2-Publisher" class="headerlink" title="2.2. Publisher"></a>2.2. Publisher</h3><ol><li>消息的生产者，也是一个向交换器发布消息的客户端应用程序。 </li></ol><h3 id="2-3-Exchange（将消息路由给队列-）"><a href="#2-3-Exchange（将消息路由给队列-）" class="headerlink" title="2.3.Exchange（将消息路由给队列 ）"></a>2.3.Exchange（将消息路由给队列 ）</h3><ol start="2"><li>交换器，<u>用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</u> </li></ol><h3 id="2-4-Binding（消息队列和交换器之间的关联）"><a href="#2-4-Binding（消息队列和交换器之间的关联）" class="headerlink" title="2.4.Binding（消息队列和交换器之间的关联）"></a>2.4.Binding（消息队列和交换器之间的关联）</h3><ol start="3"><li>绑定，用于<u>消息队列和交换器之间的关联。</u>一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li></ol><h3 id="2-5-Queue"><a href="#2-5-Queue" class="headerlink" title="2.5.Queue"></a>2.5.Queue</h3><ol start="4"><li>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。<u>一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</u> </li></ol><h3 id="2-6-Connection"><a href="#2-6-Connection" class="headerlink" title="2.6.Connection"></a>2.6.Connection</h3><ol start="5"><li>网络连接，比如一个 TCP 连接。</li></ol><h3 id="2-7-Channel"><a href="#2-7-Channel" class="headerlink" title="2.7.Channel"></a>2.7.Channel</h3><ol start="6"><li>信道，<u>多路复用连接中的一条独立的双向数据流通道</u>。信道是建立在真实的 TCP 连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li></ol><h3 id="2-8-Consumer"><a href="#2-8-Consumer" class="headerlink" title="2.8.Consumer"></a>2.8.Consumer</h3><ol start="7"><li>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。 </li></ol><h3 id="2-9-Virtual-Host"><a href="#2-9-Virtual-Host" class="headerlink" title="2.9.Virtual Host"></a>2.9.Virtual Host</h3><ol start="8"><li>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。</li></ol><h3 id="2-10-Broker"><a href="#2-10-Broker" class="headerlink" title="2.10.Broker"></a>2.10.Broker</h3><ol start="9"><li>表示消息队列服务器实体。 </li></ol><h2 id="3-Exchange类型"><a href="#3-Exchange类型" class="headerlink" title="3. Exchange类型"></a>3. Exchange类型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Exchange 分发消息时根据类型的不同分发策略有区别，<strong>目前共四种类型：direct、fanout、topic、headers 。headers 匹配 AMQP 消息的 header 而不是路由键</strong>，此外 headers 交换器和 direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p><h3 id="3-1-Direct-键（routing-key）分布："><a href="#3-1-Direct-键（routing-key）分布：" class="headerlink" title="3.1.Direct 键（routing key）分布："></a>3.1.Direct 键（routing key）分布：</h3><ol><li>Direct：<u>消息中的路由键（routing key）如果和 Binding 中的 binding key 一致</u>， 交换器就将消息发到对应的队列中。它是完全匹配、单播的模式。  </li></ol><p><img src="/images/Java_heart_RabbitMQorMongoDB/clip_image002.gif" alt="img"> </p><h3 id="3-2-Fanout（广播分发）"><a href="#3-2-Fanout（广播分发）" class="headerlink" title="3.2.Fanout（广播分发）"></a>3.2.Fanout（广播分发）</h3><ol start="2"><li>Fanout：每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。 </li></ol><p><img src="/images/Java_heart_RabbitMQorMongoDB/clip_image004.gif" alt="image"> </p><h3 id="3-3-topic-交换器（模式匹配）"><a href="#3-3-topic-交换器（模式匹配）" class="headerlink" title="3.3.topic 交换器（模式匹配）"></a>3.3.topic 交换器（模式匹配）</h3><ol start="3"><li>topic 交换器：<strong>topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上</strong>。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配 0 个或多个单词，匹配不多不少一个单词。 </li></ol><p><img src="/images/Java_heart_RabbitMQorMongoDB/image-20200430142746466.png" alt="image"></p><h1 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h1><h2 id="4-概念"><a href="#4-概念" class="headerlink" title="4. 概念"></a>4. 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;MongoDB 是由 C++语言编写的，是一个基于分布式文件存储的开源数据库系统。<u>在高负载的情况下，添加更多的节点，可以保证服务器性能。</u>MongoDB 旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;MongoDB 将数据存储为一个文档，数据结构由键值(key=&gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。 </p><p><img src="/images/Java_heart_RabbitMQorMongoDB/image-20200430143008754.png" alt="image"></p><h2 id="6-特点"><a href="#6-特点" class="headerlink" title="6. 特点"></a>6. 特点</h2><p>•    MongoDB 是一个<strong>面向文档存储的数据库</strong>，操作起来比较简单和容易。 </p><p>•    你可以在 MongoDB 记录中<strong>设置任何属性的索引</strong> (如：FirstName=”Sameer”,Address=”8 Ga ndhi Road”)来实现更快的排序。 </p><p>•    你可以通过本地或者网络创建数据镜像，这使得 MongoDB 有更强的扩展性。 </p><p>•    如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以<strong>分布在计算机网络中的其他节点上这就是所谓的分片。</strong> </p><p>•    Mongo 支持丰富的查询表达式。查询指令使用 JSON 形式的标记，可轻易查询文档中内嵌的对象及数组。</p><p>•    MongoDb 使用 <strong>update()命令可以实现替换完成的文档</strong>（数据）或者一些指定的数据字段 。 </p><p>•    Mongodb 中的 Map/reduce 主要是用来对数据进行批量处理和聚合操作。 </p><p>•    Map 和 Reduce。Map 函数调用 emit(key,value)遍历集合中所有的记录，将 key 与 value 传给 Reduce 函数进行处理。 </p><p>•    Map 函数和 Reduce 函数是使用 Javascript 编写的，并可以通过 db.runCommand 或 mapre duce 命令来执行 MapReduce 操作。 </p><p>•    <strong>GridFS 是 MongoDB 中的一个内置功能，可以用于存放大量小文件。</strong> </p><p>•    MongoDB 允许在服务端执行脚本，<strong>可以用 Javascript 编写某个函数，直接在服务端执行</strong>，也可以把函数的定义存储在服务端，下次直接调用即可。</p><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ol><li>设计原则 </li><li>工厂方法模式 </li><li>抽象工厂模式 </li><li>单例模式</li><li>建造者模式 </li><li>原型模式 </li><li>适配器模式 </li><li>装饰器模式 </li><li>代理模式 </li><li>外观模式 </li><li>桥接模式 </li><li>组合模式 </li><li>享元模式 </li><li>策略模式 </li><li>模板方法模式 </li><li>观察者模式 </li><li>迭代子模式 </li><li>责任链模式 </li><li>命令模式 </li><li>备忘录模式 </li><li>状态模式 </li><li>访问者模式 </li><li>中介者模式 </li><li>解释器模式</li></ol><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RabbitMQ-架构&quot;&gt;&lt;a href=&quot;#RabbitMQ-架构&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 架构&quot;&gt;&lt;/a&gt;RabbitMQ 架构&lt;/h1&gt;&lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;p&gt;RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准&lt;/strong&gt;，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。&lt;/strong&gt;具体特点包括：&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="RabbitMQ" scheme="https://quietair.gitee.io/tags/RabbitMQ/"/>
    
      <category term="MongoDB" scheme="https://quietair.gitee.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(十一)之Hbase</title>
    <link href="https://quietair.gitee.io/Java_heart_Hbase/"/>
    <id>https://quietair.gitee.io/Java_heart_Hbase/</id>
    <published>2020-04-25T10:25:06.000Z</published>
    <updated>2020-05-04T07:04:49.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;base 是分布式、面向列的开源数据库（其实准确的说是面向列族）。HDFS 为 Hbase 提供可靠的底层数据存储服务，MapReduce 为 Hbase 提供高性能的计算能力，Zookeeper 为 Hbase 提供稳定服务和 Failover 机制，因此我们说 Hbase 是一个通过大量廉价的机器解决海量数据的高速存储和读取的分布式数据库解决方案。</p><a id="more"></a><h2 id="2-列式存储"><a href="#2-列式存储" class="headerlink" title="2. 列式存储"></a>2. 列式存储</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;列方式所带来的重要好处之一就是，由于查询中的选择规则是通过列来定义的，因此整个数据库是自动索引化的。 </p><p><img src="/images/Java_heart_Hbase/biubiubiu.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;这里的列式存储其实说的是列族存储，Hbase 是根据列族来存储数据的。列族下面可以有非常多的列，列族在创建表的时候就必须指定。为了加深对 Hbase 列族的理解，下面是一个简单的关系</p><p><img src="/images/Java_heart_Hbase/clip_image014.gif" alt="img"></p><h2 id="3-Hbase核心概念"><a href="#3-Hbase核心概念" class="headerlink" title="3. Hbase核心概念"></a>3. Hbase核心概念</h2><h3 id="3-1-Column-Family-列族"><a href="#3-1-Column-Family-列族" class="headerlink" title="3.1. Column Family 列族"></a>3.1. Column Family 列族</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Column Family 又叫列族，Hbase 通过列族划分数据的存储，列族下面可以包含任意多的列，实现灵活的数据存取。Hbase 表的创建的时候就必须指定列族。就像关系型数据库创建的时候必须指定具体的列是一样的。Hbase的列族不是越多越好，官方推荐的是列族最好小于或者等于3。我们使用的场景一般是 1 个列族。 </p><h3 id="3-2-Rowkey（Rowkey查询，Rowkey-范围扫描，全表扫描）"><a href="#3-2-Rowkey（Rowkey查询，Rowkey-范围扫描，全表扫描）" class="headerlink" title="3.2. Rowkey（Rowkey查询，Rowkey 范围扫描，全表扫描）"></a>3.2. Rowkey（Rowkey查询，Rowkey 范围扫描，全表扫描）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Rowkey 的概念和 mysql 中的主键是完全一样的，Hbase 使用 Rowkey 来唯一的区分某一行的数据。<strong>Hbase 只支持 3 中查询方式：基于 Rowkey 的单行查询，基于 Rowkey 的范围扫描，全表扫描。</strong> </p><h3 id="3-3-Region-分区"><a href="#3-3-Region-分区" class="headerlink" title="3.3. Region 分区"></a>3.3. Region 分区</h3><ul><li>Region: Region 的概念和关系型数据库的分区或者分片差不多。Hbase 会将一个大表的数据基于 <strong>Rowkey 的不同范围分配到不通的 Region 中</strong>，每个 Region 负责一定范围的数据访问和存储。这样即使是一张巨大的表，由于被切割到不通的 region，访问起来的时延也很低。 </li></ul><h3 id="3-4-TimeStamp-多版本"><a href="#3-4-TimeStamp-多版本" class="headerlink" title="3.4. TimeStamp 多版本"></a>3.4. TimeStamp 多版本</h3><ul><li>TimeStamp 是实现 Hbase 多版本的关键。在 Hbase 中使用不同的 timestame 来标识相同 rowkey 行对应的不通版本的数据。在写入数据的时候，如果用户没有指定对应的timestamp，Hbase 会自动添加一个 timestamp，timestamp 和服务器时间保持一致。<u>在 Hbase 中，相同 rowkey 的数据按照 timestamp 倒序排列。默认查询的是最新的版本，用户可同指定 timestamp 的值来读取旧版本的数据。</u> </li></ul><h2 id="4-Hbase-核心架构"><a href="#4-Hbase-核心架构" class="headerlink" title="4. Hbase 核心架构"></a>4. Hbase 核心架构</h2><p><strong>Hbase 是由 Client、Zookeeper、Master、HRegionServer、HDFS</strong> 等几个组建组成。 </p><p><img src="/images/Java_heart_Hbase/clip_image016.gif" alt="img"> </p><h3 id="4-1-Client"><a href="#4-1-Client" class="headerlink" title="4.1. Client"></a>4.1. Client</h3><ul><li>Client 包含了访问 Hbase 的接口，另外 Client 还维护了对应的 cache 来加速 Hbase 的访问，比如 cache 的.META.元数据的信息。 </li></ul><h3 id="4-2-Zookeeper"><a href="#4-2-Zookeeper" class="headerlink" title="4.2. Zookeeper"></a>4.2. Zookeeper</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Hbase 通过 Zookeeper 来做 master 的高可用、RegionServer 的监控、元数据的入口以及集群配置的维护等工作。具体工作如下：</p><ol><li><p>通过 Zoopkeeper 来保证集群中只有 1 个 master 在运行，如果 master 异常，会通过竞争机制产生新的 master 提供服务 </p></li><li><p>通过 Zoopkeeper 来监控 RegionServer 的状态，当 RegionSevrer 有异常的时候，通过回调的形式通知 Master RegionServer 上下限的信息 </p></li><li><p><u>通过 Zoopkeeper 存储元数据的统一入口地址</u>。 </p></li></ol><h3 id="4-3-Hmaster"><a href="#4-3-Hmaster" class="headerlink" title="4.3. Hmaster"></a>4.3. Hmaster</h3><p>master 节点的主要职责如下： </p><ol><li><p>为 RegionServer 分配 Region </p></li><li><p>维护整个集群的负载均衡 </p></li><li><p>维护集群的元数据信息发现失效的 Region，并将失效的 Region 分配到正常 RegionServer 上当 RegionSever 失效的时候，协调对应 Hlog 的拆分 </p></li></ol><h3 id="4-4-HregionServer"><a href="#4-4-HregionServer" class="headerlink" title="4.4. HregionServer"></a>4.4. HregionServer</h3><p>HregionServer 直接对接用户的读写请求，是真正的“干活”的节点。它的功能概括如下： </p><ol><li><p>管理 master 为其分配的 Region </p></li><li><p>处理来自客户端的读写请求 </p></li><li><p>负责和底层 HDFS 的交互，存储数据到 HDFS </p></li><li><p>负责 Region 变大以后的拆分</p></li><li><p>负责 Storefile 的合并工作</p></li></ol><h3 id="4-5-Region寻址方式（通过-zookeeper-META）"><a href="#4-5-Region寻址方式（通过-zookeeper-META）" class="headerlink" title="4.5.Region寻址方式（通过 zookeeper .META）"></a>4.5.Region寻址方式（通过 zookeeper .META）</h3><p>第 1 步：Client 请求 ZK 获取.META.所在的 RegionServer 的地址。 </p><p>第 2 步：Client 请求.META.所在的 RegionServer 获取访问数据所在的 RegionServer 地址，client 会将.META.的相关信息 cache 下来，以便下一次快速访问。 </p><p>第 3 步：Client 请求数据所在的 RegionServer，获取所需要的数据。 </p><p><img src="/images/Java_heart_Hbase/clip_image018.gif" alt="img"> </p><h3 id="4-6-HDFS"><a href="#4-6-HDFS" class="headerlink" title="4.6.HDFS"></a>4.6.HDFS</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;HDFS 为 Hbase 提供最终的底层数据存储服务，同时为 Hbase 提供高可用（Hlog 存储在HDFS）的支持。  </p><h2 id="5-Hbase的写逻辑"><a href="#5-Hbase的写逻辑" class="headerlink" title="5. Hbase的写逻辑"></a>5. Hbase的写逻辑</h2><h3 id="5-1-Hbase的写入流程"><a href="#5-1-Hbase的写入流程" class="headerlink" title="5.1. Hbase的写入流程"></a>5.1. Hbase的写入流程</h3><p><img src="/images/Java_heart_Hbase/clip_image020.jpg" alt="img"> </p><p>从上图可以看出氛围 3 步骤： </p><p><strong>获取RegionServer</strong></p><p>第 1 步：Client 获取数据写入的 Region 所在的 RegionServer </p><p><strong>请求写Hlog</strong></p><p>第 2 步：请求写 Hlog, Hlog 存储在 HDFS，当 RegionServer 出现异常，需要使用 Hlog 来恢复数据。 </p><p><strong>请求写MemStore</strong></p><p>第 3 步：请求写 MemStore,只有当写 Hlog 和写 MemStore 都成功了才算请求写入完成。 <u>MemStore 后续会逐渐刷到 HDFS 中。</u> </p><h3 id="5-2-MemStore刷盘"><a href="#5-2-MemStore刷盘" class="headerlink" title="5.2. MemStore刷盘"></a>5.2. MemStore刷盘</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;为了提高 Hbase 的写入性能，当写请求写入 MemStore 后，不会立即刷盘。而是会等到一定的时候进行刷盘的操作。具体是哪些场景会触发刷盘的操作呢？总结成如下的几个场景：</p><p><strong>全局内存控制</strong> </p><ol><li>这个全局的参数是控制内存整体的使用情况，当所有 memstore 占整个 heap 的最大比例的时候，会触发刷盘的操作。这个参数是hbase.regionserver.global.memstore.upperLimit，默认为整个 heap 内存的 40%。但这并不意味着全局内存触发的刷盘操作会将所有的 MemStore 都进行输盘，而是通过另外一个参数 hbase.regionserver.global.memstore.lowerLimit 来控制，默认是整个 heap 内存的 35%。当 flush 到所有 memstore 占整个 heap 内存的比率为 35%的时候，就停止刷盘。这么做主要是为了减少刷盘对业务带来的影响，实现平滑系统负载的目的。 </li></ol><p><strong>MemStore达到上限</strong> </p><ol start="2"><li>当 MemStore 的大小达到 hbase.hregion.memstore.flush.size 大小的时候会触发刷盘，默认 128M 大小 </li></ol><p><strong>RegionServer 的Hlog数量达到上限</strong> </p><ol start="3"><li>前面说到 Hlog 为了保证 Hbase 数据的一致性，那么如果 Hlog 太多的话，会导致故障恢复的时间太长，因此 Hbase 会对 Hlog 的最大个数做限制。当达到 Hlog 的最大个数的时候，会强制刷盘。这个参数是 hase.regionserver.max.logs，默认是 32 个。 </li></ol><p><strong>手工触发</strong> </p><ol start="4"><li>可以通过 hbase shell 或者 java api 手工触发 flush 的操作。 </li></ol><p><strong>关闭RegionServer触发</strong> </p><ol start="5"><li>在正常关闭 RegionServer 会触发刷盘的操作，全部数据刷盘后就不需要再使用 Hlog 恢复数据。 </li></ol><p><strong>Region使用HLOG恢复完数据后触发</strong> </p><ol start="6"><li>：当 RegionServer 出现故障的时候，其上面的 Region 会迁移到其他正常的 RegionServer 上，在恢复完 Region 的数据后，会触发刷盘，当刷盘完成后才会提供给业务访问。 </li></ol><h2 id="6-HBase-vs-Cassandra"><a href="#6-HBase-vs-Cassandra" class="headerlink" title="6. HBase vs Cassandra"></a>6. HBase vs Cassandra</h2><table><thead><tr><th></th><th><strong>HBase</strong></th><th><strong>Cassandra</strong></th></tr></thead><tbody><tr><td>语言</td><td>Java</td><td>Java</td></tr><tr><td>出发点</td><td>BigTable</td><td>BigTable and Dynamo</td></tr><tr><td>License</td><td>Apache</td><td>Apache</td></tr><tr><td>Protocol</td><td>HTTP/REST (also Thrift)</td><td>Custom, binary (Thrift)</td></tr><tr><td>数据分布</td><td>表划分为多个 region  存在不同 region   server 上</td><td>改进的一致性哈希（虚拟节点）</td></tr><tr><td>存储目标</td><td>大文件</td><td>小文件</td></tr><tr><td>一致性</td><td>强一致性</td><td>最终一致性，Quorum NRW 策略</td></tr><tr><td>架构</td><td>master/slave</td><td>p2p</td></tr><tr><td>高可用性</td><td>NameNode 是 HDFS 的单点故障点</td><td>P2P 和去中心化设计，不会出现单点故障</td></tr><tr><td>伸缩性</td><td>Region Server 扩容，通过将自身发布到  Master，Master 均匀分布 Region</td><td>扩容需在 Hash Ring 上多个节点间调整数据分布</td></tr><tr><td>读写性能</td><td>数据读写定位可能要通过最多 6 次的网络 RPC，性能较低。</td><td>数据读写定位非常快</td></tr><tr><td>数据冲突处理</td><td>乐观并发控制（optimistic  concurrency control）</td><td>向量时钟</td></tr><tr><td>临时故障处理</td><td>Region Server 宕机，重做 HLog</td><td>数据回传机制：某节点宕机，hash 到该节点的新数据自  动路由到下一节点做 hinted  handoff，源节点恢复后，推送回源节点。</td></tr><tr><td>永久故障恢复</td><td>Region Server  恢复，master 重新给其分配 region</td><td>Merkle 哈希树，通过 Gossip 协议同步 Merkle Tree，维  护集群节点间的数据一致性</td></tr><tr><td>成员通信及错误检测</td><td>Zookeeper</td><td>基于 Gossip</td></tr><tr><td>CAP</td><td>1，强一致性，0 数据丢失。2，可用性低。3，扩容方便。</td><td>1，弱一致性，数据可能丢失。2，可用性高。3，扩容方便。</td></tr></tbody></table><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7. 最后"></a>7. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;base 是分布式、面向列的开源数据库（其实准确的说是面向列族）。HDFS 为 Hbase 提供可靠的底层数据存储服务，MapReduce 为 Hbase 提供高性能的计算能力，Zookeeper 为 Hbase 提供稳定服务和 Failover 机制，因此我们说 Hbase 是一个通过大量廉价的机器解决海量数据的高速存储和读取的分布式数据库解决方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Hbase" scheme="https://quietair.gitee.io/tags/Hbase/"/>
    
      <category term="Zookeeper" scheme="https://quietair.gitee.io/tags/Zookeeper/"/>
    
      <category term="HDFS" scheme="https://quietair.gitee.io/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(十)之Zookeeper、Kafka</title>
    <link href="https://quietair.gitee.io/Java_heart_ZookeeperorKafka/"/>
    <id>https://quietair.gitee.io/Java_heart_ZookeeperorKafka/</id>
    <published>2020-04-18T06:31:37.000Z</published>
    <updated>2020-05-04T07:04:50.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h1><h2 id="1-Zookeeper-概念"><a href="#1-Zookeeper-概念" class="headerlink" title="1. Zookeeper 概念"></a>1. Zookeeper 概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Zookeeper 是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。Zookeeper 提供了一个类似于 Linux 文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。</p><a id="more"></a><h2 id="2-Zookeeper-角色"><a href="#2-Zookeeper-角色" class="headerlink" title="2. Zookeeper 角色"></a>2. Zookeeper 角色</h2><p>Zookeeper 集群是一个基于主从复制的高可用集群，每个服务器承担如下三种角色中的一种</p><h3 id="2-1-Leader"><a href="#2-1-Leader" class="headerlink" title="2.1. Leader"></a>2.1. Leader</h3><ol><li><p>一个 Zookeeper 集群同一时间只会有一个实际工作的 Leader，它会发起并维护与各 Follwer 及 Observer 间的心跳。 </p></li><li><p>所有的写操作必须要通过 Leader 完成再由 Leader 将写操作广播给其它服务器。只要有超过半数节点（不包括 observeer 节点）写入成功，该写请求就会被提交（类 2PC 协议）。 </p></li></ol><h3 id="2-2-Follower"><a href="#2-2-Follower" class="headerlink" title="2.2. Follower"></a>2.2. Follower</h3><ol><li><p>一个 Zookeeper 集群可能同时存在多个 Follower，它会响应 Leader 的心跳， </p></li><li><p>Follower 可直接处理并返回客户端的读请求，同时会将写请求转发给 Leader 处理， </p></li><li><p>并且负责在 Leader 处理写请求时对请求进行投票。 </p></li></ol><h3 id="2-3-Observer"><a href="#2-3-Observer" class="headerlink" title="2.3. Observer"></a>2.3. Observer</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;角色与 Follower 类似，但是无投票权。Zookeeper 需保证高可用和强一致性，为了支持更多的客户端，需要增加更多 Server；<u>Server 增多，投票阶段延迟增大，影响性能；引入 Observer， Observer 不参与投票； Observers 接受客户端的连接，并将写请求转发给 leader 节点；</u> 加入更多 Observer 节点，提高伸缩性，同时不影响吞吐率。 </p><p><img src="/images/Java_heart_ZookeeperorKafka/clip_image003.gif" alt="img"> </p><h3 id="2-4-ZAB-协议"><a href="#2-4-ZAB-协议" class="headerlink" title="2.4. ZAB 协议"></a>2.4. ZAB 协议</h3><p><strong>事务编号 Zxid（事务请求计数器+ epoch）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 ZAB ( ZooKeeper Atomic Broadcast , ZooKeeper 原子消息广播协议） 协议的事务编号 Zxid 设计中，Zxid 是一个 64 位的数字，其中低 32 位是一个简单的单调递增的计数器，<u>针对客户端每一个事务请求，计数器加 1；</u>而高 32 位则代表 Leader 周期 epoch 的编号，<u>每个当选产生一个新的 Leader 服务器，就会从这个 Leader 服务器上取出其本地日志中最大事务的 ZXID，并从中读取 epoch 值，然后加 1，以此作为新的 epoch，</u>并将低 32 位从 0 开始计数。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Zxid（Transaction id）类似于 RDBMS 中的事务 ID，用于标识一次更新操作的 Proposal（提议） ID。为了保证顺序性，该 zkid 必须单调递增。 </p><p><strong>epoch</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;epoch：可以理解为当前集群所处的年代或者周期，每个 leader 就像皇帝，都有自己的年号，所以每次改朝换代，leader 变更之后，都会在前一个年代的基础上加 1。这样就算<u>旧的 leader 崩溃恢复之后，也没有人听他的了，因为 follower 只听从当前年代的 leader 的命令。</u> </p><p><strong>Zab协议有两种模式-恢复模式（选主）、广播模式（同步）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Zab协议有两种模式，它们分别是<u>恢复模式（选主）和广播模式（同步）</u>。当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。 </p><p><strong>ZAB协议4阶段</strong> </p><p><strong>Leader election（选举阶段-选出准Leader）</strong> </p><ol><li>Leader election（选举阶段）：节点在一开始都处于选举阶段，只要有一个节点得到超半数节点的票数，它就可以当选准 leader。只有到达 广播阶段（broadcast） 准 leader 才会成为真正的 leader。这一阶段的目的是就是为了选出一个准 leader，然后进入下一个阶段。 </li></ol><p><strong>Discovery（发现阶段-接受提议、生成epoch、接受epoch）</strong> </p><ol start="2"><li>Discovery（发现阶段）：在这个阶段，followers 跟准 leader 进行通信，同步 followers 最近接收的事务提议。这个一阶段的主要目的是发现当前大多数节点接收的最新提议，并且准 leader 生成新的 epoch，让 followers 接受，更新它们的 accepted Epoch 一个 follower 只会连接一个 leader，如果有一个节点 f 认为另一个 follower p 是 leader，f 在尝试连接 p 时会被拒绝，f 被拒绝之后，就会进入重新选举阶段。 </li></ol><p><strong>Synchronization（同步阶段-同步follower副本）</strong> </p><ol start="3"><li>Synchronization（同步阶段）：同步阶段主要是利用 leader 前一阶段获得的最新提议历史，同步集群中所有的副本。只有当 大多数节点都同步完成，准 leader 才会成为真正的 leader。 follower 只会接收 zxid 比自己的 lastZxid 大的提议。 </li></ol><p><strong>Broadcast（广播阶段-leader消息广播）</strong> </p><ol start="4"><li>Broadcast（广播阶段）：到了这个阶段，Zookeeper 集群才能正式对外提供事务服务，并且 leader 可以进行消息广播。同时如果有新的节点加入，还需要对新节点进行同步。 </li></ol><p>ZAB 提交事务并不像 2PC 一样需要全部 follower 都 ACK，只需要得到超过半数的节点的 ACK 就可以了。 </p><p><strong>ZAB协议JAVA 实现（FLE-发现阶段和同步合并为 Recovery Phase（恢复阶段））</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;协议的 Java 版本实现跟上面的定义有些不同，选举阶段使用的是 Fast Leader Election（FLE），它包含了 选举的发现职责。因为 FLE 会选举拥有最新提议历史的节点作为 leader，这样就省去了发现最新提议的步骤。实际的实现将 发现阶段 和 同步合并为 Recovery Phase（恢复阶段）。所以，ZAB 的实现只有三个阶段：Fast Leader Election；Recovery Phase；Broadcast Phase。 </p><h3 id="2-5-投票机制"><a href="#2-5-投票机制" class="headerlink" title="2.5. 投票机制"></a>2.5. 投票机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>每个 sever 首先给自己投票，然后用自己的选票和其他 sever 选票对比，权重大的胜出，使用权重较大的更新自身选票箱。</u>具体选举过程如下：</p><ol><li><p>每个 Server 启动以后<strong>都询问其它的 Server 它要投票给谁</strong>。对于其他 server 的询问， server 每次根据自己的状态都回复自己推荐的 leader 的 id 和上一次处理事务的 zxid（系统启动时每个 server 都会推荐自己） </p></li><li><p>收到所有 Server 回复以后，就<strong>计算出 zxid 最大的哪个 Server</strong>，并将这个 Server 相关信息设置成下一次要投票的 Server。 </p></li><li><p>计算这过程中<strong>获得票数最多的的 sever 为获胜者</strong>，如果获胜者的票数超过半数，则改 server 被选为 leader。否则，继续这个过程，直到 leader 被选举出来  </p></li><li><p>leader 就会开始等待 server 连接</p></li><li><p>Follower 连接 leader，将最大的 zxid 发送给 leader </p></li><li><p>Leader 根据 follower 的 zxid 确定同步点，至此选举阶段完成。 </p></li><li><p>选举阶段完成 Leader 同步后通知 follower 已经成为 uptodate 状态 </p></li><li><p>Follower 收到 uptodate 消息后，又可以重新接受 client 的请求进行服务了 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;目前有 5 台服务器，每台服务器均没有数据，它们的编号分别是 1,2,3,4,5,按编号依次启动，它们的选择举过程如下： </p><ol><li><p>服务器 1 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器 1 的状态一直属于 Looking。 </p></li><li><p>服务器 2 启动，给自己投票，同时与之前启动的服务器 1 交换结果，由于服务器 2 的编号大所以服务器 2 胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是LOOKING。 </p></li><li><p>服务器 3 启动，给自己投票，同时与之前启动的服务器 1,2 交换信息，由于服务器 3 的编号最大所以服务器 3 胜出，此时投票数正好大于半数，所以服务器 3 成为领导者，服务器1,2 成为小弟。</p></li><li><p>服务器 4 启动，给自己投票，同时与之前启动的服务器 1,2,3 交换信息，尽管服务器 4 的编号大，但之前服务器 3 已经胜出，所以服务器 4 只能成为小弟。 </p></li><li><p>服务器 5 启动，后面的逻辑同服务器 4 成为小弟。 </p></li></ol><h2 id="3-Zookeeper工作原理（原子广播）"><a href="#3-Zookeeper工作原理（原子广播）" class="headerlink" title="3. Zookeeper工作原理（原子广播）"></a>3. Zookeeper工作原理（原子广播）</h2><ol><li><p><strong>Zookeeper 的核心是原子广播</strong>，这个机制保证了各个 server 之间的同步。实现这个机制的协议叫做 Zab 协议。Zab 协议有两种模式，它们分别是恢复模式和广播模式。 </p></li><li><p>当服务启动或者在领导者崩溃后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 server 的完成了和 leader 的状态同步以后，恢复模式就结束了。</p></li><li><p>状态同步保证了 leader 和 server 具有相同的系统状态 </p></li><li><p><strong>一旦 leader 已经和多数的 follower 进行了状态同步后，他就可以开始广播消息了</strong>，即进入广播状态。这时候当一个 server 加入 zookeeper 服务中，它会在恢复模式下启动，发现 leader，并和 leader 进行状态同步。待到同步结束，它也参与消息广播。Zookeeper 服务一直维持在 Broadcast 状态，直到 leader 崩溃了或者 leader 失去了大部分的 followers 支持。 </p></li><li><p>广播模式需要保证 proposal 被按顺序处理，因此 zk 采用了递增的事务 id 号(zxid)来保证。所有的提议(proposal)都在被提出的时候加上了 zxid。 </p></li><li><p>实现中 zxid 是一个 64 为的数字，它高 32 位是 epoch 用来标识 leader 关系是否改变，每次一个 leader 被选出来，它都会有一个新的 epoch。低 32 位是个递增计数。 </p></li><li><p>当 leader 崩溃或者 leader 失去大多数的 follower，这时候 zk 进入恢复模式，恢复模式需要重新选举出一个新的 leader，让所有的 server 都恢复到一个正确的状态。 </p></li></ol><h2 id="4-Znode有四种形式的目录节点"><a href="#4-Znode有四种形式的目录节点" class="headerlink" title="4. Znode有四种形式的目录节点"></a>4. Znode有四种形式的目录节点</h2><ol><li><p>PERSISTENT：持久的节点。 </p></li><li><p>EPHEMERAL：暂时的节点。 </p></li><li><p>PERSISTENT_SEQUENTIAL：持久化顺序编号目录节点。 </p></li><li><p>EPHEMERAL_SEQUENTIAL：暂时化顺序编号目录节点。 </p></li></ol><h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="5-Kafka概念"><a href="#5-Kafka概念" class="headerlink" title="5. Kafka概念"></a>5. Kafka概念</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用 Scala 语言编写，目前是 Apache 的开源项目。 </p><ol><li><p>broker：Kafka 服务器，负责消息存储和转发</p></li><li><p>topic：消息类别，Kafka 按照 topic 来分类消息 </p></li><li><p>partition：topic 的分区，一个 topic 可以包含多个 partition，topic 消息保存在各个 partition 上 </p></li><li><p>offset：消息在日志中的位置，可以理解是消息在 partition 上的偏移量，也是代表该消息的唯一序号 </p></li><li><p>Producer：消息生产者 </p></li><li><p>Consumer：消息消费者 </p></li><li><p>Consumer Group：消费者分组，每个 Consumer 必须属于一个 group </p></li><li><p>Zookeeper：保存着集群 broker、topic、partition 等 meta 数据；另外，还负责 broker 故障发现，partition leader 选举，负载均衡等功能 </p></li></ol><p><img src="/images/Java_heart_ZookeeperorKafka/clip_image005.gif" alt="img"> </p><h2 id="6-Kafka-数据存储设计"><a href="#6-Kafka-数据存储设计" class="headerlink" title="6. Kafka 数据存储设计"></a>6. Kafka 数据存储设计</h2><h3 id="6-1-partition的数据文件（offset，MessageSize，data）"><a href="#6-1-partition的数据文件（offset，MessageSize，data）" class="headerlink" title="6.1. partition的数据文件（offset，MessageSize，data）"></a>6.1. partition的数据文件（offset，MessageSize，data）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;partition中的每条Message包含了以下三个属性：offset，MessageSize，data，其中<u>offset表示 Message 在这个 partition 中的偏移量，offset 不是该 Message 在 partition 数据文件中的实际存储位置，而是逻辑上一个值</u>，它唯一确定了partition中的一条Message，可以认为offset是 partition 中 Message 的 id；MessageSize 表示消息内容 data 的大小；data 为 Message 的具体内容。 </p><h3 id="6-2-数据文件分段-segment（顺序读写、分段命令、二分查找）"><a href="#6-2-数据文件分段-segment（顺序读写、分段命令、二分查找）" class="headerlink" title="6.2. 数据文件分段 segment（顺序读写、分段命令、二分查找）"></a>6.2. 数据文件分段 segment（顺序读写、分段命令、二分查找）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;partition 物理上由多个 segment 文件组成，每个 segment 大小相等，顺序读写。每个 segment 数据文件以该段中最小的 offset 命名，文件扩展名为.log。这样在查找指定 offset 的 Message 的时候，用二分查找就可以定位到该 Message 在哪个 segment 数据文件中。 </p><h3 id="6-3-数据文件索引（分段索引、稀疏存储）"><a href="#6-3-数据文件索引（分段索引、稀疏存储）" class="headerlink" title="6.3. 数据文件索引（分段索引、稀疏存储）"></a>6.3. 数据文件索引（分段索引、稀疏存储）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Kafka 为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩展名为.index。index 文件中并没有为数据文件中的每条 Message 建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。</p><p><img src="/images/Java_heart_ZookeeperorKafka/clip_image007.gif" alt="img"> </p><h2 id="7-生产者设计"><a href="#7-生产者设计" class="headerlink" title="7. 生产者设计"></a>7. 生产者设计</h2><h3 id="7-1-负载均衡（partition-会均衡分布到不同-broker-上）"><a href="#7-1-负载均衡（partition-会均衡分布到不同-broker-上）" class="headerlink" title="7.1. 负载均衡（partition 会均衡分布到不同 broker 上）"></a>7.1. 负载均衡（partition 会均衡分布到不同 broker 上）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;由于消息 topic 由多个 partition 组成，且 <strong>partition 会均衡分布到不同 broker 上，因此，为了有效利用 broker 集群的性能，提高消息的吞吐量</strong>，producer 可以通过随机或者 hash 等方式，将消息平均发送到多个 partition 上，以实现负载均衡。</p><p><img src="/images/Java_heart_ZookeeperorKafka/clip_image009.gif" alt="img"> </p><h3 id="7-2-批量发送"><a href="#7-2-批量发送" class="headerlink" title="7.2. 批量发送"></a>7.2. 批量发送</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是提高消息吞吐量重要的方式，Producer 端可以在内存中合并多条消息后，<strong>以一次请求的方式发送了批量的消息给 broker</strong>，从而大大减少 broker 存储消息的 IO 操作次数。但也一定程度上影响了消息的实时性，相当于以时延代价，换取更好的吞吐量。 </p><h3 id="7-3-压缩（GZIP或-Snappy）"><a href="#7-3-压缩（GZIP或-Snappy）" class="headerlink" title="7.3. 压缩（GZIP或 Snappy）"></a>7.3. 压缩（GZIP或 Snappy）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Producer 端可以通过 GZIP 或 Snappy 格式对消息集合进行压缩。Producer 端进行压缩之后，在 Consumer 端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大数据处理上，瓶颈往往体现在网络上而不是 CPU（压缩和解压会耗掉部分 CPU 资源）。 </p><h2 id="8-消费者设计"><a href="#8-消费者设计" class="headerlink" title="8. 消费者设计"></a>8. 消费者设计</h2><p><img src="/images/Java_heart_ZookeeperorKafka/clip_image011.jpg" alt="img"> </p><h3 id="8-1-Consumer-Group"><a href="#8-1-Consumer-Group" class="headerlink" title="8.1. Consumer Group"></a>8.1. Consumer Group</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;同一 Consumer Group 中的多个 Consumer 实例，不同时消费同一个 partition，等效于队列模式。partition 内消息是有序的，Consumer 通过 pull 方式消费消息。Kafka 不删除已消费的消息 对于 partition，顺序读写磁盘数据，以时间复杂度 O(1)方式提供消息持久化能力。 </p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Zookeeper&quot;&gt;&lt;a href=&quot;#Zookeeper&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper&quot;&gt;&lt;/a&gt;Zookeeper&lt;/h1&gt;&lt;h2 id=&quot;1-Zookeeper-概念&quot;&gt;&lt;a href=&quot;#1-Zookeeper-概念&quot; class=&quot;headerlink&quot; title=&quot;1. Zookeeper 概念&quot;&gt;&lt;/a&gt;1. Zookeeper 概念&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Zookeeper 是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。Zookeeper 提供了一个类似于 Linux 文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Zookeeper" scheme="https://quietair.gitee.io/tags/Zookeeper/"/>
    
      <category term="Kafka" scheme="https://quietair.gitee.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(九)之日志</title>
    <link href="https://quietair.gitee.io/Java_heart_log/"/>
    <id>https://quietair.gitee.io/Java_heart_log/</id>
    <published>2020-04-12T06:31:37.000Z</published>
    <updated>2020-05-04T07:04:49.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Slf4j"><a href="#1-Slf4j" class="headerlink" title="1. Slf4j"></a>1. Slf4j</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带的 java.util.logging.Logger 等。 </p><a id="more"></a><h2 id="2-Log4j"><a href="#2-Log4j" class="headerlink" title="2. Log4j"></a>2. Log4j</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Log4j 是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI 组件，甚至是套接口服务器、NT 的事件记录器、UNIX Syslog 守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p><p>Log4j由三个重要的组成构成：日志记录器(Loggers)，输出端(Appenders)和日志格式化器(Layout)。 </p><ol><li><p>Logger：控制要启用或禁用哪些日志记录语句，并对日志信息进行级别限制</p></li><li><p>Appenders : 指定了日志将打印到控制台还是文件中</p></li><li><p>Layout : 控制日志信息的显示格式</p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;Log4j 中将要输出的 Log 信息定义了 5 种级别，依次为 DEBUG、INFO、WARN、ERROR 和 FATAL，当输出时，只有级别高过配置中规定的 级别的信息才能真正的输出，这样就很方便的来配置不同情况下要输出的内容，而不需要更改代码。 </p><h2 id="3-LogBack"><a href="#3-LogBack" class="headerlink" title="3. LogBack"></a>3. LogBack</h2><p>简单地说，Logback 是一个 Java 领域的日志框架。它被认为是 Log4J 的继承人。 </p><p>Logback 主要由三个模块组成：<strong>logback-core，logback-classic。logback-access</strong> </p><p>logback-core 是其它模块的基础设施，其它模块基于它构建，显然，logback-core 提供了一些关键的通用机制。 </p><p>logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单日志门面 SLF4J； </p><p>logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与 </p><p>HTTP 访问相关的功能。 </p><h3 id="3-1-Logback优点"><a href="#3-1-Logback优点" class="headerlink" title="3.1. Logback优点"></a>3.1. Logback优点</h3><ul><li>同样的代码路径，Logback 执行更快 </li><li>更充分的测试</li><li>原生实现了 SLF4J API（Log4J 还需要有一个中间转换层） </li><li>内容更丰富的文档</li><li>支持 XML 或者 Groovy 方式配置 </li><li>配置文件自动热加载</li><li>从 IO 错误中优雅恢复 </li><li>自动删除日志归档</li><li>自动压缩日志成为归档文件</li><li>支持 Prudent 模式，使多个 JVM 进程能记录同一个日志文件 </li><li>支持配置文件中加入条件判断来适应不同的环境</li><li>更强大的过滤器</li><li>支持 SiftingAppender（可筛选 Appender） </li><li>异常栈信息带有包信息 </li></ul><h2 id="4-ELk"><a href="#4-ELk" class="headerlink" title="4. ELk"></a>4. ELk</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;ELK 是软件集合 Elasticsearch、Logstash、Kibana 的简称，由这三个软件及其相关的组件可以打造大规模日志实时处理系统。</p><ul><li>Elasticsearch 是一个基于 Lucene 的、支持全文索引的分布式存储和索引引擎，主要负责将日志索引并存储起来，方便业务方检索查询。 </li><li>Logstash 是一个日志收集、过滤、转发的中间件，主要负责将各条业务线的各类日志统一收集、过滤后，转发给 Elasticsearch 进行下一步处理。 </li><li>Kibana 是一个可视化工具，主要负责查询 Elasticsearch 的数据并以可视化的方式展现给业务方，比如各类饼图、直方图、区域图等。 </li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;( 1.Filebeat; 2.Filebeat; 3.Filebeat ) –&gt; Redis –&gt; Logstash –&gt; Elasticsearch  –&gt; Kibana </p><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Slf4j&quot;&gt;&lt;a href=&quot;#1-Slf4j&quot; class=&quot;headerlink&quot; title=&quot;1. Slf4j&quot;&gt;&lt;/a&gt;1. Slf4j&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;slf4j 的全称是 Simple Loging Facade For Java，即它仅仅是一个为 Java 程序提供日志输出的统一接口，并不是一个具体的日志实现方案，就比如 JDBC 一样，只是一种规则而已。所以单独的 slf4j 是不能工作的，必须搭配其他具体的日志实现方案，比如 apache 的 org.apache.log4j.Logger，jdk 自带的 java.util.logging.Logger 等。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(八)之网络</title>
    <link href="https://quietair.gitee.io/Java_heart_network/"/>
    <id>https://quietair.gitee.io/Java_heart_network/</id>
    <published>2020-04-11T05:24:47.000Z</published>
    <updated>2020-05-04T07:04:49.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-网络7层架构"><a href="#1-网络7层架构" class="headerlink" title="1. 网络7层架构"></a>1. 网络7层架构</h2><p><strong>7 层模型主要包括：</strong> </p><ol><li>物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为 1、0，也就是我们常说的<strong>模数转换与数模转换</strong>）。这一层的数据叫做比特。</li></ol><a id="more"></a><ol start="2"><li><p>数据链路层：主要将从物理层接收的数据进行 <strong>MAC 地址（网卡的地址）的封装与解封装</strong>。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。  </p></li><li><p>网络层：主要将从下层接收到的数据进行 <strong>IP 地址（例 192.168.0.1)的封装与解封装</strong>。在这一层工作的设备是<strong>路由器</strong>，常把这一层的数据叫做数据包。 </p></li><li><p>传输层：定义了一些<strong>传输数据的协议和端口号</strong>（WWW 端口 80 等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段进行传输，到达目的地址后在进行重组。常常把这一层数据叫做段。  </p></li><li><p>会话层：通过传输层（端口号：传输端口与接收端口）<strong>建立数据传输的通路</strong>。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）  </p></li><li><p>表示层：主要是进行对接收的数据进行<strong>解释、加密与解密、压缩与解压缩</strong>等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））  </p></li><li><p>应用层：主要是一些终端的应用，比如说FTP（各种文件下载），WEB（IE浏览），QQ之类的（你 就把它理解成我们在电脑屏幕上可以看到的东西．就 是终端应用）。</p></li></ol><p><img src="/images/Java_heart_network/image-01.png" alt="image-20200415130931301"></p><h2 id="2-TCP-IP原理"><a href="#2-TCP-IP原理" class="headerlink" title="2. TCP/IP原理"></a>2. TCP/IP原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族。从协议分层模型方面来讲，TCP/IP 由四个层次组成：网络接口层、网络层、传输层、应用层。</p><p><img src="/images/Java_heart_network/clip_image002.jpg" alt="img"> </p><h3 id="2-1-网络访问层-Network-Access-Layer"><a href="#2-1-网络访问层-Network-Access-Layer" class="headerlink" title="2.1. 网络访问层(Network Access Layer)"></a>2.1. 网络访问层(Network Access Layer)</h3><ol><li>网络访问层(Network Access Layer)在 TCP/IP 参考模型中并没有详细描述，只是指出<strong>主机必须使用某种协议与网络相连</strong>。 </li></ol><h3 id="2-2-网络层-Internet-Layer"><a href="#2-2-网络层-Internet-Layer" class="headerlink" title="2.2. 网络层(Internet Layer)"></a>2.2. 网络层(Internet Layer)</h3><ol start="2"><li>网络层(Internet Layer)是整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标。这些分组可能经由不同的网络，到达的顺序和发送的顺序也可能不同。高层如果需要顺序收发，那么就必须自行处理对分组的排序。<strong>互联网层使用因特网协议(IP，Internet Protocol)</strong>。 </li></ol><h3 id="2-3-传输层-Tramsport-Layer-TCP-UDP"><a href="#2-3-传输层-Tramsport-Layer-TCP-UDP" class="headerlink" title="2.3. 传输层(Tramsport Layer-TCP/UDP)"></a>2.3. 传输层(Tramsport Layer-TCP/UDP)</h3><ol start="3"><li>传输层(Tramsport Layer)使源端和目的端机器上的对等实体可以进行会话。<strong>在这一层定义了两个端到端的协议</strong>：传输控制协议(TCP，Transmission Control Protocol)和用户数据报协议(UDP，User Datagram Protocol)。<strong>TCP</strong> 是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。<strong>UDP</strong> 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。 </li></ol><h3 id="2-4-应用层-Application-Layer"><a href="#2-4-应用层-Application-Layer" class="headerlink" title="2.4. 应用层(Application Layer)"></a>2.4. 应用层(Application Layer)</h3><ol start="4"><li>应用层(Application Layer)包含所有的高层协议，包括：<u>虚拟终端协议(TELNET， TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。</u> </li></ol><h2 id="3-TCP-三次握手-四次挥手"><a href="#3-TCP-三次握手-四次挥手" class="headerlink" title="3. TCP 三次握手/四次挥手"></a>3. TCP 三次握手/四次挥手</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP 在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般称为“四次挥手”。 </p><h3 id="3-1-数据包说明"><a href="#3-1-数据包说明" class="headerlink" title="3.1. 数据包说明"></a>3.1. 数据包说明</h3><ol><li><p>源端口号（ 16 位）：它（连同源主机 IP 地址）标识源主机的一个应用进程。 </p></li><li><p>目的端口号（ 16 位）：它（连同目的主机 IP 地址）标识目的主机的一个应用进程。这两个值<strong>加上 IP 报头中的源主机 IP 地址和目的主机 IP 地址唯一确定一个 TCP 连接</strong>。 </p></li><li><p>顺序号 seq（ 32 位）：<strong>用来标识从 TCP 源端向 TCP 目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号</strong>。如果将字节流看作在两个应用程序间的单向流动，则 <strong>TCP 用顺序号对每个字节进行计数</strong>。序号是 32bit 的无符号数，<strong>序号到达 2 的 32 次方 － 1 后又从 0 开始。当建立一个新的连接时， SYN 标志变 1</strong> ，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN （ Initial Sequence Number ）。 </p></li><li><p>确认号 ack（ 32 位）：<strong>包含发送确认的一端所期望收到的下一个顺序号</strong>。因此，确认序号应当是上次已成功收到数据字节顺序号加 1 。<strong>只有 ACK 标志为 1 时确认序号字段才有效</strong>。 TCP 为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。</p></li><li><p>TCP 报头长度（ 4 位）：给出报头中 32bit 字的数目，<strong>它实际上指明数据从哪里开始</strong>。需要这个值是因为任选字段的长度是可变的。这个字段占 4bit ，因此 TCP 最多有 60 字节的首部。然而，没有任选字段，正常的长度是 20 字节。 </p></li><li><p>保留位（ 6 位）：保留给将来使用，目前必须置为 0 。 </p></li><li><p><strong>控制位（ control flags ， 6 位）：在 TCP 报头中有 6 个标志比特，它们中的多个可同时被设置为 1 。依次为：</strong> </p></li></ol><ul><li><p>URG ：为 1 表示紧急指针有效，为 0 则忽略紧急指针值。 </p></li><li><p>ACK ：为 1 表示确认号有效，为 0 表示报文中不包含确认信息，忽略确认号字段。 </p></li><li><p>PSH ：为 1 表示是带有 PUSH 标志的数据，<strong>指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满</strong>。 </p></li><li><p>RST ：<strong>用于复位由于主机崩溃或其他原因而出现错误的连接</strong>。它还可以用于拒绝非法的报文段和拒绝连接请求。一般情况下，如果收到一个 RST 为 1 的报文，那么一定发生了某些问题。 </p></li><li><p>SYN ：同步序号，<strong>为 1 表示连接请求</strong>，用于建立连接和使顺序号同步（ synchronize ）。 </p></li><li><p>FIN ：<strong>用于释放连接</strong>，为 1 表示发送方已经没有数据发送了，即关闭本方数据流。</p></li></ul><ol start="8"><li><p>窗口大小（ 16 位）：数据字节数，表示从确认号开始，本报文的源方可以接收的字节数，即源方接收窗口大小。窗口大小是一个 16bit 字段，因而窗口大小最大为 65535 字节。 </p></li><li><p>校验和（ 16 位）：此校验和是对整个的 TCP 报文段，<strong>包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得</strong>。这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证。 </p></li><li><p>紧急指针（ 16 位）：只有当 URG 标志置 1 时紧急指针才有效。<strong>TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式</strong>。</p></li><li><p>选项：最常见的可选字段是最长报文大小，又称为 MSS(Maximum Segment Size) 。每个连接方通常都在通信的第一个报文段（为建立连接而设置 SYN 标志的那个段）中指明这个选项，它<strong>指明本端所能接收的最大长度的报文段</strong>。选项长度不一定是 32 位字的整数倍，所以要加填充位，使得报头长度成为整字数。 </p></li><li><p>数据： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP 首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。</p></li></ol><p><img src="/images/Java_heart_network/clip_image004.jpg" alt="img"> </p><h3 id="3-2-三次握手"><a href="#3-2-三次握手" class="headerlink" title="3.2. 三次握手"></a>3.2. 三次握手</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第一次握手：主机 A 发送位码为 <strong>syn＝1</strong>,随机产生 <strong>seq number=1234567</strong> 的数据包到服务器，主机 B 由 SYN=1 知道，A 要求建立联机； </p><p>&nbsp;&nbsp;&nbsp;&nbsp;第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 <strong>ack number=(主机 A 的 seq+1),syn=1,ack=1,随机产生 seq=7654321 的包</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;第三次握手：<strong>主机 A 收到后检查 ack number 是否正确</strong>，即第一次发送的 seq number+1,以及位码 ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认 seq 值与 ack=1 则连接建立成功。</p><p><img src="/images/Java_heart_network/clip_image006.gif" alt="img"> </p><h3 id="3-3-四次挥手"><a href="#3-3-四次挥手" class="headerlink" title="3.3. 四次挥手"></a>3.3. 四次挥手</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 <strong>TCP 的半关闭造成的</strong>。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。 </p><p>  1） 关闭客户端到服务器的连接：首先客户端 A 发送一个 FIN，用来关闭客户到服务器的数据传送，然后等待服务器的确认。其中终止标志位 FIN=1，序列号 seq=u </p><p>  2） 服务器收到这个 FIN，它发回一个 ACK，确认号 ack 为收到的序号加 1。 </p><p>  3） 关闭服务器到客户端的连接：也是发送一个 FIN 给客户端。 </p><p>  4） 客户段收到 FIN 后，并发回一个 ACK 报文确认，并将确认序号 seq 设置为收到序号加 1。   </p><p>首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 </p><p><img src="/images/Java_heart_network/clip_image008.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;主机 A 发送 FIN 后，进入终止等待状态， 服务器 B 收到主机 A 连接释放报文段后，就立即给主机 A 发送确认，然后服务器 B 就进入 close-wait 状态，此时 TCP 服务器进程就通知高层应用进程，因而从 A 到 B 的连接就释放了。此时是“半关闭”状态。即 A 不可以发送给 B，但是 B 可以发送给 A。此时，若 B 没有数据报要发送给 A 了，其应用进程就通知 TCP 释放连接，然后发送给 A 连接释放报文段，并等待确认。A 发送确认后，进入 time-wait，注意，此时 TCP 连接还没有释放掉，然后经过时间等待计时器设置的 2MSL 后，A 才进入到 close 状态。 </p><h2 id="4-HTTP-原理"><a href="#4-HTTP-原理" class="headerlink" title="4. HTTP 原理"></a>4. HTTP 原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTP是一个无状态的协议。无状态是指客户机（Web浏览器）和服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循请求(Request)/应答(Response)模型。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。所有 HTTP 连接都被构造成一套请求和应答。 </p><h3 id="4-1-传输流程"><a href="#4-1-传输流程" class="headerlink" title="4.1. 传输流程"></a>4.1. 传输流程</h3><p><strong>1：地址解析</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如用客户端浏览器请求这个页面：<a href="http://localhost.com:8080/index.htm" target="_blank" rel="noopener">http://localhost.com:8080/index.htm</a> 从中分解出协议名、主机名、</p><p>端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下： </p><p>协议名：http   </p><p>主机名：localhost.com   </p><p>端口：8080   </p><p>对象路径：/index.htm    </p><p>在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。 </p><p><strong>2：封装HTTP请求数据包</strong> </p><p>把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包 </p><p><strong>3：封装成TCP包并建立连接</strong>    </p><p>封装成 TCP 包，建立 TCP 连接（TCP 的三次握手） </p><p><strong>4：客户机发送请求命</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;客户机发送请求命令：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和可内容。</p><p><strong>5：服务器响应</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;服务器接到请求后，给予相应的响应信息，<u>其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容</u>。 </p><p><strong>6：服务器关闭TCP连接</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;服务器关闭 TCP 连接：一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 <u>Connection:keep-alive，TCP 连接在发送后将仍然保持打开状态</u>，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p><p><img src="/images/Java_heart_network/clip_image010.jpg" alt="img"> </p><h3 id="4-2-HTTP-状态"><a href="#4-2-HTTP-状态" class="headerlink" title="4.2. HTTP 状态"></a>4.2. HTTP 状态</h3><table><thead><tr><th><strong>状态码</strong></th><th><strong>原因短语</strong></th></tr></thead><tbody><tr><td></td><td><strong>消息响应</strong></td></tr><tr><td>100</td><td>Continue(继续)</td></tr><tr><td>101</td><td>Switching Protocol(切换协议)</td></tr><tr><td></td><td><strong>成功响应</strong></td></tr><tr><td>200</td><td>OK(成功)</td></tr><tr><td>201</td><td>Created(已创建)</td></tr><tr><td>202</td><td>Accepted(已创建)</td></tr><tr><td>203</td><td>Non-Authoritative  Information(未授权信息)</td></tr><tr><td>204</td><td>No  Content(无内容)</td></tr><tr><td>205</td><td>Reset  Content(重置内容)</td></tr><tr><td>206</td><td>Partial  Content(部分内容)</td></tr><tr><td></td><td><strong>重定向</strong></td></tr><tr><td>300</td><td>Multiple  Choice(多种选择)</td></tr><tr><td>301</td><td>Moved  Permanently(永久移动)</td></tr><tr><td>302</td><td>Found(临时移动)</td></tr><tr><td>303</td><td>See  Other(查看其他位置)</td></tr><tr><td>304</td><td>Not  Modified(未修改)</td></tr><tr><td>305</td><td>Use  Proxy(使用代理)</td></tr><tr><td>306</td><td>unused(未使用)</td></tr><tr><td>307</td><td>Temporary  Redirect(临时重定向)</td></tr><tr><td>308</td><td>Permanent  Redirect(永久重定向)</td></tr><tr><td></td><td><strong>客户端错误</strong></td></tr><tr><td>400</td><td>Bad  Request(错误请求)</td></tr><tr><td>401</td><td>Unauthorized(未授权)</td></tr><tr><td>402</td><td>Payment  Required(需要付款)</td></tr><tr><td>403</td><td>Forbidden(禁止访问)</td></tr><tr><td>404</td><td>Not  Found(未找到)</td></tr><tr><td>405</td><td>Method  Not Allowed(不允许使用该方法)</td></tr><tr><td>406</td><td>Not  Acceptable(无法接受)</td></tr><tr><td>407</td><td>Proxy  Authentication Required(要求代理身份验证)</td></tr><tr><td>408</td><td>Request  Timeout(请求超时)</td></tr><tr><td>409</td><td>Conflict(冲突)</td></tr><tr><td>410</td><td>Gone(已失效)</td></tr><tr><td>411</td><td>Length  Required(需要内容长度头)</td></tr><tr><td>412</td><td>Precondition  Failed(预处理失败)</td></tr><tr><td>413</td><td>Request  Entity Too Large(请求实体过长)</td></tr><tr><td>414</td><td>Request-URI  Too Long(请求网址过长)</td></tr><tr><td>415</td><td>Unsupported  Media Type(媒体类型不支持)</td></tr><tr><td>416</td><td>Requested  Range Not Satisfiable(请求范围不合要求)</td></tr><tr><td>417</td><td>Expectation  Failed(预期结果失败)</td></tr><tr><td></td><td><strong>服务器端错误</strong></td></tr><tr><td>500</td><td>Internal  Server Error(内部服务器错误)</td></tr><tr><td>501</td><td>Implemented(未实现)</td></tr><tr><td>502</td><td>Bad  Gateway(网关错误)</td></tr><tr><td>503</td><td>Service  Unavailable(服务不可用)</td></tr><tr><td>504</td><td>Gateway  Timeout (网关超时)</td></tr><tr><td>505</td><td>HTTP  Version Not Supported(HTTP 版本不受支持)</td></tr></tbody></table><h3 id="4-3-HTTPS"><a href="#4-3-HTTPS" class="headerlink" title="4.3. HTTPS"></a>4.3. HTTPS</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP 通道，简单讲是 HTTP 的安全版。即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。其所用的端口号是 443。 过程大致如下： </p><p><strong>建立连接获取证书</strong> </p><ol><li>SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL 的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。         </li></ol><p><strong>证书验证</strong> </p><ol start="2"><li>Client 在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</li></ol><p><strong>数据加密和传输</strong> </p><ol start="3"><li>如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</li></ol><p><img src="/images/Java_heart_network/clip_image012.gif" alt="img"> </p><h2 id="5-CDN-原理"><a href="#5-CDN-原理" class="headerlink" title="5. CDN 原理"></a>5. CDN 原理</h2><p>CND 一般包含分发服务系统、负载均衡系统和管理系统 </p><h3 id="5-1-分发服务系统"><a href="#5-1-分发服务系统" class="headerlink" title="5.1.分发服务系统"></a>5.1.分发服务系统</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;其基本的工作单元就是各个 Cache 服务器。负责直接响应用户请求，将内容快速分发到用户；同时还负责内容更新，保证和源站内容的同步。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;根据内容类型和服务种类的不同，分发服务系统分为多个子服务系统，如：<strong>网页加速服务、流媒体加速服务、应用加速服务</strong>等。每个子服务系统都是一个分布式的服务集群，由功能类似、地域接近的分布部署的 Cache 集群组成。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>在承担内容同步、更新和响应用户请求之外，分发服务系统还需要向上层的管理调度系统反馈各个 Cache 设备的健康状况、响应情况、内容缓存状况等，以便管理调度系统能够根据设定的策略决定由哪个 Cache 设备来响应用户的请求。</u> </p><h3 id="5-2-负载均衡系统"><a href="#5-2-负载均衡系统" class="headerlink" title="5.2.负载均衡系统"></a>5.2.负载均衡系统</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;负载均衡系统是整个 CDN 系统的中枢。负责对所有的用户请求进行调度，确定提供给用户的最终访问地址。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;使用分级实现。最基本的两极调度体系包括全局负载均衡（GSLB）和本地负载均衡（SLB）。 GSLB 根据用户地址和用户请求的内容，<u>主要根据就近性原则，确定向用户服务的节点。一般通过 DNS 解析或者应用层重定向（Http 3XX 重定向）的方式实现。</u> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;SLB 主要负责节点内部的负载均衡。当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各个 Cache 设备的工作状况和内容分布情况等对用户请求重定向。<u>SLB 的实现有四层调度（LVS）、七层调度（Nginx）和链路负载调度等。</u> </p><h3 id="5-3-管理系统"><a href="#5-3-管理系统" class="headerlink" title="5.3.管理系统"></a>5.3.管理系统</h3><p>分为<strong>运营管理和网络管理子系统</strong>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;网络管理系统实现对 CDN 系统的设备管理、拓扑管理、链路监控和故障管理，为管理员提供对全网资源的可视化的集中管理，通常用 web 方式实现。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;运营管理是对 CDN 系统的业务管理，负责处理业务层面的与外界系统交互所必须的一些收集、整理、交付工作。<u>包括用户管理、产品管理、计费管理、统计分析等。</u> </p><p><img src="/images/Java_heart_network/clip_image013.jpg" alt="img"> </p><h2 id="6-最后"><a href="#6-最后" class="headerlink" title="6.最后"></a>6.最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-网络7层架构&quot;&gt;&lt;a href=&quot;#1-网络7层架构&quot; class=&quot;headerlink&quot; title=&quot;1. 网络7层架构&quot;&gt;&lt;/a&gt;1. 网络7层架构&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;7 层模型主要包括：&lt;/strong&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为 1、0，也就是我们常说的&lt;strong&gt;模数转换与数模转换&lt;/strong&gt;）。这一层的数据叫做比特。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(七)之Netty与 RPC</title>
    <link href="https://quietair.gitee.io/Java_heart_NettyorRPC/"/>
    <id>https://quietair.gitee.io/Java_heart_NettyorRPC/</id>
    <published>2020-04-05T06:42:27.000Z</published>
    <updated>2020-05-04T07:04:49.840Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Netty-原理"><a href="#1-Netty-原理" class="headerlink" title="1. Netty 原理"></a>1. Netty 原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对 TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞的，<strong>通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。</strong>  </p><a id="more"></a><h2 id="2-Netty-高性能"><a href="#2-Netty-高性能" class="headerlink" title="2. Netty 高性能"></a>2. Netty 高性能</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在IO编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者IO多路复用技术进行处理。IO多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O 多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降低了系统的维护工作量，节省了系统资源。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;与Socket类和ServerSocket类相对应，NIO也提供了SocketChannel和ServerSocketChannel 两种不同的套接字通道实现。 </p><h3 id="2-1-多路复用通讯方式"><a href="#2-1-多路复用通讯方式" class="headerlink" title="2.1. 多路复用通讯方式"></a>2.1. 多路复用通讯方式</h3><p>Netty 架构按照 Reactor 模式设计和实现，它的服务端通信序列图如下： </p><p><img src="/images/Java_heart_NettyorRPC/clip_image003.gif" alt="img"> </p><p>客户端通信序列图如下：</p><p><img src="/images/Java_heart_NettyorRPC/clip_image005.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty 的 IO <strong>线程 NioEventLoop 由于聚合了多路复用器 Selector</strong>，可以同时并发处理成百上千个客户端 Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起。 </p><h3 id="2-2-异步通讯-NIO"><a href="#2-2-异步通讯-NIO" class="headerlink" title="2.2. 异步通讯 NIO"></a>2.2. 异步通讯 NIO</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>由于 Netty 采用了异步通信模式，一个 IO 线程可以并发处理 N 个客户端连接和读写操作</strong>，这从根本上解决了传统同步阻塞 IO 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。 </p><h3 id="2-3-零拷贝（DIRECT-BUFFERS-使用堆外直接内存）"><a href="#2-3-零拷贝（DIRECT-BUFFERS-使用堆外直接内存）" class="headerlink" title="2.3. 零拷贝（DIRECT BUFFERS 使用堆外直接内存）"></a>2.3. 零拷贝（DIRECT BUFFERS 使用堆外直接内存）</h3><ol><li><p><strong>Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝</strong>。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写， JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 </p></li><li><p><u>Netty 提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的Buffer。</u> </p></li><li><p>Netty的文件传输采用了<strong>transferTo方法</strong>，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环 write 方式导致的内存拷贝问题 。</p></li></ol><h3 id="2-4-内存池（基于内存池的缓冲区重用机制）"><a href="#2-4-内存池（基于内存池的缓冲区重用机制）" class="headerlink" title="2.4. 内存池（基于内存池的缓冲区重用机制）"></a>2.4. 内存池（基于内存池的缓冲区重用机制）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;随着 JVM 虚拟机和 JIT 即时编译技术的发展，对象的分配和回收是个非常轻量级的工作。但是对于缓冲区 Buffer，情况却稍有不同，特别是对于<strong>堆外直接内存的分配和回收，是一件耗时的操作</strong>。为了尽量重用缓冲区，<strong>Netty 提供了基于内存池的缓冲区重用机制</strong>。 </p><h3 id="2-5-高效的-Reactor-线程模型"><a href="#2-5-高效的-Reactor-线程模型" class="headerlink" title="2.5. 高效的 Reactor 线程模型"></a>2.5. 高效的 Reactor 线程模型</h3><p>常用的 Reactor 线程模型有三种，Reactor 单线程模型, Reactor 多线程模型, 主从 Reactor 多线程模型。 </p><p><strong>Reactor单线程模型</strong> </p><p>Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成，NIO 线程的职责如下： </p><p>1) 作为 NIO 服务端，接收客户端的 TCP 连接； </p><p>2) 作为 NIO 客户端，向服务端发起 TCP 连接； </p><p>3) 读取通信对端的请求或者应答消息；</p><p>4) 向通信对端发送消息请求或者应答消息。</p><p><img src="/images/Java_heart_NettyorRPC/clip_image007.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;由于 Reactor 模式使用的是异步非阻塞 IO，所有的 IO 操作都不会导致阻塞，理论上一个线程可以独立处理所有 IO 相关的操作。从架构层面看，一个 NIO 线程确实可以完成其承担的职责。例如，通过Acceptor 接收客户端的 TCP 连接请求消息，链路建立成功之后，通过 Dispatch 将对应的 ByteBuffer 派发到指定的 Handler 上进行消息解码。用户 Handler 可以通过 NIO 线程将消息发送给客户端。 </p><p><strong>Reactor多线程模型</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作。 有专门一个 <strong>NIO 线程-Acceptor 线程用于监听服务端</strong>，接收客户端的 TCP 连接请求； <strong>网络 IO 操作-读、写等由一个 NIO 线程池负责</strong>，线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N 个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送；</p><p><img src="/images/Java_heart_NettyorRPC/clip_image009.gif" alt="img"> <strong>主从Reactor多线程模型</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。 Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责 SocketChannel 的读写和编解码工作。<u>Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。</u> </p><p><img src="/images/Java_heart_NettyorRPC/clip_image011.gif" alt="img"> </p><h3 id="2-6-无锁设计、线程绑定"><a href="#2-6-无锁设计、线程绑定" class="headerlink" title="2.6. 无锁设计、线程绑定"></a>2.6. 无锁设计、线程绑定</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列多个工作线程模型性能更优。</p><p><img src="/images/Java_heart_NettyorRPC/clip_image013.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的 fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。</p><h3 id="2-7-高性能的序列化框架"><a href="#2-7-高性能的序列化框架" class="headerlink" title="2.7. 高性能的序列化框架"></a>2.7. 高性能的序列化框架</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Netty 默认提供了对 Google Protobuf 的支持，通过扩展 Netty 的编解码接口，用户可以实现其它的高性能序列化框架，例如 Thrift 的压缩二进制编解码框架。 </p><ol><li>SO_RCVBUF 和 SO_SNDBUF：<strong>通常建议值为 128K 或者 256K</strong>。 </li></ol><p><strong>小包封大包，防止网络阻塞</strong> </p><ol start="2"><li>SO_TCPNODELAY：<strong>NAGLE 算法通过将缓冲区内的小封包自动相连，组成较大的封包，阻止大量小封包的发送阻塞网络</strong>，从而提高网络应用效率。但是对于时延敏感的应用场景需要关闭该优化算法。 </li></ol><p><strong>软中断Hash值和CPU绑定</strong> </p><ol start="3"><li>软中断：开启 RPS 后可以实现软中断，提升网络吞吐量。<strong>RPS 根据数据包的源地址，目的地址以及目的和源端口，计算出一个 hash 值，然后根据这个 hash 值来选择软中断运行的 cpu</strong>，从上层来看，<strong>也就是说将每个连接和 cpu 绑定，并通过这个 hash 值，来均衡软中断在多个 cpu 上</strong>，提升网络并行处理性能。</li></ol><h2 id="3-Netty-RPC-实现"><a href="#3-Netty-RPC-实现" class="headerlink" title="3. Netty RPC 实现"></a>3. Netty RPC 实现</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1. 概念"></a>3.1. 概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;RPC，即 Remote Procedure Call（远程过程调用），调用远程计算机上的服务，就像调用本地服务一样。RPC 可以很好的解耦系统，如 WebService 就是一种基于 Http 协议的 RPC。这个 RPC 整体框架如下： </p><p><img src="/images/Java_heart_NettyorRPC/clip_image015.gif" alt="img"> </p><h3 id="3-2-关键技术"><a href="#3-2-关键技术" class="headerlink" title="3.2. 关键技术"></a>3.2. 关键技术</h3><ol><li><p>服务发布与订阅：服务端使用 Zookeeper 注册服务地址，客户端从 Zookeeper 获取可用的服务地址。 </p></li><li><p>通信：使用 Netty 作为通信框架。</p></li><li><p>Spring：使用 Spring 配置服务，加载 Bean，扫描注解。 </p></li><li><p>动态代理：客户端使用代理模式透明化服务调用。 </p></li><li><p>消息编解码：使用 Protostuff 序列化和反序列化消息。 </p></li></ol><h3 id="3-3-核心流程"><a href="#3-3-核心流程" class="headerlink" title="3.3. 核心流程"></a>3.3. 核心流程</h3><ol><li><p>服务消费方（client）调用以本地调用方式调用服务；</p></li><li><p>client stub 接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体； </p></li><li><p>client stub 找到服务地址，并将消息发送到服务端； </p></li><li><p>server stub 收到消息后进行解码； </p></li><li><p>server stub 根据解码结果调用本地的服务； </p></li><li><p>本地服务执行并将结果返回给 server stub； </p></li><li><p>server stub 将返回结果打包成消息并发送至消费方； </p></li><li><p>client stub 接收到消息，并进行解码； </p></li><li><p>服务消费方得到最终结果。 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>RPC 的目标就是要 2~8 这些步骤都封装起来</strong>，让用户对这些细节透明。<strong>JAVA 一般使用动态代理方式实现远程调用</strong>。 </p><p><img src="/images/Java_heart_NettyorRPC/clip_image017.gif" alt="img"> </p><h3 id="3-4-消息编解码"><a href="#3-4-消息编解码" class="headerlink" title="3.4. 消息编解码"></a>3.4. 消息编解码</h3><p><strong>息数据结构（接口名称+方法名+参数类型和参数值+超时时间+ requestID）</strong>  </p><p>客户端的请求消息结构一般需要包括以下内容： </p><ol><li><p>接口名称：在我们的例子里接口名是“HelloWorldService”，如果不传，服务端就不知道调用哪个接口了；</p></li><li><p>方法名：一个接口内可能有很多方法，如果不传方法名服务端也就不知道调用哪个方法；</p></li><li><p>参数类型和参数值：参数类型有很多，比如有 bool、int、long、double、string、map、list，甚至如 struct（class）；以及相应的参数值；</p></li><li><p>超时时间： </p></li><li><p>requestID，标识唯一请求 id，在下面一节会详细描述 requestID 的用处。 </p></li><li><p>服务端返回的消息 ： 一般包括以下内容。返回值+状态 code+requestID </p></li></ol><p><strong>序列化</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;目前互联网公司广泛使用 Protobuf、Thrift、Avro 等成熟的序列化解决方案来搭建 RPC 框架，这些都是久经考验的解决方案。 </p><h3 id="3-5-通讯过程"><a href="#3-5-通讯过程" class="headerlink" title="3.5. 通讯过程"></a>3.5. 通讯过程</h3><p><strong>核心问题(线程暂停、消息乱序)</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果使用 netty 的话，<u>一般会用 channel.writeAndFlush()方法来发送消息二进制串，这个方法调用后对于整个远程调用(从发出请求到接收到结果)来说是一个异步的，即对于当前线程来说，将请求发送出来后，线程就可以往后执行了，至于服务端的结果，是服务端处理完成后，再以消息的形式发送给客户端的。</u>于是这里出现以下两个问题：</p><ol><li><p>怎么让当前线程“暂停”，等结果回来后，再向后执行？ </p></li><li><p>如果有多个线程同时进行远程方法调用，这时建立在 client server 之间的 socket 连接上会有很多双方发送的消息传递，前后顺序也可能是随机的，server 处理完结果后，将结果消息发送给 client，client 收到很多消息，怎么知道哪个消息结果是原先哪个线程调用的？如下图所示，线程 A 和线程 B 同时向 client socket 发送请求 requestA 和 requestB， socket 先后将 <u>requestB 和 requestA 发送至 server，而 server 可能将 responseB 先返回</u>，尽管 requestB 请求到达时间更晚。我们需要一种机制保证 responseA 丢给ThreadA，responseB 丢给 ThreadB。 </p></li></ol><p><img src="/images/Java_heart_NettyorRPC/clip_image019.gif" alt="img"> </p><p><strong>通讯流程</strong> </p><p><strong>requestID生成-AtomicLong</strong></p><ol><li>client 线程每次通过 socket 调用一次远程接口前，<u>生成一个唯一的 ID，即 requestID （requestID 必需保证在一个 Socket 连接里面是唯一的）</u>，一般常常使用 AtomicLong 从 0 开始累计数字生成唯一 ID； </li></ol><p><strong>存放回调对象callback到全局ConcurrentHashMap</strong></p><ol start="2"><li>将 处 理 结 果 的 回 调 对 象 callback ， 存 放 到 全 局 ConcurrentHashMap 里 面 put(requestID, callback)； </li></ol><p><strong>synchronized获取回调对象callback的锁并自旋wait</strong></p><ol start="3"><li>当线程调用 channel.writeAndFlush()发送消息后，紧接着执行 callback 的 get()方法试图获取远程返回的结果。在 get()内部，则使用 synchronized 获取回调对象 callback 的锁，再先检测是否已经获取到结果，如果没有，然后调用 callback 的 wait()方法，释放 callback 上的锁，让当前线程处于等待状态。 </li></ol><p><strong>监听消息的线程收到消息，找到callback上的锁并唤醒</strong> </p><ol start="4"><li><p>服务端接收到请求并处理后，将response结果（此结果中包含了前面的requestID）发送给客户端，<u>客户端 socket 连接上专门监听消息的线程收到消息，分析结果，取到 requestID，再从前面的 ConcurrentHashMap 里面 get(requestID)，从而找到 callback 对象，再用 synchronized 获取 callback 上的锁，将方法调用结果设置到 callback 对象里，再调用 callback.notifyAll()唤醒前面处于等待状态的线程。</u> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 旋锁       </span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 是否有结果了   </span></span><br><span class="line">            If （!isDone）&#123;                 </span><br><span class="line">                wait(); <span class="comment">//没结果释放锁，让当前线程处于等待状态   </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//获取数据并处理   </span></span><br><span class="line">            &#125;             </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">setDone</span><span class="params">(Response res)</span> </span>&#123;      </span><br><span class="line">    <span class="keyword">this</span>.res = res;     </span><br><span class="line">    isDone = <span class="keyword">true</span>;       </span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">//获取锁，因为前面 wait()已经释放了 callback 的锁了       </span></span><br><span class="line">        notifyAll(); <span class="comment">//  唤醒处于等待的线程       </span></span><br><span class="line">    &#125;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-RMI-实现方式"><a href="#4-RMI-实现方式" class="headerlink" title="4. RMI 实现方式"></a>4. RMI 实现方式</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 远程方法调用，即 Java RMI（Java Remote Method Invocation）是 Java 编程语言里，一种用于实现远程过程调用的应用程序编程接口。它使客户机上运行的程序可以调用远程服务器上的对象。远程方法调用特性使 Java 编程人员能够在网络环境中分布操作。RMI 全部的宗旨就是尽可能简化远程接口对象的使用。</p><h3 id="4-1-实现步骤"><a href="#4-1-实现步骤" class="headerlink" title="4.1. 实现步骤"></a>4.1. 实现步骤</h3><ol><li><p>编写远程服务接口，该接口必须继承 java.rmi.Remote 接口，方法必须抛出 java.rmi.RemoteException 异常；</p></li><li><p>编写远程接口实现类，该实现类必须继承 java.rmi.server.UnicastRemoteObject 类； </p></li><li><p>运行 RMI 编译器（rmic），创建客户端 stub 类和服务端 skeleton 类; </p></li><li><p>启动一个 RMI 注册表，以便驻留这些服务; </p></li><li><p>在 RMI 注册表中注册服务；</p></li><li><p>客户端查找远程对象，并调用远程方法； </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1：创建远程接口，继承 java.rmi.Remote 接口    </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GreetService</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">Remote</span>  </span>&#123;   </span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span>  <span class="keyword">throws</span> RemoteException</span>;   </span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">//2：实现远程接口，继承 java.rmi.server.UnicastRemoteObject 类   </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreetServiceImpl</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">rmi</span>.<span class="title">server</span>.<span class="title">UnicastRemoteObject</span>  <span class="keyword">implements</span> <span class="title">GreetService</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3434060152387200042L</span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreetServiceImpl</span><span class="params">()</span> <span class="keyword">throws</span>  RemoteException </span>&#123;     </span><br><span class="line">        <span class="keyword">super</span>();       </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="meta">@Override</span>   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span>  <span class="keyword">throws</span> RemoteException </span>&#123;     </span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"Hello "</span> + name;       </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//3：生成  Stub 和 Skeleton;    4：执行  rmiregistry 命令注册服务     5：启动服务    </span></span><br><span class="line">LocateRegistry.createRegistry(<span class="number">1098</span>);   </span><br><span class="line">Naming.bind(<span class="string">"rmi://10.108.1.138:1098/GreetService"</span>,  <span class="keyword">new</span> GreetServiceImpl());   </span><br><span class="line"><span class="comment">//6.客户端调用    </span></span><br><span class="line">GreetService   greetService    =   (GreetService)   Naming.lookup(<span class="string">"rmi://10.108.1.138:1098/GreetService"</span>);    </span><br><span class="line">System.out.println(greetService.sayHello(<span class="string">"Jobs"</span>));</span><br></pre></td></tr></table></figure><h2 id="5-Protoclol-Buffer"><a href="#5-Protoclol-Buffer" class="headerlink" title="5. Protoclol Buffer"></a>5. Protoclol Buffer</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;protocol buffer 是 google 的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法，例如 XML，不过它比 xml 更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。</p><h3 id="5-1-特点"><a href="#5-1-特点" class="headerlink" title="5.1. 特点"></a>5.1. 特点</h3><p><img src="/images/Java_heart_NettyorRPC/clip_image021.gif" alt="img"> </p><p>Protocol Buffer 的序列化 &amp; 反序列化简单 &amp; 速度快的原因是： </p><ol><li><p>编码 / 解码 方式简单（只需要简单的数学运算 = 位移等等） </p></li><li><p>采用 Protocol Buffer 自身的框架代码 和 编译器 共同完成 </p></li></ol><p>Protocol Buffer 的数据压缩效果好（即序列化后的数据量体积小）的原因是： </p><ol><li><p>a. 采用了独特的编码方式，如 Varint、Zigzag 编码方式等等 </p></li><li><p>b. 采用 T - L - V 的数据存储方式：减少了分隔符的使用 &amp; 数据存储得紧凑 </p></li></ol><h2 id="6-Thrift"><a href="#6-Thrift" class="headerlink" title="6. Thrift"></a>6. Thrift</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Apache Thrift 是 Facebook 实现的一种高效的、支持多种编程语言的远程服务调用的框架。本文将从 Java 开发人员角度详细介绍 Apache Thrift 的架构、开发和部署，并且针对不同的传输协议和服务类型给出相应的 Java 实例，同时详细介绍 Thrift 异步客户端的实现，最后提出使用 Thrift 需要注意的事项。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;目前流行的服务调用方式有很多种，例如基于 SOAP 消息格式的 Web Service，基于 JSON 消息格式的 RESTful 服务等。其中所用到的数据传输方式包括 XML，JSON 等，然而 XML 相对体积太大，传输效率低，JSON 体积较小，新颖，但还不够完善。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;本文将介绍由 Facebook 开发的远程服务调用框架 Apache Thrift，<strong>它采用接口描述语言定义并创建服务，支持可扩展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中</strong>，如 C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk 等创建高效的、无缝的服务，其传输数据采用二进制格式，<strong>相对 XML 和 JSON 体积更小，对于高并发、大数据量和多语言的环境更有优势。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;本文将详细介绍 Thrift 的使用，并且提供丰富的实例代码加以解释说明，帮助使用者快速构建服务。 </p><p>为什么要 Thrift：</p><p>1、多语言开发的需要 2、性能问题</p><p><img src="/images/Java_heart_NettyorRPC/clip_image023.gif" alt="img"> </p><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7.最后"></a>7.最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Netty-原理&quot;&gt;&lt;a href=&quot;#1-Netty-原理&quot; class=&quot;headerlink&quot; title=&quot;1. Netty 原理&quot;&gt;&lt;/a&gt;1. Netty 原理&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对 TCP、UDP 和文件传输的支持，作为一个异步 NIO 框架，Netty 的所有 IO 操作都是异步非阻塞的，&lt;strong&gt;通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。&lt;/strong&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(六)之微服务</title>
    <link href="https://quietair.gitee.io/Java_heart_microservice/"/>
    <id>https://quietair.gitee.io/Java_heart_microservice/</id>
    <published>2020-03-21T05:36:05.000Z</published>
    <updated>2020-05-04T07:04:49.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-服务注册发现"><a href="#1-服务注册发现" class="headerlink" title="1. 服务注册发现"></a>1. 服务注册发现</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要Service Provider地址就行了。当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种形式：客户端注册和第三方注册。 </p><a id="more"></a><h3 id="1-1-客户端注册（zookeeper）"><a href="#1-1-客户端注册（zookeeper）" class="headerlink" title="1.1.客户端注册（zookeeper）"></a>1.1.客户端注册（zookeeper）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;客户端注册是服务自身要负责注册与注销的工作。当服务启动后向注册中心注册自身，当服务下线时注销自己。期间还需要和注册中心保持心跳。心跳不一定要客户端来做，也可以由注册中心负责（这个过程叫探活）。这种方式的缺点是注册工作与服务耦合在一起，不同语言都要实现一套注册逻辑。</p><p><img src="/images/Java_heart_microservice/clip_image003.gif" alt="img"> </p><h3 id="1-2-第三方注册（独立的服务-Registrar）"><a href="#1-2-第三方注册（独立的服务-Registrar）" class="headerlink" title="1.2.第三方注册（独立的服务 Registrar）"></a>1.2.第三方注册（独立的服务 Registrar）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第三方注册由一个独立的服务Registrar负责注册与注销。当服务启动后以某种方式通知Registrar，然后 Registrar 负责向注册中心发起注册工作。同时注册中心要维护与服务之间的心跳，当服务不可用时，向注册中心注销服务。这种方式的缺点是 Registrar 必须是一个高可用的系统，否则注册工作没法进展。 </p><p><img src="/images/Java_heart_microservice/clip_image005.gif" alt="img"> </p><h3 id="1-3-客户端发现"><a href="#1-3-客户端发现" class="headerlink" title="1.3.客户端发现"></a>1.3.客户端发现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;客户端发现是指客户端负责查询可用服务地址，以及负载均衡的工作。这种方式最方便直接，而且也方便做负载均衡。再者一旦发现某个服务不可用立即换另外一个，非常直接。缺点也在于多语言时的重复工作，每个语言实现相同的逻辑。</p><p><img src="/images/Java_heart_microservice/clip_image007.gif" alt="img"> </p><h3 id="1-4-服务端发现"><a href="#1-4-服务端发现" class="headerlink" title="1.4.服务端发现"></a>1.4.服务端发现</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;服务端发现需要额外的 Router 服务，请求先打到 Router，然后 Router 负责查询服务与负载均衡。这种方式虽然没有客户端发现的缺点，但是它的缺点是保证 Router 的高可用。 </p><p><img src="/images/Java_heart_microservice/clip_image009.jpg" alt="img"> </p><ul><li>Consul</li><li>Eureka</li><li>SmartStack</li><li>Etcd</li></ul><h2 id="2-API-网关"><a href="#2-API-网关" class="headerlink" title="2. API 网关"></a>2. API 网关</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;API Gateway 是一个服务器，也可以说是进入系统的唯一节点。这跟面向对象设计模式中的 Facade 模式很像。API Gateway 封装内部系统的架构，并且提供 API 给各个客户端。它还可能有其他功能，如授权、监控、负载均衡、缓存、请求分片和管理、静态响应处理等。下图展示了一个适应当前架构的 API Gateway。 </p><p><img src="/images/Java_heart_microservice/clip_image011.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>API Gateway 负责请求转发、合成和协议转换。</strong>所有来自客户端的请求都要先经过 API Gateway，然后路由这些请求到对应的微服务。API Gateway 将经常通过调用多个微服务来处理一个请求以及聚合多个服务的结果。它可以在 web 协议与内部使用的非 Web 友好型协议间进行转换，如HTTP 协议、WebSocket 协议。</p><h3 id="2-1-请求转发"><a href="#2-1-请求转发" class="headerlink" title="2.1. 请求转发"></a>2.1. 请求转发</h3><p>服务转发主要是对客户端的请求安装微服务的负载转发到不同的服务上 </p><h3 id="2-2-响应合并"><a href="#2-2-响应合并" class="headerlink" title="2.2. 响应合并"></a>2.2. 响应合并</h3><p>把业务上需要调用多个服务接口才能完成的工作合并成一次调用对外统一提供服务。 </p><h3 id="2-3-协议转换"><a href="#2-3-协议转换" class="headerlink" title="2.3. 协议转换"></a>2.3. 协议转换</h3><p>重点是支持 SOAP，JMS，Rest 间的协议转换。 </p><h3 id="2-4-数据转换"><a href="#2-4-数据转换" class="headerlink" title="2.4. 数据转换"></a>2.4. 数据转换</h3><p>重点是支持 XML 和 Json 之间的报文格式转换能力（可选） </p><h3 id="2-5-安全认证"><a href="#2-5-安全认证" class="headerlink" title="2.5. 安全认证"></a>2.5. 安全认证</h3><ol><li><p>基于 Token 的客户端访问控制和安全策略</p></li><li><p>传输数据和报文加密，到服务端解密，需要在客户端有独立的 SDK 代理包 </p></li><li><p>基于 Https 的传输加密，客户端和服务端数字证书支持</p></li><li><p>基于 OAuth2.0 的服务安全认证(授权码，客户端，密码模式等） </p></li></ol><h2 id="3-配置中心"><a href="#3-配置中心" class="headerlink" title="3. 配置中心"></a>3. 配置中心</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;配置中心一般用作系统的参数配置，它需要满足如下几个要求：高效获取、实时感知、分布式访</p><p>问。 </p><h3 id="3-1-zookeeper-配置中心"><a href="#3-1-zookeeper-配置中心" class="headerlink" title="3.1. zookeeper 配置中心"></a>3.1. zookeeper 配置中心</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;实现的架构图如下所示，采取数据加载到内存方式解决高效获取的问题，借助 zookeeper 的节点监听机制来实现实时感知。 </p><img src="/images/Java_heart_microservice/clip_image013.gif" alt="img"> <h3 id="3-2-配置中心数据分类"><a href="#3-2-配置中心数据分类" class="headerlink" title="3.2. 配置中心数据分类"></a>3.2. 配置中心数据分类</h3><p><img src="/images/Java_heart_microservice/clip_image015.gif" alt="img"> </p><h2 id="4-事件调度（kafka）"><a href="#4-事件调度（kafka）" class="headerlink" title="4. 事件调度（kafka）"></a>4. 事件调度（kafka）</h2><p>消息服务和事件的统一调度，常用用 kafka ，activemq 等。 </p><h2 id="5-服务跟踪（starter-sleuth）"><a href="#5-服务跟踪（starter-sleuth）" class="headerlink" title="5. 服务跟踪（starter-sleuth）"></a>5. 服务跟踪（starter-sleuth）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;随着微服务数量不断增长，需要跟踪一个请求从一个微服务到下一个微服务的传播过程， <strong>Spring Cloud Sleuth 正是解决这个问题，它在日志中引入唯一 ID，以保证微服务调用之间的一致性，这样你就能跟踪某个请求是如何从一个微服务传递到下一个。</strong> </p><ol><li><p>为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，<strong>这个唯一标识就是前文中提到的 Trace ID</strong>。通过 Trace ID 的记录，我们就能将所有请求过程日志关联起来。 </p></li><li><p>为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的 Span ID，<strong>对于每个 Span 来说，它必须有开始和结束两个节点，通过记录开始 Span 和结束 Span 的时间戳，就能统计出该 Span 的时间延迟</strong>，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。</p></li><li><p>在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloudstarter-sleuth 组件的实现。在 Spring Boot 应用中，通过在工程中引入 spring-cloudstarter-sleuth 依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：（1）、通过诸如 RabbitMQ、Kafka（或者其他任何 Spring Cloud Stream 绑定器实现的消息中间件）传递的请求。（2）、通过 Zuul 代理传递的请求。 （3）、通过 RestTemplate 发起的请求。</p></li></ol><h2 id="6-服务熔断（Hystrix）"><a href="#6-服务熔断（Hystrix）" class="headerlink" title="6. 服务熔断（Hystrix）"></a>6. 服务熔断（Hystrix）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。 熔断器的原理很简单，如同电力过载保护器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;它可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费 CPU 时间去等到长时间的超时产生。熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p><p><img src="/images/Java_heart_microservice/clip_image017.jpg" alt="img"> </p><h3 id="6-1-Hystrix-断路器机制"><a href="#6-1-Hystrix-断路器机制" class="headerlink" title="6.1. Hystrix 断路器机制"></a>6.1. Hystrix 断路器机制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;断路器很好理解, 当 Hystrix Command 请求后端服务失败数量超过一定比例(默认 50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认 5 秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix 的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力。</p><h2 id="7-API-管理"><a href="#7-API-管理" class="headerlink" title="7. API 管理"></a>7. API 管理</h2><p>SwaggerAPI 管理工具。</p><h2 id="8-最后"><a href="#8-最后" class="headerlink" title="8. 最后"></a>8. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-服务注册发现&quot;&gt;&lt;a href=&quot;#1-服务注册发现&quot; class=&quot;headerlink&quot; title=&quot;1. 服务注册发现&quot;&gt;&lt;/a&gt;1. 服务注册发现&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;服务注册就是维护一个登记簿，它管理系统内所有的服务地址。当新的服务启动后，它会向登记簿交待自己的地址信息。服务的依赖方直接向登记簿要Service Provider地址就行了。当下用于服务注册的工具非常多 ZooKeeper，Consul，Etcd, 还有 Netflix 家的 eureka 等。服务注册有两种形式：客户端注册和第三方注册。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="Zookeeper" scheme="https://quietair.gitee.io/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot与日志</title>
    <link href="https://quietair.gitee.io/spring-boot-logging/"/>
    <id>https://quietair.gitee.io/spring-boot-logging/</id>
    <published>2020-03-12T02:47:23.000Z</published>
    <updated>2020-05-04T07:04:50.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1.日志框架"></a>1.日志框架</h2><p>一个统一的接口层；日志门面（日志的一个抽象层）；</p><p>给项目中导入具体的日志实现就行了；之前的日志框架都是实现的抽象层；</p><p>市面上的日志框架:</p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j……</p><a id="more"></a><table><thead><tr><th>日志门面  （日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（Jakarta  Commons Logging）</del>    SLF4j（Simple  Logging Facade for Java）    <strong><del>jboss-logging</del></strong></td><td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td></tr></tbody></table><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面：  SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是Spring框架，Spring框架默认是用JCL；</p><p>​    <strong>SpringBoot选用 SLF4j和logback；</strong></p><h2 id="2-SLF4j使用"><a href="#2-SLF4j使用" class="headerlink" title="2.SLF4j使用"></a>2.SLF4j使用</h2><h3 id="2-1-如何在系统中使用SLF4j"><a href="#2-1-如何在系统中使用SLF4j" class="headerlink" title="2.1.如何在系统中使用SLF4j"></a>2.1.如何在系统中使用SLF4j</h3><p><a href="http://www.slf4j.org/manual.html" target="_blank" rel="noopener">用户文档</a></p><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p><p>给系统里面导入slf4j的jar和  logback的实现jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示；</p><p><img src="/images/spring-boot-logging/concrete-bindings.png" alt="images/concrete-bindings.png"></p><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架自己本身的配置文件；</strong></p><h3 id="2-2-遗留问题"><a href="#2-2-遗留问题" class="headerlink" title="2.2.遗留问题"></a>2.2.遗留问题</h3><p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p><p><img src="/images/spring-boot-logging/legacy.png" alt></p><p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p><p>1、将系统中其他日志框架先排除出去；</p><p>2、用中间包来替换原有的日志框架；</p><p>3、我们导入slf4j其他的实现;</p><h2 id="3-SpringBoot日志关系"><a href="#3-SpringBoot日志关系" class="headerlink" title="3.SpringBoot日志关系"></a>3.SpringBoot日志关系</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot使用它来做日志功能；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>底层依赖关系</p><p><img src="/images/spring-boot-logging/20200311190119.png" alt></p><p>总结：</p><p>​    1）、SpringBoot底层也是使用slf4j+logback的方式进行日志记录</p><p>​    2）、SpringBoot也把其他的日志都替换成了slf4j；</p><p>​    3）、中间替换包？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory();</span><br></pre></td></tr></table></figure><p><img src="/images/spring-boot-logging/20200311190307.png" alt></p><p>​    4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>​            Spring框架用的是commons-logging；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；</strong></p><h2 id="4-日志使用"><a href="#4-日志使用" class="headerlink" title="4.日志使用"></a>4.日志使用</h2><h3 id="4-1-默认配置"><a href="#4-1-默认配置" class="headerlink" title="4.1.默认配置"></a>4.1.默认配置</h3><p>SpringBoot默认帮我们配置好了日志；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//日志的级别；</span></span><br><span class="line"><span class="comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line"><span class="comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span></span><br><span class="line">logger.trace(<span class="string">"这是trace日志..."</span>);</span><br><span class="line">logger.debug(<span class="string">"这是debug日志..."</span>);</span><br><span class="line"><span class="comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span></span><br><span class="line">logger.info(<span class="string">"这是info日志..."</span>);</span><br><span class="line">logger.warn(<span class="string">"这是warn日志..."</span>);</span><br><span class="line">logger.error(<span class="string">"这是error日志..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">--</span> </span></span><br><span class="line"><span class="tag">  日志输出格式：</span></span><br><span class="line"><span class="tag">%<span class="attr">d</span>表示日期时间，</span></span><br><span class="line"><span class="tag">%<span class="attr">thread</span>表示线程名，</span></span><br><span class="line"><span class="tag">%<span class="attr">-5level</span>：级别从左显示<span class="attr">5</span>个字符宽度</span></span><br><span class="line"><span class="tag">%<span class="attr">logger</span>&#123;<span class="attr">50</span>&#125; 表示<span class="attr">logger</span>名字最长<span class="attr">50</span>个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="tag">%<span class="attr">msg</span>：日志消息，</span></span><br><span class="line"><span class="tag">%<span class="attr">n</span>是换行符</span></span><br><span class="line"><span class="tag">  <span class="attr">--</span>&gt;</span></span><br><span class="line">  %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br></pre></td></tr></table></figure><p>SpringBoot修改日志的默认配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.com.atguigu</span>=<span class="string">trace</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.path=(过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前项目下生成my.log日志</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">my.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.file=G:/springboot.log(过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.file.path= 文件名  直接在跟目录下创建该文件且自动 帮你创建好 spring.log 文件</span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">/log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件夹；使用 spring.log 作为默认文件</span></span><br><span class="line"><span class="meta">logging.path</span>=<span class="string">/spring/log(过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  在控制台输出的日志的格式</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>logging.file.name</th><th>logging.file.name</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>(none)</td><td>(none)</td><td></td><td>仅控制台记录。</td></tr><tr><td>指定文件名</td><td>(none)</td><td>my.log</td><td>写入指定的日志文件。名称可以是确切的位置，也可以相对于当前目录。</td></tr><tr><td>(none)</td><td>指定目录</td><td>/var/log</td><td>写入<code>spring.log</code>指定的目录。名称可以是确切的位置，也可以相对于当前目录。</td></tr></tbody></table><h3 id="4-2-指定配置"><a href="#4-2-指定配置" class="headerlink" title="4.2.指定配置"></a>4.2.指定配置</h3><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#boot-features-logging" target="_blank" rel="noopener">官方日志文档</a>；给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用他默认配置的了</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>官方建议将<code>-spring</code>变体用于日志记录配置（例如，<code>logback-spring.xml</code>而不是<code>logback.xml</code>）。如果使用标准配置位置，Spring将无法完全控制日志初始化。</p><p>如果用logback.xml：直接就被日志框架识别了；</p><p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，可以使用SpringBoot的高级Profile功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">  可以指定某段配置只在某个环境下生效</span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">%d表示日期时间，</span></span><br><span class="line"><span class="comment">%thread表示线程名，</span></span><br><span class="line"><span class="comment">%-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">%logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">%msg：日志消息，</span></span><br><span class="line"><span class="comment">%n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [%thread] ---&gt; %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [%thread] ==== %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用logback.xml作为日志配置文件，还要使用profile功能，会有以下错误:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no applicable action for [springProfile]</span><br></pre></td></tr></table></figure><h2 id="5-切换日志框架"><a href="#5-切换日志框架" class="headerlink" title="5.切换日志框架"></a>5.切换日志框架</h2><p>可以按照slf4j的日志适配图，进行相关的切换；</p><p>slf4j+log4j的方式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>切换为log4j2:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-最后"><a href="#6-最后" class="headerlink" title="6.最后"></a>6.最后</h2><p>​    此spring boot部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-日志框架&quot;&gt;&lt;a href=&quot;#1-日志框架&quot; class=&quot;headerlink&quot; title=&quot;1.日志框架&quot;&gt;&lt;/a&gt;1.日志框架&lt;/h2&gt;&lt;p&gt;一个统一的接口层；日志门面（日志的一个抽象层）；&lt;/p&gt;
&lt;p&gt;给项目中导入具体的日志实现就行了；之前的日志框架都是实现的抽象层；&lt;/p&gt;
&lt;p&gt;市面上的日志框架:&lt;/p&gt;
&lt;p&gt;JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j……&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot配置文件解析</title>
    <link href="https://quietair.gitee.io/spring-boot-configuration/"/>
    <id>https://quietair.gitee.io/spring-boot-configuration/</id>
    <published>2020-03-05T07:46:27.000Z</published>
    <updated>2020-05-04T07:04:50.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1.配置文件"></a>1.配置文件</h2><p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p><p>•application.properties</p><p>•application.yml</p><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><a id="more"></a><p>YAML（YAML Ain’t Markup Language）</p><p>​    YAML  A Markup Language：是一个标记语言</p><p>​    YAML   isn’t Markup Language：不是一个标记语言；</p><p>标记语言：</p><p>​    以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</p><p>​    YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p><p>​    YAML：配置例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>​    XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-YAML语法："><a href="#2-YAML语法：" class="headerlink" title="2.YAML语法："></a>2.YAML语法：</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1.基本语法"></a>2.1.基本语法</h3><p>k:(空格)v：表示一对键值对（空格必须有）；</p><p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p>属性和值也是大小写敏感；</p><h3 id="2-2-值的写法"><a href="#2-2-值的写法" class="headerlink" title="2.2.值的写法"></a>2.2.值的写法</h3><p><strong>字面量：普通的值（数字，字符串，布尔）</strong></p><p>​    k: v：字面直接来写；</p><p>​        字符串默认不用加上单引号或者双引号；</p><p>​        “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><p>​                name:   “zhangsan \n lisi”：输出；zhangsan 换行  lisi</p><p>​        ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>​                name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</p><h3 id="2-3-对象、Map（属性和值）（键值对）："><a href="#2-3-对象、Map（属性和值）（键值对）：" class="headerlink" title="2.3.对象、Map（属性和值）（键值对）："></a>2.3.对象、Map（属性和值）（键值对）：</h3><p>​    k: v：在下一行来写对象的属性和值的关系；注意缩进</p><p>​        对象还是k: v的方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line"><span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-数组（List、Set）："><a href="#2-4-数组（List、Set）：" class="headerlink" title="2.4.数组（List、Set）："></a>2.4.数组（List、Set）：</h3><p>用- 值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cat</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">dog</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure><h2 id="3-配置文件值注入"><a href="#3-配置文件值注入" class="headerlink" title="3.配置文件值注入"></a>3.配置文件值注入</h2><p>配置文件:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">hello</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">    <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line">    <span class="attr">maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line">    <span class="attr">lists:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zhaoliu</span></span><br><span class="line">    <span class="attr">dog:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">小狗</span></span><br><span class="line">      <span class="attr">age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>javaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>我们可以导入配置文件处理器，以后编写配置就有提示了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-properties配置文件在idea中默认utf-8可能会乱码"><a href="#3-1-properties配置文件在idea中默认utf-8可能会乱码" class="headerlink" title="3.1.properties配置文件在idea中默认utf-8可能会乱码"></a>3.1.properties配置文件在idea中默认utf-8可能会乱码</h3><p>调整:</p><p><img src="/images/spring-boot-configuration/20200302190132.png" alt="idea配置乱码"></p><h3 id="3-2-Value获取值和-ConfigurationProperties获取值比较"><a href="#3-2-Value获取值和-ConfigurationProperties获取值比较" class="headerlink" title="3.2.@Value获取值和@ConfigurationProperties获取值比较"></a>3.2.@Value获取值和@ConfigurationProperties获取值比较</h3><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL(Spring表达式)</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>配置文件yml还是properties他们都能获取到值；</p><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p><p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p><h3 id="3-3-配置文件注入值数据校验"><a href="#3-3-配置文件注入值数据校验" class="headerlink" title="3.3.配置文件注入值数据校验"></a>3.3.配置文件注入值数据校验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><h3 id="3-4-PropertySource-amp-ImportResource-amp-Bean"><a href="#3-4-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="3.4.@PropertySource&amp;@ImportResource&amp;@Bean"></a>3.4.@PropertySource&amp;@ImportResource&amp;@Bean</h3><p>@<strong>PropertySource</strong>：加载指定的配置文件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的<span class="doctag">@ConfigurationProperties</span>功能；</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@ConfigurationProperties</span>(prefix = "person")默认从全局配置文件中获取值；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量、配置文件中获取值/#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName必须是邮箱格式</span></span><br><span class="line">   <span class="comment">// @Email</span></span><br><span class="line">    <span class="comment">//@Value("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure><p>@<strong>ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p><p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p><p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line">导入Spring的配置文件让其生效</span><br></pre></td></tr></table></figure><p>不来编写Spring的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p><p>1、配置类<strong>@Configuration</strong>——&gt;Spring配置文件</p><p>2、使用<strong>@Bean</strong>给容器中添加组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"配置类@Bean给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##4、配置文件占位符</p><p><strong>1.随机数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="keyword">int</span>&#125;、$&#123;random.<span class="keyword">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="keyword">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure><p><strong>2.占位符获取之前配置的值，如果没有可以是用:指定默认值</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2017/12/15</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">14</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">$&#123;person.hello:hello&#125;_dog</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure><h2 id="4-Profile"><a href="#4-Profile" class="headerlink" title="4.Profile"></a>4.Profile</h2><p>Profile是spring对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境。</p><h3 id="4-1-多Profile文件"><a href="#4-1-多Profile文件" class="headerlink" title="4.1.多Profile文件"></a>4.1.多Profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</p><p>默认使用application.properties的配置；</p><h3 id="4-2-yml支持多文档块方式"><a href="#4-2-yml支持多文档块方式" class="headerlink" title="4.2.yml支持多文档块方式"></a>4.2.yml支持多文档块方式</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span> <span class="comment">#指定激活哪个环境</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span>  <span class="comment">#指定属于哪个环境</span></span><br></pre></td></tr></table></figure><h3 id="4-3-激活指定profile"><a href="#4-3-激活指定profile" class="headerlink" title="4.3.激活指定profile"></a>4.3.激活指定profile</h3><p>​    1、在配置文件中指定  spring.profiles.active=dev</p><p>​    2、命令行：</p><p>​        java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev；</p><p>​        可以直接在测试的时候，配置传入命令行参数</p><p>​    3、虚拟机参数；</p><p>​        -Dspring.profiles.active=dev</p><h2 id="5-配置文件加载位置"><a href="#5-配置文件加载位置" class="headerlink" title="5.配置文件加载位置"></a>5.配置文件加载位置</h2><p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><p><img src="/images/spring-boot-configuration/20200304195848.png" alt></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application.properties文件内容</span></span><br><span class="line"><span class="meta">server.post</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment">#server.servlet.context-path=/boot #配置项目得访问路径</span></span><br></pre></td></tr></table></figure><p>–file:./config/</p><p>–file:./</p><p>–classpath:/config/</p><p>–classpath:/</p><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p><p>==我们还可以通过spring.config.location来改变默认的配置文件位置==</p><p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar  G:/application.properties</p><h2 id="6-外部配置加载顺序"><a href="#6-外部配置加载顺序" class="headerlink" title="6.外部配置加载顺序"></a>6.外部配置加载顺序</h2><p><strong>SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</strong></p><p><strong>1.命令行参数</strong></p><p>所有的配置都可以在命令行上进行指定</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p><p>多个配置用空格分开； –配置项=值</p><p>2.来自java:comp/env的JNDI属性</p><p>3.Java系统属性（System.getProperties()）</p><p>4.操作系统环境变量</p><p>5.RandomValuePropertySource配置的random.*属性值</p><p><strong>由jar包外向jar包内进行寻找；</strong></p><p><strong>优先加载带profile</strong></p><p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p><p><strong>再来加载不带profile</strong></p><p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p><p>10.@Configuration注解类上的@PropertySource</p><p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p><p>所有支持的配置加载来源；</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><p><img src="/images/spring-boot-configuration/20200305123720.png" alt="支持的配置"></p><h2 id="7-自动配置原理"><a href="#7-自动配置原理" class="headerlink" title="7.自动配置原理"></a>7.自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h3 id="7-1-自动配置原理："><a href="#7-1-自动配置原理：" class="headerlink" title="7.1.自动配置原理："></a>7.1.<strong>自动配置原理：</strong></h3><p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 <strong>@EnableAutoConfiguration</strong></p><p>2）、<strong>@EnableAutoConfiguration 作用：</strong></p><ul><li>利用EnableAutoConfigurationImportSelector给容器中导入一些组件;<ul><li>可以查看selectImports()方法的内容；</li><li>List<string> configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</string></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames()</span><br><span class="line"><span class="comment">//扫描所有jar包类路径下  META-INF/spring.factories</span></span><br><span class="line"><span class="comment">//把扫描到的这些文件的内容包装成properties对象</span></span><br><span class="line"><span class="comment">//从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中</span></span><br></pre></td></tr></table></figure><p>将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p>3）、每一个自动配置类进行自动配置功能；</p><p>4）、以<strong>HttpEncodingAutoConfiguration（Http编码自动配置）</strong>为例解释自动配置原理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">//表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties<span class="class">.<span class="keyword">class</span>)  //启动指定类的<span class="title">ConfigurationProperties</span>功能；将配置文件中对应的值和<span class="title">HttpEncodingProperties</span>绑定起来；并把<span class="title">HttpEncodingProperties</span>加入到<span class="title">ioc</span>容器中</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span> //<span class="title">Spring</span>底层@<span class="title">Conditional</span>注解（<span class="title">Spring</span>注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是<span class="title">web</span>应用，如果是，当前配置类生效</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(<span class="title">CharacterEncodingFilter</span>.<span class="title">class</span>)  //判断当前项目有没有这个类<span class="title">CharacterEncodingFilter</span>；<span class="title">SpringMVC</span>中进行乱码解决的过滤器；</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">//判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的</span></span><br><span class="line"><span class="comment">//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//他已经和SpringBoot的配置文件映射了</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">//只有一个有参构造器的情况下，参数的值就会从容器中拿</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.properties = properties;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//给容器中添加一个组件，这个组件的某些值需要从properties中获取</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>) //判断容器没有这个组件？</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">CharacterEncodingFilter</span> <span class="title">characterEncodingFilter</span>() </span>&#123;</span><br><span class="line">CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.REQUEST));</span><br><span class="line">filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Type.RESPONSE));</span><br><span class="line"><span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>)  <span class="comment">//从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p><strong>精髓：</strong></p><p>​    <strong>1）、SpringBoot启动会加载大量的自动配置类</strong></p><p>​    <strong>2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；</strong></p><p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p><p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p><p>xxxxAutoConfigurartion：自动配置类；</p><p>给容器中添加组件</p><p>xxxxProperties:封装配置文件中相关属性；</p><h3 id="7-2-细节"><a href="#7-2-细节" class="headerlink" title="7.2.细节"></a>7.2.细节</h3><p><strong>@Conditional派生注解（Spring注解版原生的@Conditional作用）</strong></p><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p><strong>自动配置类必须在一定的条件下才能生效；</strong></p><p>我们怎么知道哪些自动配置类生效；</p><p><strong>我们可以通过启用  debug=true属性；来让控制台打印自动配置报告</strong>，这样我们就可以很方便的知道哪些自动配置类生效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-CONFIGURATION REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">      - @<span class="title">ConditionalOnWebApplication</span> <span class="params">(required)</span> found <span class="title">StandardServletEnvironment</span> <span class="params">(OnWebApplicationCondition)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   AopAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="params">(OnClassCondition)</span></span></span><br></pre></td></tr></table></figure><h2 id="8-最后"><a href="#8-最后" class="headerlink" title="8.最后"></a>8.最后</h2><p>​    此spring boot部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-配置文件&quot;&gt;&lt;a href=&quot;#1-配置文件&quot; class=&quot;headerlink&quot; title=&quot;1.配置文件&quot;&gt;&lt;/a&gt;1.配置文件&lt;/h2&gt;&lt;p&gt;SpringBoot使用一个全局的配置文件，配置文件名是固定的；&lt;/p&gt;
&lt;p&gt;•application.properties&lt;/p&gt;
&lt;p&gt;•application.yml&lt;/p&gt;
&lt;p&gt;配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot入门</title>
    <link href="https://quietair.gitee.io/spring-boot-01/"/>
    <id>https://quietair.gitee.io/spring-boot-01/</id>
    <published>2020-02-29T12:24:00.000Z</published>
    <updated>2020-05-04T07:04:50.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring-Boot-简介"><a href="#1-Spring-Boot-简介" class="headerlink" title="1.Spring Boot 简介"></a>1.Spring Boot 简介</h2><p>-简化Spring应用开发的一个框架；</p><p>-整个Spring技术栈的一个大整合；</p><p>-J2EE开发的一站式解决方案；</p><a id="more"></a><h2 id="2-微服务"><a href="#2-微服务" class="headerlink" title="2.微服务"></a>2.微服务</h2><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p><p>单体应用：ALL IN ONE</p><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="noopener">详细参照微服务文档</a></p><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3.环境准备"></a>3.环境准备</h2><p>环境约束:</p><p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；</p><p>–maven3.x：maven 3.3以上版本；</p><p>–IntelliJIDEA：IntelliJ IDEA </p><p>–SpringBoot 1.5.9.RELEASE：1.5.9；</p><h3 id="3-1-MAVEN设置"><a href="#3-1-MAVEN设置" class="headerlink" title="3.1.MAVEN设置"></a>3.1.MAVEN设置</h3><p>给maven 的settings.xml配置文件的profiles标签添加(可以添加，也可以不用)；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-IDEA设置"><a href="#3-2-IDEA设置" class="headerlink" title="3.2.IDEA设置"></a>3.2.IDEA设置</h3><p>首先对maven进行整合；</p><p><img src="/images/spring-boot-01/20200229191224.png" alt="idea设置"></p><p><img src="/images/spring-boot-01/20200229191357.png" alt="images/"></p><h2 id="4-Spring-Boot-HelloWorld"><a href="#4-Spring-Boot-HelloWorld" class="headerlink" title="4.Spring Boot HelloWorld"></a>4.Spring Boot HelloWorld</h2><p>实现一个简单的功能：</p><p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p><h3 id="4-1-创建一个maven工程（jar）"><a href="#4-1-创建一个maven工程（jar）" class="headerlink" title="4.1.创建一个maven工程（jar）"></a>4.1.创建一个maven工程（jar）</h3><h3 id="4-2-导入spring-boot相关的依赖"><a href="#4-2-导入spring-boot相关的依赖" class="headerlink" title="4.2.导入spring boot相关的依赖"></a>4.2.导入spring boot相关的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-编写一个主程序；启动Spring-Boot应用"><a href="#4-3-编写一个主程序；启动Spring-Boot应用" class="headerlink" title="4.3.编写一个主程序；启动Spring Boot应用"></a>4.3.编写一个主程序；启动Spring Boot应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-编写相关的Controller、Service"><a href="#4-4-编写相关的Controller、Service" class="headerlink" title="4.4.编写相关的Controller、Service"></a>4.4.编写相关的Controller、Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运行主程序测试"><a href="#4-5-运行主程序测试" class="headerlink" title="4.5.运行主程序测试"></a>4.5.运行主程序测试</h3><h3 id="4-6-简化部署"><a href="#4-6-简化部署" class="headerlink" title="4.6.简化部署"></a>4.6.简化部署</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将这个应用打成jar包，再window下或者Linux下直接使用java -jar的命令进行执行；</p><h2 id="5-Hello-World探究"><a href="#5-Hello-World探究" class="headerlink" title="5.Hello World探究"></a>5.Hello World探究</h2><h3 id="5-1-POM文件"><a href="#5-1-POM文件" class="headerlink" title="5.1.POM文件"></a>5.1.POM文件</h3><h4 id="5-1-1父项目"><a href="#5-1-1父项目" class="headerlink" title="5.1.1父项目"></a>5.1.1父项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">上面的父项目是</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">它来真正管理Spring Boot应用里面的所有依赖版本；</span><br></pre></td></tr></table></figure><p>Spring Boot的版本仲裁中心；</p><p>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p><h4 id="5-1-2启动器"><a href="#5-1-2启动器" class="headerlink" title="5.1.2启动器"></a>5.1.2启动器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-boot-starter-<strong>web</strong>：</p><p>​    spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p><p>总结：Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p><h3 id="5-2-主程序类，主入口类"><a href="#5-2-主程序类，主入口类" class="headerlink" title="5.2.主程序类，主入口类"></a>5.2.主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">      @<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p><p>​        标注在某个类上，表示这是一个Spring Boot的配置类；</p><p>​        @<strong>Configuration</strong>:配置类上来标注这个注解；</p><p>​            配置类 —–  配置文件；配置类也是容器中的一个组件；<strong>@Component</strong></p><p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p><p>​        以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>​    @<strong>AutoConfigurationPackage</strong>：自动配置包</p><p>​        @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p><p>​        Spring的底层注解<strong>@Import</strong>，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</p><p>将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；</p><p>​    @<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p><p>​        给容器中导入组件？</p><p>​        <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p><p>​        将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p>​        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；        <img src="/images/spring-boot-01/20200229203810.png" alt="自动配置类"></p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p><p>​        SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p><p>总结：Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；</p><p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p><h2 id="6-IDEA：使用-Spring-Initializer快速创建spring-boot项目"><a href="#6-IDEA：使用-Spring-Initializer快速创建spring-boot项目" class="headerlink" title="6.IDEA：使用 Spring Initializer快速创建spring boot项目"></a>6.IDEA：使用 Spring Initializer快速创建spring boot项目</h2><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p><p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p><p>默认生成的Spring Boot项目；</p><ul><li>主程序已经生成好了，我们只需要我们自己的逻辑</li><li>resources文件夹中目录结构<ul><li>static：保存所有的静态资源； js css  images；</li><li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li></ul></li></ul><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7.最后"></a>7.最后</h2><p>​    此spring boot部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Spring-Boot-简介&quot;&gt;&lt;a href=&quot;#1-Spring-Boot-简介&quot; class=&quot;headerlink&quot; title=&quot;1.Spring Boot 简介&quot;&gt;&lt;/a&gt;1.Spring Boot 简介&lt;/h2&gt;&lt;p&gt;-简化Spring应用开发的一个框架；&lt;/p&gt;
&lt;p&gt;-整个Spring技术栈的一个大整合；&lt;/p&gt;
&lt;p&gt;-J2EE开发的一站式解决方案；&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(五)之Spring原理</title>
    <link href="https://quietair.gitee.io/Java_heart_spring/"/>
    <id>https://quietair.gitee.io/Java_heart_spring/</id>
    <published>2020-02-08T14:49:51.000Z</published>
    <updated>2020-05-04T07:04:49.992Z</updated>
    
    <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是 Spring 仍然可以和其他的框架无缝整合。 </p><h2 id="1-Spring-特点"><a href="#1-Spring-特点" class="headerlink" title="1. Spring 特点"></a>1. Spring 特点</h2><ol><li><strong>轻量级</strong></li><li><strong>控制反转</strong></li><li><strong>面向切面</strong></li><li><strong>容器</strong></li><li><strong>框架集合</strong></li></ol><a id="more"></a><p><img src="/images/Java_heart_spring/clip_image003.gif" alt="img"> </p><h2 id="2-Spring-核心组件"><a href="#2-Spring-核心组件" class="headerlink" title="2. Spring 核心组件"></a>2. Spring 核心组件</h2><p><img src="/images/Java_heart_spring/clip_image005.gif" alt="img"> </p><h2 id="3-Spring-常用模块"><a href="#3-Spring-常用模块" class="headerlink" title="3. Spring 常用模块"></a>3. Spring 常用模块</h2><p><img src="/images/Java_heart_spring/clip_image007.gif" alt="img"> </p><h2 id="4-Spring-主要包"><a href="#4-Spring-主要包" class="headerlink" title="4. Spring 主要包"></a>4. Spring 主要包</h2><p><img src="/images/Java_heart_spring/clip_image009.jpg" alt="img"> </p><h2 id="5-Spring-常用注解"><a href="#5-Spring-常用注解" class="headerlink" title="5. Spring 常用注解"></a>5. Spring 常用注解</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;bean 注入与装配的的方式有很多种，可以通过 xml，get set 方式，构造函数或者注解等。简单易用的方式就是使用 Spring 的注解了，Spring 提供了大量的注解方式。 </p><p><img src="/images/Java_heart_spring/clip_image011.gif" alt="img"> </p><h2 id="6-Spring-第三方结合"><a href="#6-Spring-第三方结合" class="headerlink" title="6. Spring 第三方结合"></a>6. Spring 第三方结合</h2><p><img src="/images/Java_heart_spring/clip_image013.gif" alt="img"> </p><h2 id="7-Spring-IOC原理"><a href="#7-Spring-IOC原理" class="headerlink" title="7.  Spring IOC原理"></a>7.  Spring IOC原理</h2><h3 id="7-1-概念"><a href="#7-1-概念" class="headerlink" title="7.1. 概念"></a>7.1. 概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Spring 通过一个配置文件描述 Bean 及 Bean 之间的依赖关系，利用 Java 语言的反射功能实例化 Bean 并建立 Bean 之间的依赖关系。 Spring 的 IoC 容器在完成这些底层工作的基础上，还提供了 Bean 实例缓存、生命周期管理、 Bean 实例代理、事件发布、资源装载等高级服务。 </p><h3 id="7-2-Spring-容器高层视图"><a href="#7-2-Spring-容器高层视图" class="headerlink" title="7.2. Spring 容器高层视图"></a>7.2. Spring 容器高层视图</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Spring 启动时读取应用程序提供的 Bean 配置信息，并在 Spring 容器中生成一份相应的 Bean 配置注册表，然后根据这张注册表实例化 Bean，装配好 Bean 之间的依赖关系，为上层应用提供准备就绪的运行环境。其中 Bean 缓存池为 HashMap 实现 。</p><p><img src="/images/Java_heart_spring/clip_image015.gif" alt="img"> </p><h3 id="7-3-IOC容器实现"><a href="#7-3-IOC容器实现" class="headerlink" title="7.3. IOC容器实现"></a>7.3. IOC容器实现</h3><p><strong>BeanFactory-框架基础设施</strong> </p><ul><li>BeanFactory 是 Spring 框架的基础设施，面向 Spring 本身；ApplicationContext 面向使用 Spring 框架的开发者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。</li></ul><p><img src="/images/Java_heart_spring/clip_image017.gif" alt="img"> </p><p><strong>BeanDefinitionRegistry注册表</strong> </p><ol><li>Spring 配置文件中每一个节点元素在 Spring 容器里都通过一个 BeanDefinition 对象表示，它描述了 Bean 的配置信息。而 BeanDefinitionRegistry 接口提供了向容器手工注册 BeanDefinition 对象的方法。 </li></ol><p><strong>BeanFactory顶层接口</strong> </p><ol start="2"><li>位于类结构树的顶端 ，它最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的 Bean，BeanFactory 的功能通过其他的接口得到不断扩展： </li></ol><p><strong>ListableBeanFactory</strong></p><ol start="3"><li>该接口定义了访问容器中 Bean 基本信息的若干方法，如查看 Bean 的个数、获取某一类型 Bean 的配置名、查看容器中是否包括某一 Bean 等方法； </li></ol><p><strong>HierarchicalBeanFactory父子级联</strong> </p><ol start="4"><li>父子级联 IoC 容器的接口，子容器可以通过接口方法访问父容器； 通过 HierarchicalBeanFactory 接口， <u>Spring 的 IoC 容器可以建立父子层级关联的容器体系</u>，子容器可以访问父容器中的 Bean，但父容器不能访问子容器的 Bean。Spring 使用父子容器实现了很多功能，比如<u>在 Spring MVC 中，展现层 Bean 位于一个子容器中，而业务层和持久层的 Bean 位于父容器中。这样，展现层 Bean 就可以引用业务层和持久层的 Bean，而业务层和持久层的 Bean 则看不到展现层的 Bean</u>。 </li></ol><p><strong>ConfigurableBeanFactory</strong> </p><ol start="5"><li>是一个重要的接口，增强了 IoC 容器的可定制性，它定义了设置类装载器、属性编辑器、容器初始化后置处理器等方法；</li></ol><p><strong>AutowireCapableBeanFactory自动装配</strong> </p><ol start="6"><li>定义了将容器中的 Bean 按某种规则（如按名字匹配、按类型匹配等）进行自动装配的方法；</li></ol><p><strong>SingletonBeanRegistry运行期间注册单例Bean</strong></p><ol start="7"><li>定义了允许在运行期间向容器注册单实例 Bean 的方法；对于单实例（ singleton）的 Bean 来说，<u>BeanFactory 会缓存 Bean 实例，所以第二次使用 getBean() 获取 Bean 时将直接从 IoC 容器的缓存中获取 Bean 实例</u>。Spring 在 DefaultSingletonBeanRegistry 类中提供了一个用于缓存单实例 Bean 的缓存器，它是一个用 HashMap 实现的缓存器，单实例的 Bean 以 beanName 为键保存在这个 HashMap 中。 </li></ol><p><strong>依赖日志框框</strong> </p><ol start="8"><li><u>在初始化 BeanFactory 时，必须为其提供一种日志框架</u>，比如使用 Log4J， 即在类路径下提供 Log4J 配置文件，这样启动 Spring 容器才不会报错。 </li></ol><p><strong>ApplicationContext面向开发应用</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;ApplicationContext 由 BeanFactory 派 生 而 来 ， 提 供 了 更 多 面 向 实 际 应 用 的 功 能 。ApplicationContext 继承了 HierarchicalBeanFactory 和 ListableBeanFactory 接口，在此基础上，还通过多个其他的接口扩展了 BeanFactory 的功能： </p><p><img src="/images/Java_heart_spring/clip_image019.jpg" alt="img"> </p><ol><li><p>ClassPathXmlApplicationContext：默认从类路径加载配置文件 </p></li><li><p>FileSystemXmlApplicationContext：默认从文件系统中装载配置文件 </p></li><li><p>ApplicationEventPublisher：让容器拥有发布应用上下文事件的功能，包括容器启动事件、关闭事件等。</p></li><li><p>MessageSource：为应用提供 i18n 国际化消息访问的功能；</p></li><li><p>ResourcePatternResolver ： 所 有 ApplicationContext 实现类都实现了类似于 PathMatchingResourcePatternResolver 的功能，可以通过带前缀的 Ant 风格的资源文件路径装载 Spring 的配置文件。 </p></li><li><p>LifeCycle：该接口是 Spring 2.0 加入的，该接口提供了 start()和 stop()两个方法，主要用于控制异步处理过程。在具体使用时，该接口同时被 ApplicationContext 实现及具体 Bean 实现， ApplicationContext 会将 start/stop 的信息传递给容器中所有实现了该接口的 Bean，以达到管理和控制 JMX、任务调度等目的。 </p></li><li><p>ConfigurableApplicationContext 扩展于 ApplicationContext，它新增加了两个主要的方法： <u>refresh()和 close()，让 ApplicationContext 具有启动、刷新和关闭应用上下文的能力</u>。在应用上下文关闭的情况下调用 refresh()即可启动应用上下文，在已经启动的状态下，调用 refresh()则清除缓存并重新装载配置信息，而调用 close()则可关闭应用上下文。 </p></li></ol><p><strong>WebApplication体系架构</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;WebApplicationContext 是专门为 Web 应用准备的，它允许从相对于 Web 根目录的路径中装载配置文件完成初始化工作。从 WebApplicationContext 中可以获得 ServletContext 的引用，<u>整个 Web 应用上下文对象将作为属性放置到 ServletContext 中</u>，以便 Web 应用环境可以访问 Spring 应用上下文。 </p><p><img src="/images/Java_heart_spring/clip_image021.jpg" alt="img"> </p><h3 id="7-4-Spring-Bean-作用域"><a href="#7-4-Spring-Bean-作用域" class="headerlink" title="7.4. Spring Bean 作用域"></a>7.4. Spring Bean 作用域</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Spring 3 中为 Bean 定义了 5 中作用域，分<strong>别为 singleton（单例）、prototype（原型）、 request、session 和 global session</strong>，5 种作用域说明如下： </p><p><strong>singleton：单例模式（多线程下不安全）</strong> </p><ol><li>singleton：单例模式，Spring IoC 容器中只会存在一个共享的 Bean 实例，无论有多少个 Bean 引用它，始终指向同一对象。<u>该模式在多线程下是不安全的</u>。Singleton 作用域是 Spring 中的缺省作用域，也可以显示的将 Bean 定义为 singleton 模式，配置为： </li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.ioc.UserDaoImpl"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>prototype:原型模式每次使用时创建</strong> </p><ol start="2"><li>prototype:原型模式，<u>每次通过 Spring 容器获取 prototype 定义的 bean 时，容器都将创建一个新的 Bean 实例，每个 Bean 实例都有自己的属性和状态</u>，而 singleton 全局只有一个对象。根据经验，<u>对有状态的bean使用prototype作用域，而对无状态的bean使用singleton 作用域</u>。 </li></ol><p><strong>Request：一次request 一个实例</strong> </p><ol start="3"><li>request：在一次 Http 请求中，容器会返回该 Bean 的同一实例。而对不同的 Http 请求则会产生新的 Bean，而且该 bean 仅在当前 Http Request 内有效,当前 Http 请求结束，该 bean 实例也将会被销毁。 </li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginAction"</span> <span class="attr">class</span>=<span class="string">"com.cnblogs.Login"</span> <span class="attr">scope</span>=<span class="string">"request"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>session</strong></p><ol start="4"><li>session：在<u>一次 Http Session 中，容器会返回该 Bean 的同一实例</u>。而对不同的 Session 请求则会创建新的实例，该 bean 实例仅在当前 Session 内有效。同 Http 请求相同，每一次 session 请求创建新的实例，而不同的实例之间不共享属性，且实例仅在自己的 session 请求内有效，请求结束，则实例将被销毁。 </li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreference"</span> <span class="attr">class</span>=<span class="string">"com.ioc.UserPreference"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>global Session</strong></p><ol start="5"><li>global Session：在一个全局的 Http Session 中，容器会返回该 Bean 的同一个实例，仅在使用 portlet context 时有效。 </li></ol><h3 id="7-5-Spring-Bean-生命周期"><a href="#7-5-Spring-Bean-生命周期" class="headerlink" title="7.5. Spring Bean 生命周期"></a>7.5. Spring Bean 生命周期</h3><p><strong>实例化</strong> </p><ol><li>实例化一个 Bean，也就是我们常说的 new。 </li></ol><p><strong>IOC依赖注入</strong> </p><ol start="2"><li>按照 Spring 上下文对实例化的 Bean 进行配置，也就是 IOC 注入。 </li></ol><p><strong>setBeanName实现</strong> </p><ol start="3"><li>如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String) 方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值 </li></ol><p><strong>BeanFactoryAware实现</strong> </p><ol start="4"><li>如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory， setBeanFactory(BeanFactory)传递的是 Spring 工厂自身（可以用这个方式来获取其它 Bean，只需在 Spring 配置文件中配置一个普通的 Bean 就可以）。 </li></ol><p><strong>ApplicationContextAware实现</strong> </p><ol start="5"><li>如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用 setApplicationContext(ApplicationContext)方法，传入 Spring 上下文（同样这个方式也可以实现步骤 4 的内容，但比 4 更好，因为 ApplicationContext 是 BeanFactory 的子接口，有更多的实现方法） </li></ol><p><strong>postProcessBeforeInitialization接口实现-初始化预处理</strong> </p><ol start="6"><li>如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用postProcessBeforeInitialization(Object obj, String s)方法，<u>BeanPostProcessor 经常被用作是 Bean 内容的更改，并且由于这个是在 Bean 初始化结束时调用那个的方法，也可以被应用于内存或缓存技术。</u></li></ol><p><strong>init-method</strong></p><ol start="7"><li>如果 Bean 在 Spring 配置文件中配置了 init-method 属性会自动调用其配置的初始化方法。</li></ol><p><strong>postProcessAfterInitialization</strong></p><ol start="8"><li>如果这个 Bean 关联了 BeanPostProcessor 接口，将会调用postProcessAfterInitialization(Object obj, String s)方法。注：<u>以上工作完成以后就可以应用这个 Bean 了</u>，那这个 Bean 是一个 Singleton 的，所以一般情况下我们调用同一个 id 的 Bean 会是在内容地址相同的实例，当然在 Spring 配置文件中也可以配置非 Singleton。 </li></ol><p><strong>Destroy过期自动清理阶段</strong> </p><ol start="9"><li><p>当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用那个其实现的 destroy()方法；</p><p><strong>destroy-method自配置清理</strong> </p></li><li><p>最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。</p></li></ol><p><img src="/images/Java_heart_spring/clip_image023.gif" alt="img"> </p><ol start="11"><li>bean 标签有两个重要的属性<u>（init-method 和 destroy-method）。用它们你可以自己定制初始化和注销方法。它们也有相应的注解（@PostConstruct 和@PreDestroy）。</u> </li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">init-method</span>=<span class="string">"初始化方法"</span> <span class="attr">destroy-method</span>=<span class="string">"销毁方法"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="7-6-Spring-依赖注入四种方式"><a href="#7-6-Spring-依赖注入四种方式" class="headerlink" title="7.6. Spring 依赖注入四种方式"></a>7.6. Spring 依赖注入四种方式</h3><p><strong>构造器注入</strong> </p><pre><code><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*带参数，方便利用构造器进行注入*/</span>        </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CatDaoImpl</span><span class="params">(String message)</span></span>&#123;      </span><br><span class="line">    <span class="keyword">this</span>. message = message;      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"CatDaoImpl"</span>  <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.CatDaoImpl"</span>&gt;    </span><br><span class="line">    &lt;constructor-arg value=<span class="string">" message  "</span>&gt;</span><br><span class="line">    &lt;/constructor-arg&gt;    </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></code></pre><p><strong>setter方法注入</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Id</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> id;  </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span>  </span>&#123;   </span><br><span class="line">       <span class="keyword">this</span>.id = id;  </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">&lt;bean id=<span class="string">"id"</span>  <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.id "</span>&gt; </span><br><span class="line">    &lt;property name=<span class="string">"id"</span>  value=<span class="string">"123"</span>&gt;</span><br><span class="line">    &lt;/property&gt; </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>静态工厂注入</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;静态工厂顾名思义，就是通过调用静态工厂的方法来获取自己需要的对象，为了让 spring 管理所有对象，我们不能直接通过”工程类.静态方法()”来获取对象，而是依然通过 spring 注入的形式获取： </p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//静态工厂    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">final</span> FactoryDao <span class="title">getStaticFactoryDaoImpl</span><span class="params">()</span></span>&#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  StaticFacotryDaoImpl();     </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;     </span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">SpringAction</span> </span>&#123;     </span><br><span class="line">    <span class="keyword">private</span> FactoryDao  staticFactoryDao; </span><br><span class="line">    <span class="comment">//注入对象       //注入对象的 set 方法       </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStaticFactoryDao</span><span class="params">(FactoryDao  staticFactoryDao)</span> </span>&#123;       </span><br><span class="line">        <span class="keyword">this</span>.staticFactoryDao = staticFactoryDao;      </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//factory-method="getStaticFactoryDaoImpl"指定调用哪个工厂方法     </span></span><br><span class="line">&lt;bean name=<span class="string">"springAction"</span>  <span class="class"><span class="keyword">class</span></span>=<span class="string">" SpringAction"</span> &gt;         </span><br><span class="line">    &lt;!--使用静态工厂的方法注入对象,对应下面的配置文件--&gt;          </span><br><span class="line">    &lt;property name="staticFactoryDao"  ref="staticFactoryDao"&gt;&lt;/property&gt;       </span><br><span class="line">&lt;/bean&gt;      </span><br><span class="line">    </span><br><span class="line">&lt;!--此处获取对象的方式是从工厂类中获取静态方法--&gt;    </span><br><span class="line">&lt;bean name=<span class="string">"staticFactoryDao"</span>  <span class="class"><span class="keyword">class</span></span>=<span class="string">"DaoFactory"</span> factory-method=<span class="string">"getStaticFactoryDaoImpl"</span>&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><strong>实例工厂</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;实例工厂的意思是获取对象实例的方法不是静态的，所以你需要首先 new 工厂类，再调用普通的实例方法： </p>  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//实例工厂    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FactoryDao <span class="title">getFactoryDaoImpl</span><span class="params">()</span></span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FactoryDaoImpl();  </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringAction</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> FactoryDao  factoryDao;   </span><br><span class="line">    <span class="comment">//注入对象       </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactoryDao</span><span class="params">(FactoryDao  factoryDao)</span> </span>&#123;      </span><br><span class="line">        <span class="keyword">this</span>.factoryDao  = factoryDao;      </span><br><span class="line">    &#125;     </span><br><span class="line">&#125;      </span><br><span class="line">&lt;bean name=<span class="string">"springAction"</span>  <span class="class"><span class="keyword">class</span></span>=<span class="string">"SpringAction"</span>&gt;        </span><br><span class="line">    &lt;!--使用实例工厂的方法注入对象,对应下面的配置文件--&gt;        </span><br><span class="line">    &lt;property  name="factoryDao" ref="factoryDao"&gt;&lt;/property&gt;    </span><br><span class="line">&lt;/bean&gt; </span><br><span class="line">    </span><br><span class="line">&lt;!--此处获取对象的方式是从工厂类中获取实例方法--&gt;    </span><br><span class="line">&lt;bean name="daoFactory"  class="com.DaoFactory"&gt;&lt;/bean&gt;    </span><br><span class="line">&lt;bean  name="factoryDao" factory-bean="daoFactory"   factory-method="getFactoryDaoImpl"&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="7-7-五种不同方式的自动装配"><a href="#7-7-五种不同方式的自动装配" class="headerlink" title="7.7. 五种不同方式的自动装配"></a>7.7. 五种不同方式的自动装配</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Spring 装配包括<strong>手动装配和自动装配</strong>，手动装配是有基于 xml 装配、构造方法、setter 方法等 自动装配有五种自动装配的方式，可以用来指导 Spring 容器用自动装配方式来进行依赖注入。</p><ol><li><p>no：默认的方式是不进行自动装配，通过显式设置 ref 属性来进行装配。 </p></li><li><p>byName：通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire 属性被设置成 byname，之后容器试图匹配、装配和该 bean 的属性具有相同名字的 bean。 </p></li><li><p>byType：通过参数类型自动装配，Spring 容器在配置文件中发现 bean 的 autowire 属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个 bean 符合条件，则抛出错误。 </p></li><li><p>constructor：这个方式类似于 byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。 </p></li><li><p>autodetect：首先尝试使用constructor 来自动装配，如果无法工作，则使用byType方式。 </p></li></ol><h2 id="8-Spring-APO原理"><a href="#8-Spring-APO原理" class="headerlink" title="8. Spring APO原理"></a>8. Spring APO原理</h2><h3 id="8-1-概念"><a href="#8-1-概念" class="headerlink" title="8.1. 概念"></a>8.1. 概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;使用”横切”技术，AOP 把软件系统分为两个部分：<strong>核心关注点和横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 </p><p>AOP 主要应用场景有： </p><ol><li><p>Authentication 权限 </p></li><li><p>Caching 缓存 </p></li><li><p>Context passing 内容传递 </p></li><li><p>Error handling 错误处理 </p></li><li><p>Lazy loading 懒加载 </p></li><li><p>Debugging 调试 </p></li><li><p>logging, tracing, profiling and monitoring 记录跟踪 优化 校准 </p></li><li><p>Performance optimization 性能优化 </p></li><li><p>Persistence 持久化 </p></li><li><p>Resource pooling 资源池 </p></li><li><p>Synchronization 同步 </p></li><li><p>Transactions 事务</p></li></ol><h3 id="8-2-AOP核心概念"><a href="#8-2-AOP核心概念" class="headerlink" title="8.2. AOP核心概念"></a>8.2. AOP核心概念</h3><ol><li><p>切面（aspect）：类是对物体特征的抽象，切面就是对横切关注点的抽象</p></li><li><p>横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点。</p></li><li><p>连接点（joinpoint）：被拦截到的点，因为 Spring 只支持方法类型的连接点，所以在 Spring 中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器。 </p></li><li><p>切入点（pointcut）：对连接点进行拦截的定义</p></li><li><p>通知（advice）：所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类。 </p></li><li><p>目标对象：代理的目标对象 </p></li><li><p>织入（weave）：将切面应用到目标对象并导致代理对象创建的过程 8、引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段。</p></li></ol><p>参考：<a href="https://segmentfault.com/a/1190000007469968" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007469968</a></p><p><img src="/images/Java_heart_spring/clip_image025.gif" alt="img"> </p><h3 id="8-3-AOP两种代理方式"><a href="#8-3-AOP两种代理方式" class="headerlink" title="8.3. AOP两种代理方式"></a>8.3. AOP两种代理方式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Spring 提供了两种方式来生成代理对象: JDKProxy 和 Cglib，具体使用哪种方式生成由 AopProxyFactory 根据 AdvisedSupport 对象的配置来决定。<strong>默认的策略是如果目标类是接口，则使用 JDK 动态代理技术，否则使用 Cglib 来生成代理。</strong> </p><p><strong>JDK动态接口代理</strong> </p><ol><li>JDK 动态代理主要涉及到 java.lang.reflect 包中的两个类：Proxy 和 InvocationHandler。 InvocationHandler是一个接口，通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态将横切逻辑和业务逻辑编制在一起。Proxy 利用 InvocationHandler 动态创建一个符合某一接口的实例，生成目标类的代理对象。 </li></ol><p><strong>CGLib动态代理</strong> </p><ol start="2"><li>：CGLib 全称为 Code Generation Library，是一个强大的高性能，<strong>高质量的代码生成类库，可以在运行期扩展 Java 类与实现 Java 接口</strong>，CGLib 封装了 asm，可以再运行期动态生成新的 class。和 JDK 动态代理相比较：JDK 创建代理有一个限制，就是只能为接口创建代理实例，而对于没有通过接口定义业务方法的类，则可以通过 CGLib 创建动态代理。 </li></ol><h3 id="8-4-实现原理"><a href="#8-4-实现原理" class="headerlink" title="8.4. 实现原理"></a>8.4. 实现原理</h3>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionDemo</span> </span>&#123;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut</span>(value=<span class="string">"execution(*  com.yangxin.core.service.*.*.*(..))"</span>)    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">point</span><span class="params">()</span></span>&#123;       </span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before</span>(value=<span class="string">"point()"</span>)   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">"transaction  begin"</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning</span>(value =  <span class="string">"point()"</span>)   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">"transaction  commit"</span>);     </span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"point()"</span>)       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span>  Throwable</span>&#123;      </span><br><span class="line">        System.out.println(<span class="string">"transaction begin"</span>);     </span><br><span class="line">        joinPoint.proceed();       </span><br><span class="line">        System.out.println(<span class="string">"transaction  commit"</span>);    </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/Java_heart_spring/clip_image027.jpg" alt="img"> </p><h2 id="9-Spring-MVC原理"><a href="#9-Spring-MVC原理" class="headerlink" title="9. Spring MVC原理"></a>9. Spring MVC原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Spring 的模型-视图-控制器（MVC）框架是围绕一个 DispatcherServlet 来设计的，这个 Servlet 会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。</p><h3 id="9-1-MVC流程"><a href="#9-1-MVC流程" class="headerlink" title="9.1. MVC流程"></a>9.1. MVC流程</h3><p><img src="/images/Java_heart_spring/clip_image029.jpg" alt="img"> </p><p><strong>Http请求到DispatcherServlet</strong></p><ol><li>客户端请求提交到 DispatcherServlet。 </li></ol><p><strong>HandlerMapping寻找处理器</strong> </p><ol start="2"><li>由 DispatcherServlet 控制器查询一个或多个 HandlerMapping，找到处理请求的Controller。 </li></ol><p><strong>调用处理器Controller</strong></p><ol start="3"><li>DispatcherServlet 将请求提交到 Controller。 </li></ol><p><strong>Controller调用业务逻辑处理后，返回ModelAndView</strong></p><ol start="4"><li>调用业务处理和返回结果：Controller 调用业务逻辑处理后，返回 ModelAndView。 </li></ol><p><strong>DispatcherServlet查询ModelAndView</strong></p><ol start="5"><li>处理视图映射并返回模型： DispatcherServlet 查询一个或多个 ViewResoler 视图解析器，找到 ModelAndView 指定的视图。 </li></ol><p><strong>ModelAndView反馈浏览器HTTP</strong></p><ol start="6"><li>Http 响应：视图负责将结果显示到客户端。</li></ol><h3 id="9-2-MVC-常用注解"><a href="#9-2-MVC-常用注解" class="headerlink" title="9.2. MVC 常用注解"></a>9.2. MVC 常用注解</h3><p><img src="/images/Java_heart_spring/clip_image031.gif" alt="img"> </p><h2 id="10-Spring-Boot原理"><a href="#10-Spring-Boot原理" class="headerlink" title="10. Spring Boot原理"></a>10. Spring Boot原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot 致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。其特点如下： </p><ol><li><p><strong>创建独立的 Spring 应用程序</strong></p></li><li><p><strong>嵌入的 Tomcat，无需部署WAR文件</strong> </p></li><li><p><strong>简化 Maven 配置</strong> </p></li><li><p><strong>自动配置 Spring</strong> </p></li><li><p><strong>提供生产就绪型功能，如指标，健康检查和外部配置</strong> </p></li><li><p><strong>绝对没有代码生成和对 XML 没有要求配置 [1]</strong> </p></li></ol><h2 id="11-JPA原理"><a href="#11-JPA原理" class="headerlink" title="11. JPA原理"></a>11. JPA原理</h2><h3 id="11-1-事务"><a href="#11-1-事务" class="headerlink" title="11.1. 事务"></a>11.1. 事务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;事务是计算机应用中不可或缺的组件模型，它保证了用户操作的原子性 ( Atomicity )、一致性 ( Consistency )、隔离性 ( Isolation ) 和持久性 ( Durabilily )。 </p><h3 id="11-2-本地事务"><a href="#11-2-本地事务" class="headerlink" title="11.2. 本地事务"></a>11.2. 本地事务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;紧密依赖于底层资源管理器（例如数据库连接 )，事务<strong>处理局限在当前事务资源内</strong>。此种事务处理方式不存在对应用服务器的依赖，因而部署灵活却无法支持多数据源的分布式事务。在数据库连接中使用本地事务示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferAccount</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">    Connection conn = <span class="keyword">null</span>;         </span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;          </span><br><span class="line">    <span class="keyword">try</span>&#123;             </span><br><span class="line">        conn = getDataSource().getConnection();    </span><br><span class="line">        <span class="comment">// 将自动提交设置为 false，若设置为 true 则数据库将会把每一次数据更新认定为一个事务并自动提交          </span></span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>);         </span><br><span class="line">        stmt = conn.createStatement();             </span><br><span class="line">        <span class="comment">// 将 A 账户中的金额减少 500          </span></span><br><span class="line">        stmt.execute(<span class="string">"update t_account set  amount = amount - 500 where account_id = 'A'"</span>); </span><br><span class="line">        <span class="comment">// 将 B 账户中的金额增加 500          </span></span><br><span class="line">        stmt.execute(<span class="string">"update t_account set  amount = amount + 500 where account_id = 'B'"</span>);             </span><br><span class="line">        <span class="comment">// 提交事务            </span></span><br><span class="line">        conn.commit();           </span><br><span class="line">        <span class="comment">// 事务提交：转账的两步操作同时成功          </span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(SQLException sqle)&#123;                        </span><br><span class="line">        <span class="comment">//  发生异常，回滚在本事务中的操做                             </span></span><br><span class="line">        conn.rollback();                 </span><br><span class="line">        <span class="comment">//  事务回滚：转账的两步操作完全撤销                            </span></span><br><span class="line">        stmt.close();                               </span><br><span class="line">        conn.close();         </span><br><span class="line">    &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-3-分布式事务"><a href="#11-3-分布式事务" class="headerlink" title="11.3. 分布式事务"></a>11.3. 分布式事务</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 事务编程接口（JTA：Java Transaction API）和 Java 事务服务 (JTS；Java Transaction Service) 为 J2EE 平台提供了分布式事务服务。分布式事务（Distributed Transaction）包括事务管理器（Transaction Manager）和一个或多个支持 XA 协议的资源管理器 ( Resource Manager )。我们可以将资源管理器看做任意类型的持久化数据存储；事务管理器承担着所有事务参与单元的协调与控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">transferAccount</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">     UserTransaction userTx  = <span class="keyword">null</span>;        </span><br><span class="line">     Connection connA = <span class="keyword">null</span>; Statement stmtA =  <span class="keyword">null</span>;      </span><br><span class="line">     Connection connB = <span class="keyword">null</span>; Statement stmtB =  <span class="keyword">null</span>;    </span><br><span class="line">     <span class="keyword">try</span>&#123;   </span><br><span class="line">         <span class="comment">//  获得 Transaction 管理对象   </span></span><br><span class="line">         userTx = (UserTransaction)getContext().lookup(<span class="string">"java:comp/UserTransaction"</span>);     </span><br><span class="line">         connA  = getDataSourceA().getConnection();<span class="comment">// 从数据库 A 中取得数据库连接   </span></span><br><span class="line">         connB =  getDataSourceB().getConnection();<span class="comment">// 从数据库 B 中取得数据库连接    </span></span><br><span class="line">         userTx.begin();   <span class="comment">// 启动事务   </span></span><br><span class="line">         </span><br><span class="line">         stmtA = connA.createStatement();<span class="comment">// 将 A 账户中的金额减少 500 </span></span><br><span class="line">         </span><br><span class="line">         stmtA.execute(<span class="string">"update  t_account set amount = amount - 500 where account_id = 'A'"</span>);             <span class="comment">// 将 B 账户中的金额增加 500             </span></span><br><span class="line">         stmtB = connB.createStatement();   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         stmtB.execute(<span class="string">"update t_account set amount = amount + 500 where account_id = 'B'"</span>);       </span><br><span class="line">         userTx.commit();<span class="comment">// 提交事务</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 事务提交：转账的两步操作同时成功（数据库 A 和数据库 B 中的数据被同时更新） </span></span><br><span class="line">     &#125; <span class="keyword">catch</span>(SQLException sqle)&#123; </span><br><span class="line">         <span class="comment">// 发生异常，回滚在本事务中的操纵 </span></span><br><span class="line"></span><br><span class="line">         userTx.rollback();<span class="comment">// 事务回滚：数据库 A 和数据库 B 中的数据更新被同时撤销    </span></span><br><span class="line">     &#125; <span class="keyword">catch</span>(Exception ne)&#123; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11-4-两阶段提交"><a href="#11-4-两阶段提交" class="headerlink" title="11.4.两阶段提交"></a>11.4.两阶段提交</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做，所谓的两个阶段是指：<strong>第一阶段：准备阶段；第二阶段：提交阶段。</strong> </p><p><img src="/images/Java_heart_spring/clip_image033.gif" alt="img"> </p><h4 id="11-4-1-准备阶段"><a href="#11-4-1-准备阶段" class="headerlink" title="11.4.1.准备阶段:"></a>11.4.1.准备阶段:</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回失败(如权限验证失败)，<strong>要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交</strong>，到达一种“万事俱备，只欠东风”的状态。 </p><h4 id="11-4-2提交阶段："><a href="#11-4-2提交阶段：" class="headerlink" title="11.4.2提交阶段："></a>11.4.2提交阶段：</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:<strong>必须在最后阶段释放锁资源</strong>) 将提交分成两阶段进行的目的很明确，就是尽可能晚地提交事务，让事务在提交前尽可能地完成所有能完成的工作。</p><h2 id="12-Mybatis缓存"><a href="#12-Mybatis缓存" class="headerlink" title="12. Mybatis缓存"></a>12. Mybatis缓存</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Mybatis中有一级缓存和二级缓存，默认情况下一级缓存是开启的，而且是不能关闭的。一级缓存是指 SqlSession 级别的缓存，当在同一个 SqlSession 中进行相同的 SQL 语句查询时，第二次以后的查询不会从数据库查询，而是直接从缓存中获取，一级缓存最多缓存 1024 条 SQL。二级缓存是指可以跨 SqlSession 的缓存。是 mapper 级别的缓存，对于 mapper 级别的缓存不同的 sqlsession 是可以共享的。 </p><p><img src="/images/Java_heart_spring/clip_image035.gif" alt="img"> </p><h3 id="12-1-Mybatis的一级缓存原理（sqlsession级别）"><a href="#12-1-Mybatis的一级缓存原理（sqlsession级别）" class="headerlink" title="12.1. Mybatis的一级缓存原理（sqlsession级别）"></a>12.1. Mybatis的一级缓存原理（sqlsession级别）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;第一次发出一个查询 sql，sql 查询结果写入 sqlsession 的一级缓存中，缓存使用的数据结构是一个 map。 </p><p><strong>key：MapperID+offset+limit+Sql+所有的入参</strong> </p><p>value：用户信息 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;同一个 sqlsession 再次发出相同的 sql，就从缓存中取出数据。<u>如果两次中间出现 commit 操作（修改、添加、删除），本 sqlsession 中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。</u></p><h3 id="12-2-二级缓存原理（mapper基本）"><a href="#12-2-二级缓存原理（mapper基本）" class="headerlink" title="12.2. 二级缓存原理（mapper基本）"></a>12.2. 二级缓存原理（mapper基本）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;二级缓存的范围是mapper 级别（mapper同一个命名空间），mapper以命名空间为单位创建缓存数据结构，结构是 map。mybatis 的二级缓存是通过 CacheExecutor 实现的。CacheExecutor 其实是 Executor 的代理对象。所有的查询操作，在 CacheExecutor 中都会先匹配缓存中是否存在，不存在则查询数据库。</p><p><strong>key：MapperID+offset+limit+Sql+所有的入参</strong></p><p><strong>具体使用需要配置</strong>： </p><ol><li><p>Mybatis 全局配置中启用二级缓存配置 </p></li><li><p>在对应的 Mapper.xml 中配置 cache 节点 </p></li><li><p>在对应的 select 查询节点中添加 useCache=true </p></li></ol><h2 id="13-最后"><a href="#13-最后" class="headerlink" title="13. 最后"></a>13. 最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;它是一个全面的、企业应用开发一站式的解决方案，贯穿表现层、业务层、持久层。但是 Spring 仍然可以和其他的框架无缝整合。 &lt;/p&gt;
&lt;h2 id=&quot;1-Spring-特点&quot;&gt;&lt;a href=&quot;#1-Spring-特点&quot; class=&quot;headerlink&quot; title=&quot;1. Spring 特点&quot;&gt;&lt;/a&gt;1. Spring 特点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;轻量级&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制反转&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向切面&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;框架集合&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
      <category term="Spring" scheme="https://quietair.gitee.io/tags/Spring/"/>
    
      <category term="Mybatis" scheme="https://quietair.gitee.io/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Java核心(四)之JAVA基础</title>
    <link href="https://quietair.gitee.io/Java_heart_base/"/>
    <id>https://quietair.gitee.io/Java_heart_base/</id>
    <published>2020-01-18T09:06:29.000Z</published>
    <updated>2020-05-04T07:04:49.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JAVA异常分类及处理"><a href="#1-JAVA异常分类及处理" class="headerlink" title="1.JAVA异常分类及处理"></a>1.JAVA异常分类及处理</h2><h3 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1.概念"></a>1.1.概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。</p><a id="more"></a><p><img src="/images/Java_heart_base/clip_image003.gif" alt="img"> </p><h3 id="1-2-异常分类"><a href="#1-2-异常分类" class="headerlink" title="1.2.  异常分类"></a>1.2.  异常分类</h3><p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception </p><p><strong>Error</strong></p><ol><li>Error 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。 </li></ol><p><strong>Exception（RuntimeException、CheckedException）</strong> </p><ol start="2"><li>Exception 又 有 两 个 分 支 ， 一 个 是 运 行 时 异 常 RuntimeException ， 一 个是 CheckedException。 </li></ol><p><strong>RuntimeException</strong> 如 ： NullPointerException 、 ClassCastException ； 一 个 是 检 查 异 常 CheckedException，如 I/O 错误导致的 IOException、SQLException。 RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一定是程序员的错误. </p><p><strong>检查异常 CheckedException</strong>：一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面： </p><ol><li><p>试图在文件尾部读取数据 </p></li><li><p>试图打开一个错误格式的 URL </p></li><li><p>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在</p></li></ol><h3 id="1-3-异常的处理方式"><a href="#1-3-异常的处理方式" class="headerlink" title="1.3.  异常的处理方式"></a>1.3.  异常的处理方式</h3><p>遇到问题不进行具体处理，而是继续抛给调用者 （<strong>throw,throws</strong>） </p><p>抛出异常有三种形式，一是 throw,一个 throws，还有一种系统自动抛异常。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> String s = <span class="string">"abc"</span>;</span><br><span class="line"> <span class="keyword">if</span>(s.equals(<span class="string">"abc"</span>)) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> NumberFormatException();</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> System.out.println(s);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try catch捕获异常针对性处理方式</strong> </p><h3 id="1-4-Throw-和-throws-的区别："><a href="#1-4-Throw-和-throws-的区别：" class="headerlink" title="1.4.  Throw 和 throws 的区别："></a>1.4.  Throw 和 throws 的区别：</h3><p><strong>位置不同 :</strong></p><ol><li><p><strong>throws 用在函数上</strong>，后面跟的是异常类，可以跟多个；而 throw 用在函数内，后面跟的是异常对象。 功能不同： </p></li><li><p><strong>throws 用来声明异常，让调用者只知道该功能可能出现的问题</strong>，可以给出预先的处理方式；<strong>throw抛出具体的问题对象，执行到throw，功能就已经结束了</strong>，跳转到调用者，并将具体的问题对象抛给调用者。也就是说 throw 语句独立存在时，下面不要定义其他语句，因为执行不到。 </p></li><li><p><strong>throws 表示出现异常的一种可能性</strong>，并不一定会发生这些异常；throw 则是抛出了异常，执行 throw 则一定抛出了某种异常对象。 </p></li><li><p>两者都是消极处理异常的方式，只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。</p></li></ol><h2 id="2-JAVA-反射"><a href="#2-JAVA-反射" class="headerlink" title="2.JAVA 反射"></a>2.JAVA 反射</h2><h3 id="2-1-动态语言"><a href="#2-1-动态语言" class="headerlink" title="2.1.  动态语言"></a>2.1.  动态语言</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。 </p><h3 id="2-2-反射机制概念（运行状态中知道类所有的属性和方法）"><a href="#2-2-反射机制概念（运行状态中知道类所有的属性和方法）" class="headerlink" title="2.2.反射机制概念（运行状态中知道类所有的属性和方法）"></a>2.2.反射机制概念（运行状态中知道类所有的属性和方法）</h3><p><img src="/images/Java_heart_base/clip_image005.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Java 中的反射机制是指<u>在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法</u>；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。 </p><h3 id="2-3-反射的应用场合"><a href="#2-3-反射的应用场合" class="headerlink" title="2.3.  反射的应用场合"></a>2.3.  反射的应用场合</h3><p><strong>编译时类型和运行时类型</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> Student(); </span><br><span class="line"><span class="comment">//其中编译时类型为 Person，运行时类型为 Student。</span></span><br></pre></td></tr></table></figure><p><strong>的编译时类型无法获取具体方法</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;程序在运行时还可能接收到外部传入的对象，该<strong>对象的编译时类型为 Object</strong>,但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，<strong>程序需要在运行时发现对象和类的真实信息</strong>。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</p><h3 id="2-4-Java-反射-API"><a href="#2-4-Java-反射-API" class="headerlink" title="2.4.  Java 反射 API"></a>2.4.  Java 反射 API</h3><p><strong>反射API用来生成JVM中的类、接口或则对象的信息。</strong> </p><ol><li><p>Class 类：反射的核心类，可以获取类的属性，方法等信息。 </p></li><li><p>Field 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。 </p></li><li><p>Method 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。 </p></li><li><p>Constructor 类： Java.lang.reflec 包中的类，表示类的构造方法。 </p></li></ol><h3 id="2-5-反射使用步骤（获取-Class-对象、调用对象方法）"><a href="#2-5-反射使用步骤（获取-Class-对象、调用对象方法）" class="headerlink" title="2.5.  反射使用步骤（获取 Class 对象、调用对象方法）"></a>2.5.  反射使用步骤（获取 Class 对象、调用对象方法）</h3><ol><li><p>获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。 </p></li><li><p>调用 Class 类中的方法，既就是反射的使用阶段。</p></li><li><p>使用反射 API 来操作这些信息。</p></li></ol><h3 id="2-6-获取-Class-对象的-3-种方法"><a href="#2-6-获取-Class-对象的-3-种方法" class="headerlink" title="2.6.  获取 Class 对象的 3 种方法"></a>2.6.  获取 Class 对象的 3 种方法</h3><p><strong>调用某个对象的getClass()方法</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> Person(); </span><br><span class="line">Class clazz=p.getClass();</span><br></pre></td></tr></table></figure><p><strong>调用某个类的class属性来获取该类对应的Class对象</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz=Person<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></table></figure><p><strong>使用Class类中的forName()静态方法(最安全性能最好)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz=Class.forName(<span class="string">"类的全路径"</span>); (最常用)</span><br></pre></td></tr></table></figure><p><strong>当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法和属性。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 Person 类的 Class 对象</span></span><br><span class="line">Class clazz=Class.forName(<span class="string">"reflection.Person"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Person 类的所有方法信息</span></span><br><span class="line">Method[] method=clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:method)&#123;</span><br><span class="line">System.out.println(m.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Person 类的所有成员属性信息</span></span><br><span class="line">Field[] field=clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span>(Field f:field)&#123;</span><br><span class="line">System.out.println(f.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Person 类的所有构造方法信息</span></span><br><span class="line">Constructor[] constructor=clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor c:constructor)&#123;</span><br><span class="line">System.out.println(c.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-创建对象的两种方法"><a href="#2-7-创建对象的两种方法" class="headerlink" title="2.7.  创建对象的两种方法"></a>2.7.  创建对象的两种方法</h3><p><strong>Class对象的newInstance()</strong></p><ol><li>使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。 </li></ol><p><strong>调用Constructor对象的newInstance()</strong></p><ol start="2"><li>先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。   </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取 Person 类的 Class 对象 </span></span><br><span class="line">Class clazz=Class.forName(<span class="string">"reflection.Person"</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">//使用.newInstane 方法创建对象 </span></span><br><span class="line">Person p=(Person) clazz.newInstance(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取构造方法并创建对象 </span></span><br><span class="line">Constructor c=clazz.getDeclaredConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建对象并设置属性 </span></span><br><span class="line">Person p1=(Person) c.newInstance(<span class="string">"李四"</span>,<span class="string">"男"</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h2 id="3-JAVA注解"><a href="#3-JAVA注解" class="headerlink" title="3.JAVA注解"></a>3.JAVA注解</h2><h3 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1. 概念"></a>3.1. 概念</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Annotation（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。<strong>Annatation(注解)是一个接口</strong>，程序可以通过反射来获取指定程序中元素的 Annotation 对象，然后通过该 Annotation 对象来获取注解中的元数据信息。</p><h3 id="3-2-4-种标准元注解"><a href="#3-2-4-种标准元注解" class="headerlink" title="3.2.   4 种标准元注解"></a>3.2.   4 种标准元注解</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。 </p><p><strong>@Target修饰的对象范围</strong> </p><p>@Target说明了Annotation所修饰的对象范围： Annotation<u>可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）</u>。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标</p><p><strong>@Retention定义被保留的时间长短</strong> </p><p><strong>Retention 定义了该 Annotation 被保留的时间长短</strong>：表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）由： </p><ul><li><p>SOURCE:在源文件中有效（即源文件保留） </p></li><li><p>CLASS:在 class 文件中有效（即 class 保留） </p></li><li><p>RUNTIME:在运行时有效（即运行时保留）</p></li></ul><p><strong>@Documented 描述-javadoc</strong> </p><p>@ Documented 用于描述其它类型的 annotation 应该被作为被标注的程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。 </p><p><strong>@Inherited 阐述了某个被标注的类型是被继承的</strong> </p><p>@Inherited 元注解是一个标记注解，<strong>@Inherited 阐述了某个被标注的类型是被继承的</strong>。如果一个使用了@Inherited 修饰的 annotation 类型被用于一个 class，则这个 annotation 将被用于该 class 的子类。 </p><p><img src="/images/Java_heart_base/clip_image007.jpg" alt="img"> </p><h3 id="3-3-注解处理器"><a href="#3-3-注解处理器" class="headerlink" title="3.3. 注解处理器"></a>3.3. 注解处理器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5扩展了反射机制的API，以帮助程序员快速的构造自定义注解处理器。下面实现一个注解处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1：*** 定义注解 */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FruitProvider &#123;</span><br><span class="line"><span class="comment">/* * 供应商编号*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"><span class="comment">/* ** 供应商名称*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""；</span></span><br><span class="line"><span class="function"><span class="comment">/* *** 供应商地址*/</span></span></span><br><span class="line"><span class="function"> <span class="keyword">public</span> String <span class="title">address</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2：注解使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line"> <span class="meta">@FruitProvider</span>(id = <span class="number">1</span>, name = <span class="string">"陕西红富士集团"</span>, address = <span class="string">"陕西省西安市延安路"</span>)</span><br><span class="line"> <span class="keyword">private</span> String appleProvider;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppleProvider</span><span class="params">(String appleProvider)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.appleProvider = appleProvider;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getAppleProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> appleProvider;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*3：*********** 注解处理器 *************** */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitInfoUtil</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getFruitInfo</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line"> String strFruitProvicer = <span class="string">"供应商信息："</span>;</span><br><span class="line"> Field[] fields = clazz.getDeclaredFields();<span class="comment">//通过反射获取处理注解</span></span><br><span class="line"> <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line"> <span class="keyword">if</span> (field.isAnnotationPresent(FruitProvider<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line"> FruitProvider fruitProvider = (FruitProvider)  field.getAnnotation(FruitProvider<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//注解信息的处理地方</span></span><br><span class="line">strFruitProvicer = <span class="string">" 供应商编号："</span> + fruitProvider.id() + <span class="string">" 供应商名称："</span> + fruitProvider.name() + <span class="string">" 供应商地址："</span>+ fruitProvider.address();</span><br><span class="line"> System.out.println(strFruitProvicer);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitRun</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> FruitInfoUtil.getFruitInfo(Apple<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">/* **********输出结果************** */</span></span><br><span class="line"><span class="comment">// 供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-JAVA-内部类"><a href="#4-JAVA-内部类" class="headerlink" title="4. JAVA 内部类"></a>4. JAVA 内部类</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 类中不仅可以定义变量和方法，还可以定义类，这样定义在类内部的类就被称为内部类。根据定义的方式不同，内部类分为静态内部类，成员内部类，局部内部类，匿名内部类四种。</p><h3 id="4-1-静态内部类"><a href="#4-1-静态内部类" class="headerlink" title="4.1. 静态内部类"></a>4.1. 静态内部类</h3><p>定义在类内部的静态类，就是静态内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;         </span><br><span class="line">            System.out.println(a);       </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>静态内部类可以访问外部类所有的静态变量和方法，即使是 private 的也一样。 </p></li><li><p>静态内部类和一般类一致，可以定义静态变量、方法，构造方法等。 </p></li><li><p>其它类使用静态内部类需要使用“外部类.静态内部类”方式，如下所示：Out.Inner inner = new Out.Inner();inner.print(); </p></li><li><p><strong>Java集合类HashMap内部就有一个静态内部类Entry</strong>。Entry是HashMap存放元素的抽象， HashMap 内部维护 Entry 数组用了存放元素，但是 Entry 对使用者是透明的。像这种和外部类关系密切的，且不依赖外部类实例的，都可以使用静态内部类。 </p></li></ol><h3 id="4-2-成员内部类"><a href="#4-2-成员内部类" class="headerlink" title="4.2. 成员内部类"></a>4.2. 成员内部类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final 修饰的除外）。这是因为成员内部类是非静态的，<strong>类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Out</span></span>&#123;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;   </span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;     </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;       </span><br><span class="line">            System.out.println(a);         </span><br><span class="line">            System.out.println(b);       </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-局部内部类"><a href="#4-3-局部内部类" class="headerlink" title="4.3. 局部内部类"></a>4.3. 局部内部类</h3><p><strong>定义在方法中的类</strong>.</p><p>定义在方法中的类，就是局部类。如果一个类只在某个方法中使用，则可以考虑使用局部类。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;   </span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">int</span> a;   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> c)</span> </span>&#123;     </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> d = <span class="number">1</span>;     </span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Inner</span>  </span>&#123;       </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;               </span><br><span class="line">                System.out.println(c);            </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-匿名内部类"><a href="#4-4-匿名内部类" class="headerlink" title="4.4. 匿名内部类"></a>4.4. 匿名内部类</h3><p><strong>要继承一个父类或者实现一个接口、直接使用 new 来生成一个对象的引用.</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Bird bird)</span></span>&#123;</span><br><span class="line"> System.out.println(bird.getName() + <span class="string">"能够飞 "</span> + bird.fly() + <span class="string">"米"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> Test test = <span class="keyword">new</span> Test();</span><br><span class="line"> test.test(<span class="keyword">new</span> Bird() &#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">10000</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">"大雁"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-JAVA-泛型"><a href="#5-JAVA-泛型" class="headerlink" title="5.JAVA 泛型"></a>5.JAVA 泛型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。 </p><h3 id="5-1-泛型方法-lt-E-gt"><a href="#5-1-泛型方法-lt-E-gt" class="headerlink" title="5.1. 泛型方法&lt; E &gt;"></a>5.1. 泛型方法&lt; E &gt;</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型方法 printArray               </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt; E &gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">( E[] inputArray )</span>     </span>&#123;              </span><br><span class="line">    <span class="keyword">for</span> ( E element : inputArray )&#123;             </span><br><span class="line">        System.out.printf( <span class="string">"%s  "</span>, element );        </span><br><span class="line">    &#125;       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>&lt;? extends T&gt;表示该通配符所代表的类型是 T 类型的子类。</p></li><li><p>&lt;? super T&gt;表示该通配符所代表的类型是 T 类型的父类。 </p></li></ol><h3 id="5-2-泛型类-lt-T-gt"><a href="#5-2-泛型类-lt-T-gt" class="headerlink" title="5.2. 泛型类&lt; T &gt;"></a>5.2. 泛型类&lt; T &gt;</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="keyword">private</span> T t;      </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">this</span>.t = t;      </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="keyword">return</span> t;      </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-类型通配符"><a href="#5-3-类型通配符" class="headerlink" title="5.3. 类型通配符"></a>5.3. 类型通配符</h3><p>类 型 通 配 符 一 般 是 使 用 ? 代 替 具 体 的 类 型 参 数 。 例 如 List&lt;?&gt; 在 逻 辑 上 是</p><p>List&lt; String &gt;,List&lt; Integer &gt; 等所有 List&lt;具体类型实参&gt;的父类。 </p><h3 id="5-4-类型擦除"><a href="#5-4-类型擦除" class="headerlink" title="5.4. 类型擦除"></a>5.4. 类型擦除</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>Java 中的泛型基本上都是在编译器这个层次来实现的。在生成的 Java 字节代码中是不包含泛型中的类型信息的</u>。使用泛型的时候加上的类型参数，会被编译器在编译的时候去掉。这个过程就称为类型擦除。如在代码中定义的 List&lt; Object &gt;和 List&lt; String &gt;等类型，在编译之后都会变成 List。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。 类型擦除的基本过程也比较简单，首先是找到用来替换类型参数的具体类。这个具体类一般是 Object。如果指定了类型参数的上界的话，则使用这个上界。把代码中的类型参数都替换成具体的类。 </p><h2 id="6-JAVA-序列化-创建可复用的-Java-对象"><a href="#6-JAVA-序列化-创建可复用的-Java-对象" class="headerlink" title="6.JAVA 序列化(创建可复用的 Java 对象)"></a>6.JAVA 序列化(创建可复用的 Java 对象)</h2><p><strong>保存(持久化)对象及其状态到内存或者磁盘</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 平台允许我们在内存中创建可复用的 Java 对象，但一般情况下，只有当 JVM 处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比 JVM 的生命周期更长。<u>但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象</u>。 Java 对象序列化就能够帮助我们实现该功能。 </p><p><strong>序列化对象以字节数组保持-静态成员不保存</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;使用 Java 对象序列化，<u>在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象</u>。必须注意地是，<u>对象序列化保存的是对象的”状态”，即它的成员变量</u>。由此可知，对象序列化不会关注类中的静态变量。 </p><p><strong>序列化用户远程对象传输</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;除了在持久化对象时会用到对象序列化之外，当使用 RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用。 </p><p><strong>Serializable实现序列化</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在 Java 中，<strong>只要一个类实现了 java.io.Serializable 接口</strong>，那么它就可以被序列化。</p><p><strong>ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;通过 ObjectOutputStream 和 ObjectInputStream 对对象进行序列化及反序列化。 </p><p><strong>writeObject和 readObject自定义序列化策略</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在类中增加 writeObject 和 readObject 方法可以实现自定义序列化策略。 </p><p><strong>序列化 ID</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID） </p><p><strong>序列化并不保存静态变量</strong> </p><p><strong>序列化子父类说明</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;要想将父类对象也序列化，就需要让父类也实现 Serializable 接口。 </p><p><strong>Transient关键字阻止该变量被序列化到文件中</strong> </p><ol><li><p>在变量声明前加上 <u>Transient 关键字，可以阻止该变量被序列化到文件中</u>，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 </p></li><li><p>服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。</p></li></ol><h2 id="7-JAVA-复制"><a href="#7-JAVA-复制" class="headerlink" title="7.JAVA 复制"></a>7.JAVA 复制</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种概念实际上都是为了拷贝对象。</p><h3 id="7-1-直接赋值复制"><a href="#7-1-直接赋值复制" class="headerlink" title="7.1.  直接赋值复制"></a>7.1.  直接赋值复制</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;直接赋值。在 Java 中，A a1 = a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化。 </p><h3 id="7-2-浅复制（复制引用但不复制引用的对象）"><a href="#7-2-浅复制（复制引用但不复制引用的对象）" class="headerlink" title="7.2.  浅复制（复制引用但不复制引用的对象）"></a>7.2.  浅复制（复制引用但不复制引用的对象）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一个新对象，然后将当前对象的非静态字段复制到该新对象，<strong>如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象</strong>。因此，原始对象及其副本引用同一个对象。     </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resume</span>  <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;        </span><br><span class="line">        <span class="keyword">try</span> &#123;          </span><br><span class="line">            <span class="keyword">return</span> (Resume)<span class="keyword">super</span>.clone();        </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;        </span><br><span class="line">            e.printStackTrace();        </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;        </span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-深复制（复制对象和其应用对象）"><a href="#7-3-深复制（复制对象和其应用对象）" class="headerlink" title="7.3.  深复制（复制对象和其应用对象）"></a>7.3.  深复制（复制对象和其应用对象）</h3><p>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;   </span><br><span class="line">    String name;   </span><br><span class="line">    <span class="keyword">int</span> age;     </span><br><span class="line">    Professor p;       </span><br><span class="line">    Student(String name, <span class="keyword">int</span> age, Professor p) &#123;     </span><br><span class="line">        <span class="keyword">this</span>.name = name;     </span><br><span class="line">        <span class="keyword">this</span>.age = age;     </span><br><span class="line">        <span class="keyword">this</span>.p = p;     </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;     </span><br><span class="line">        Student o = <span class="keyword">null</span>;       </span><br><span class="line">        <span class="keyword">try</span> &#123;         </span><br><span class="line">            o = (Student) <span class="keyword">super</span>.clone();       </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException  e) &#123;         </span><br><span class="line">            System.out.println(e.toString());        </span><br><span class="line">        &#125;        </span><br><span class="line">        o.p = (Professor);  </span><br><span class="line">        p.clone();     </span><br><span class="line">        <span class="keyword">return</span> o;     </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-序列化（深-clone-一中实现）"><a href="#7-4-序列化（深-clone-一中实现）" class="headerlink" title="7.4. 序列化（深 clone 一中实现）"></a>7.4. 序列化（深 clone 一中实现）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在Java 语言里深复制一个对象，常常可以先使对象实现 Serializable 接口，然后把对象（实际上只是对象的一个拷贝）写到一个流里，再从流里读出来，便可以重建对象。</p><h2 id="8-最后"><a href="#8-最后" class="headerlink" title="8.最后"></a>8.最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-JAVA异常分类及处理&quot;&gt;&lt;a href=&quot;#1-JAVA异常分类及处理&quot; class=&quot;headerlink&quot; title=&quot;1.JAVA异常分类及处理&quot;&gt;&lt;/a&gt;1.JAVA异常分类及处理&lt;/h2&gt;&lt;h3 id=&quot;1-1-概念&quot;&gt;&lt;a href=&quot;#1-1-概念&quot; class=&quot;headerlink&quot; title=&quot;1.1.概念&quot;&gt;&lt;/a&gt;1.1.概念&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果某个方法不能按照正常的途径完成任务，就可以通过另一种路径退出方法。在这种情况下会抛出一个封装了错误信息的对象。此时，这个方法会立刻退出同时不返回任何值。另外，调用这个方法的其他代码也无法继续执行，异常处理机制会将代码执行交给异常处理器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(三)之多线程并发</title>
    <link href="https://quietair.gitee.io/Java_heart_thread/"/>
    <id>https://quietair.gitee.io/Java_heart_thread/</id>
    <published>2019-12-15T07:52:18.000Z</published>
    <updated>2020-05-04T07:04:50.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JAVA并发知识库"><a href="#1-JAVA并发知识库" class="headerlink" title="1.JAVA并发知识库"></a>1.JAVA并发知识库</h2><p><img src="/images/Java_heart_thread/clip_image003.gif" alt="img"> </p><a id="more"></a><h2 id="2-JAVA-线程实现-创建方式"><a href="#2-JAVA-线程实现-创建方式" class="headerlink" title="2.JAVA 线程实现/创建方式"></a>2.JAVA 线程实现/创建方式</h2><h3 id="2-1-继承-Thread-类"><a href="#2-1-继承-Thread-类" class="headerlink" title="2.1.继承 Thread 类"></a>2.1.继承 Thread 类</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。<strong>start()方法是一个 native 方法</strong>，它将启动一个新线程，并执行run()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"MyThread.run()"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">MyThread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">myThread1.start();</span><br></pre></td></tr></table></figure><h3 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2.实现Runnable接口"></a>2.2.实现Runnable接口</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;       </span><br><span class="line">        System.out.println(<span class="string">"MyThread.run()"</span>);     </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动 MyThread，需要首先实例化一个 Thread，并传入自己的 MyThread 实例：</span></span><br><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">//事实上，当传入一个 Runnable target 参数给 Thread 后，Thread 的 run()方法就会调用</span></span><br><span class="line">target.run()</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line"> target.run();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-ExecutorService、Callable、Future有返回值线程"><a href="#2-3-ExecutorService、Callable、Future有返回值线程" class="headerlink" title="2.3.ExecutorService、Callable、Future有返回值线程"></a>2.3.ExecutorService、Callable、Future有返回值线程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行 Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个线程池</span></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line"><span class="comment">// 创建多个有返回值的任务</span></span><br><span class="line">List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">" "</span>);</span><br><span class="line"><span class="comment">// 执行任务并获取 Future 对象</span></span><br><span class="line">Future f = pool.submit(c);</span><br><span class="line">list.add(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭线程池</span></span><br><span class="line">pool.shutdown();</span><br><span class="line"><span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line"><span class="keyword">for</span> (Future f : list) &#123;</span><br><span class="line"><span class="comment">// 从 Future 对象上获取任务的返回值，并输出到控制台</span></span><br><span class="line">System.out.println(<span class="string">"res："</span> + f.get().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-基于线程池的方式"><a href="#2-4-基于线程池的方式" class="headerlink" title="2.4. 基于线程池的方式"></a>2.4. 基于线程池的方式</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;线程和数据库连接这些资源都是非常宝贵的资源。那么每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 提交多个线程任务，并执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">" is running .."</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-种线程池"><a href="#3-种线程池" class="headerlink" title="3.种线程池"></a>3.种线程池</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; Java 里面线程池的顶级接口是 <strong>Executor</strong>，但是严格意义上讲 Executor 并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是 <strong>ExecutorService</strong>。 </p><p><img src="/images/Java_heart_thread/clip_image008.gif" alt="img"></p><h3 id="3-1-newCachedThreadPool"><a href="#3-1-newCachedThreadPool" class="headerlink" title="3.1.   newCachedThreadPool"></a>3.1.   newCachedThreadPool</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。<strong>调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程</strong>。因此，长时间保持空闲的线程池不会使用任何资源。 </p><h3 id="3-2-newFixedThreadPool"><a href="#3-2-newFixedThreadPool" class="headerlink" title="3.2.   newFixedThreadPool"></a>3.2.   newFixedThreadPool</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程</strong>。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p><h3 id="3-3-newScheduledThreadPool"><a href="#3-3-newScheduledThreadPool" class="headerlink" title="3.3.   newScheduledThreadPool"></a>3.3.   newScheduledThreadPool</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledThreadPool=Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">scheduledThreadPool.schedule(newRunnable()&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"延迟三秒"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">scheduledThreadPool.scheduleAtFixedRate(newRunnable()&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">"延迟 1 秒后每三秒执行一次"</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;,<span class="number">1</span>,<span class="number">3</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><h3 id="3-4-newSingleThreadExecutor"><a href="#3-4-newSingleThreadExecutor" class="headerlink" title="3.4.   newSingleThreadExecutor"></a>3.4.   newSingleThreadExecutor</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,<strong>这个线程</strong></p><p><strong>池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去</strong>！ </p><h2 id="4-线程生命周期-状态"><a href="#4-线程生命周期-状态" class="headerlink" title="4.线程生命周期(状态)"></a>4.线程生命周期<strong>(</strong>状态<strong>)</strong></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态。在线程的生命周期中，它要经过新建(New)、就绪（Runnable）、运行（Running）、阻塞 (Blocked)和死亡(Dead)5 种状态。尤其是当线程启动以后，它不可能一直”霸占”着 CPU 独自运行，所以 CPU 需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换 </p><h3 id="4-1-新建状态（NEW）"><a href="#4-1-新建状态（NEW）" class="headerlink" title="4.1. 新建状态（NEW）"></a>4.1. 新建状态（<strong>NEW</strong>）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当程序<strong>使用 new 关键字创建了一个线程之后</strong>，该线程就处于新建状态，此时仅由 JVM 为其分配内存，并初始化其成员变量的值 </p><h3 id="4-2-就绪状态（RUNNABLE）"><a href="#4-2-就绪状态（RUNNABLE）" class="headerlink" title="4.2. 就绪状态（RUNNABLE）"></a>4.2. 就绪状态（RUNNABLE）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当线程对象<strong>调用了 start()方法之后</strong>，该线程处于就绪状态。Java 虚拟机会为其创建方法调用栈和程序计数器，等待调度运行。</p><h3 id="4-3-运行状态（RUNNING）"><a href="#4-3-运行状态（RUNNING）" class="headerlink" title="4.3. 运行状态（RUNNING）"></a>4.3. 运行状态（RUNNING）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如果处于<strong>就绪状态的线程获得了 CPU，开始执行 run()方法的线程执行体</strong>，则该线程处于运行状态。</p><h3 id="4-4-阻塞状态（BLOCKED）"><a href="#4-4-阻塞状态（BLOCKED）" class="headerlink" title="4.4. 阻塞状态（BLOCKED）"></a>4.4. 阻塞状态（BLOCKED）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;阻塞状态是指线程因为某种原因放弃了 cpu 使用权，也即让出了 cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得 cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p><ul><li><p><strong>等待阻塞(o.wait-&gt;等待对列)</strong>：运行(running)的线程执行 o.wait()方法，JVM 会把该线程放入等待队列( waitting queue ) 中。 </p></li><li><p><strong>同步阻塞(lock-&gt;锁池)</strong>：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则 JVM 会把该线程放入锁池(lock pool)中。 </p></li><li><p><strong>其他阻塞(sleep/join)</strong>： 运行(running)的线程执行 Thread.sleep(long ms)或 t.join()方法，或者发出了 I/O 请求时， JVM 会把该线程置为阻塞状态。当 sleep()状态超时、join()等待线程终止或者超时、或者 I/O 处理完毕时，线程重新转入可运行(runnable)状态。 </p></li></ul><h3 id="4-5-线程死亡（DEAD）"><a href="#4-5-线程死亡（DEAD）" class="headerlink" title="4.5. 线程死亡（DEAD）"></a>4.5. 线程死亡（DEAD）</h3><p>线程会以下面三种方式结束，结束后就是死亡状态。 </p><p><strong>正常结束</strong> ：</p><ol><li>run()或 call()方法执行完成，线程正常结束。</li></ol><p><strong>异常结束</strong> ：</p><ol start="2"><li>线程抛出一个未捕获的 Exception 或 Error。 </li></ol><p><strong>调用stop</strong>：</p><ol start="3"><li>直接调用该线程的 stop()方法来结束该线程—<strong>该方法通常容易导致死锁，不推荐使用</strong>。</li></ol><p><img src="/images/Java_heart_thread/clip_image002.gif" alt="img"> </p><h2 id="5-终止线程-4-种方式"><a href="#5-终止线程-4-种方式" class="headerlink" title="5.终止线程 4 种方式"></a>5.终止线程 4 种方式</h2><h3 id="5-1-正常运行结束"><a href="#5-1-正常运行结束" class="headerlink" title="5.1. 正常运行结束"></a>5.1. 正常运行结束</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;程序运行结束，线程自动结束。 </p><h3 id="5-2-使用退出标志退出线程"><a href="#5-2-使用退出标志退出线程" class="headerlink" title="5.2. 使用退出标志退出线程"></a>5.2. 使用退出标志退出线程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;一般 run()方法执行完，线程就会正常结束，然而，常常有些线程是伺服线程。它们需<strong>要长时间的运行，只有在外部某些条件满足的情况下，才能关闭这些线程</strong>。使用一个变量来控制循环，例如：最直接的方法就是设一个boolean类型的标志，并通过设置这个标志为true或false 来控制while 循环是否退出，代码示例：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> exit = <span class="keyword">false</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (!exit)&#123;</span><br><span class="line"> <span class="comment">//do something</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;定义了一个退出标志 exit，当 exit 为 true 时，while 循环退出，exit 的默认值为 false.在定义 exit 时，<strong>使用了一个 Java 关键字 volatile，这个关键字的目的是使 exit 同步</strong>，也就是说在同一时刻只能由一个线程来修改 exit 的值。  </p><h3 id="5-3-Interrupt-方法结束线程"><a href="#5-3-Interrupt-方法结束线程" class="headerlink" title="5.3.   Interrupt 方法结束线程"></a>5.3.   Interrupt 方法结束线程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;使用 interrupt()方法来中断线程有两种情况： </p><ol><li><p>线程处于阻塞状态：如使用了 sleep,同步锁的 wait,socket 中的 receiver,accept 等方法时，会使线程处于阻塞状态。当调用线程的 interrupt()方法时，会抛出 InterruptException 异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后 break 跳出循环状态，从而让我们有机会结束这个线程的执行。<strong>通常很多人认为只要调用 interrupt 方法线程就会结束，实际上是错的， 一定要先捕获 InterruptedException 异常之后通过 break 来跳出循环，才能正常结束 run 方法</strong>。 </p></li><li><p>线程未处于阻塞状态：使用 isInterrupted()判断线程的中断标志来退出循环。当使用 interrupt()方法时，中断标志就会置 true，和使用自定义的标志来控制循环是一样的道理。 </p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafe</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">while</span> (!isInterrupted())&#123; <span class="comment">//非阻塞过程中通过判断中断标志来退出</span></span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> Thread.sleep(<span class="number">5</span>*<span class="number">1000</span>);<span class="comment">//阻塞过程捕获中断异常来退出</span></span><br><span class="line"> &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> <span class="keyword">break</span>;<span class="comment">//捕获到异常之后，执行 break 跳出循环</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-stop-方法终止线程（线程不安全）"><a href="#5-4-stop-方法终止线程（线程不安全）" class="headerlink" title="5.4.   stop 方法终止线程（线程不安全）"></a>5.4.   stop 方法终止线程（线程不安全）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;程序中可以直接使用 thread.stop()来强行终止线程，但是 stop 方法是很危险的，就象突然关闭计算机电源，而不是按正常程序关机一样，可能会产生不可预料的结果，不安全主要是： thread.stop()调用之后，创建子线程的线程就会抛出 ThreadDeatherror 的错误，并且会释放子线程所持有的所有锁。一般任何进行加锁的代码块，都是为了保护数据的一致性，如果在<strong>调用 thread.stop()后导致了该线程所持有的所有锁的突然释放(不可控制)</strong>，那么被保护数据就有可能呈现不一致性，其他线程在使用这些被破坏的数据时，有可能导致一些很奇怪的应用程序错误。因此，并不推荐使用 stop 方法来终止线程。 </p><h2 id="6-sleep-与-wait-区别"><a href="#6-sleep-与-wait-区别" class="headerlink" title="6. sleep 与 wait 区别"></a>6. sleep 与 wait 区别</h2><ol><li>对于 sleep()方法，我们首先要知道该方法是属于 Thread 类中的。而 wait()方法，则是属于</li></ol><p>Object 类中的。 </p><ol start="2"><li><p>sleep()方法导致了程序暂停执行指定的时间，让出 cpu 该其他线程，<strong>但是他的监控状态依然保持着</strong>，当指定的时间到了又会自动恢复运行状态。</p></li><li><p>在调用 sleep()方法的过程中，<strong>线程不会释放对象锁</strong>。 </p></li><li><p>而当<strong>调用 wait()方法的时候，线程会放弃对象锁</strong>，进入等待此对象的等待锁定池，只有针对此对象调用 notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</p></li></ol><h2 id="7-start-与-run-区别"><a href="#7-start-与-run-区别" class="headerlink" title="7.start 与 run 区别"></a>7.start 与 run 区别</h2><ol><li><p>start（）方法来启动线程，真正实现了多线程运行。这时无需等待 run 方法体代码执行完毕，可以直接继续执行下面的代码。 </p></li><li><p>通过调用 Thread 类的 start()方法来启动一个线程， 这时此线程是处于<strong>就绪状态</strong>， 并没有运行。</p></li><li><p>方法 run()称为线程体，它包含了要执行的这个线程的内容，线程就进入了运行状态，<strong>开始运行 run 函数当中的代码</strong>。 Run 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。 </p></li></ol><h2 id="8-JAVA-后台线程"><a href="#8-JAVA-后台线程" class="headerlink" title="8.JAVA 后台线程"></a>8.JAVA 后台线程</h2><ol><li><p>定义：守护线程–也称“服务线程”，他是后台线程，它有一个特性，即<strong>为用户线程 提供公共服务</strong>，在没有用户线程可服务时会自动离开。 </p></li><li><p>优先级：守护线程的<strong>优先级比较低</strong>，用于为系统中的其它对象和线程提供服务。 </p></li><li><p>设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。 </p></li><li><p>在 Daemon 线程中产生的新线程也是 Daemon 的。 </p></li><li><p><strong>线程则是 JVM 级别的</strong>，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程依旧是活跃的。 </p></li><li><p>example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread, 程序就不会再产生垃圾，垃圾回收器也就无事可做，<strong>所以当垃圾回收线程是 JVM 上仅剩的线程时，垃圾回收线程会自动离开</strong>。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。 </p></li><li><p>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退出了；如果还有一个或以上的非守护线程则 JVM 不会退出。</p></li></ol><h2 id="9-JAVA-锁"><a href="#9-JAVA-锁" class="headerlink" title="9.JAVA 锁"></a>9.JAVA 锁</h2><h3 id="9-1-乐观锁"><a href="#9-1-乐观锁" class="headerlink" title="9.1. 乐观锁"></a>9.1. 乐观锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是<strong>在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作</strong>（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读-比较-写的操作。 java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。 </p><h3 id="9-2-悲观锁"><a href="#9-2-悲观锁" class="headerlink" title="9.2. 悲观锁"></a>9.2. 悲观锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会block直到拿到锁。 java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，才会转换为悲观锁，如 RetreenLock。 </p><h3 id="9-3-自旋锁"><a href="#9-3-自旋锁" class="headerlink" title="9.3. 自旋锁"></a>9.3. 自旋锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。 线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。 </p><p><strong>自旋锁的优缺点</strong> ：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！ </p><p>&nbsp;&nbsp;&nbsp;&nbsp;但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cup 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁； </p><p><strong>自旋锁时间阈值（1.6引入了适应性自旋锁）</strong> ：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;自旋锁的目的是为了占着 CPU 的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用 CPU 资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！ </p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM 对于自旋周期的选择，jdk1.5 这个限度是一定的写死的，在 1.6 引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时 JVM 还针对当前 CPU 的负荷情况做了较多的优化，如果平均负载小于 CPUs 则一直自旋，如果有超过( CPUs/ 2) 个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现 Owner 发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果 CPU 处于节电模式则停止自旋，自旋时间的最坏情况是 CPU 的存储延迟（CPU A 存储了一个数据，到 CPU B 得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。 </p><p><strong>自旋锁的开启</strong> ：</p><p>JDK1.6 中-XX:+UseSpinning 开启； </p><p>-XX:PreBlockSpin=10 为自旋次数； </p><p>JDK1.7 后，去掉此参数，由 jvm 控制； </p><h3 id="9-4-Synchronized-同步锁"><a href="#9-4-Synchronized-同步锁" class="headerlink" title="9.4.   Synchronized 同步锁"></a>9.4.   Synchronized 同步锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;synchronized 它可以把任意一个非 NULL 的对象当作锁。<strong>他属于独占式的悲观锁，同时属于可重入锁</strong>。 </p><p><strong>Synchronized作用范围</strong> ：</p><ol><li><p>作用于方法时，锁住的是对象的实例(this)；</p></li><li><p>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen （jdk1.8 则是 metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</p></li><li><p>synchronized 作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。</p></li></ol><p><strong>Synchronized核心组件</strong> ：</p><p>1) 、 Wait Set：哪些调用 wait 方法被阻塞的线程被放置在这里；</p><p>2) 、 Contention List：<strong>竞争队列</strong>，所有请求锁的线程首先被放在这个竞争队列中； </p><p>3)  、Entry List：Contention List 中那些<strong>有资格成为候选资源的线程被移动到 Entry List 中</strong>；</p><p>4)  、OnDeck：任意时刻，<strong>最多只有一个线程正在竞争锁资源，该线程被成为 OnDeck</strong>；</p><p>5)  、Owner：当前已经获取到所资源的线程被称为 Owner； </p><p>6)  、!Owner：当前释放锁的线程。 </p><p><strong>Synchronized实现</strong> ：</p><p><img src="/images/Java_heart_thread/clip_image004.gif" alt="img"> </p><ol><li><p>JVM 每次从队列的尾部取出一个数据用于锁竞争候选者（OnDeck），但是并发情况下， ContentionList 会被大量的并发线程进行 CAS 访问，为了降低对尾部元素的竞争，JVM 会将一部分线程移动到 EntryList 中作为候选竞争线程。 </p></li><li><p>Owner 线程会在 unlock 时，将 ContentionList 中的部分线程迁移到 EntryList 中，并指定 EntryList 中的某个线程为 OnDeck 线程（一般是最先进去的那个线程）。</p></li><li><p>Owner 线程并不直接把锁传递给 OnDeck 线程，而是把锁竞争的权利交给 OnDeck， OnDeck需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在 JVM 中，也把这种选择行为称之为“竞争切换”。 </p></li><li><p>OnDeck 线程获取到锁资源后会变为 Owner 线程，而没有得到锁资源的仍然停留在 EntryList 中。如果Owner线程被wait方法阻塞，则转移到WaitSet队列中，直到某个时刻通过notify 或者 notifyAll 唤醒，会重新进去 EntryList 中。 </p></li><li><p>处于 ContentionList、EntryList、WaitSet 中的线程都处于阻塞状态，该阻塞是由操作系统来完成的（Linux 内核下采用 pthread_mutex_lock 内核函数实现的）。</p></li><li><p><strong>Synchronized 是非公平锁</strong>。 Synchronized 在线程进入 ContentionList 时，<u>等待的线程会先尝试自旋获取锁，如果获取不到就进入 ContentionList，这明显对于已经进入队列的线程是不公平的</u>，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占 OnDeck 线程的锁资源。 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;参考：<a href="https://blog.csdn.net/zqz_zqz/article/details/70233767" target="_blank" rel="noopener">https://blog.csdn.net/zqz_zqz/article/details/70233767</a></p><ol start="7"><li><p>每个对象都有个 monitor 对象，<strong>加锁就是在竞争 monitor 对象</strong>，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的</p></li><li><p>synchronized <strong>是一个重量级操作，需要调用操作系统相关接口</strong>，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。 </p></li><li><p>Java1.6，synchronized进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的 Java1.7 与 1.8 中，均对该关键字的实现机理做了优化。引入了<strong>偏向锁和轻量级锁</strong>。都是在对象头中有标记位，不需要经过操作系统加锁。 </p></li><li><p><u>锁可以从偏向锁升级到轻量级锁，再升级到重量级锁</u>。这种升级过程叫做锁膨胀； </p></li><li><p>JDK 1.6 中默认是开启偏向锁和轻量级锁，可以通过-XX:-UseBiasedLocking 来禁用偏向锁。 </p></li></ol><h3 id="9-5-ReentrantLock"><a href="#9-5-ReentrantLock" class="headerlink" title="9.5.   ReentrantLock"></a>9.5.   ReentrantLock</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;ReentantLock 继承接口 Lock 并实现了接口中定义的方法，他是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，<strong>还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法</strong>。 </p><p><strong>Lock接口的主要方法</strong> ：</p><ol><li><p>void lock(): 执行此方法时, <strong>如果锁处于空闲状态, 当前线程将获取到锁</strong>. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁. </p></li><li><p>boolean tryLock()：<strong>如果锁可用, 则获取锁, 并立即返回 true, 否则返回 false</strong>. 该方法和 lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而 lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. </p></li><li><p>void unlock()：执行此方法时, <strong>当前线程将释放持有的锁</strong>. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生. </p></li><li><p>Condition newCondition()：<strong>条件对象，获取等待通知组件</strong>。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的 await()方法，而调用后，当前线程将缩放锁。 </p></li><li><p>getHoldCount() ：查询当前线程保持此锁的次数，也就是执行此线程执行lock方法的次数。 </p></li><li><p>getQueueLength（）：返回正等待获取此锁的线程估计数，比如启动 10 个线程，1 个线程获得锁，此时返回的是 9 </p></li><li><p>getWaitQueueLength：（Condition condition）返回等待与此锁相关的给定条件的线程估计数。比如 10 个线程，用同一个 condition 对象，并且此时这 10 个线程都执行了 condition 对象的 await 方法，那么此时执行此方法返回 10 </p></li><li><p>hasWaiters(Condition condition)：查询是否有线程等待与此锁有关的给定条件(condition)，对于指定 contidion 对象，有多少线程执行了 condition.await 方法</p></li><li><p>hasQueuedThread(Thread thread)：查询给定线程是否等待获取此锁 </p></li><li><p>hasQueuedThreads()：是否有线程等待此锁 </p></li><li><p>isFair()：该锁是否公平锁 </p></li><li><p>isHeldByCurrentThread()： 当前线程是否保持锁锁定，线程的执行 lock 方法的前后分别是 false 和 true </p></li><li><p>isLock()：此锁是否有任意线程占用 </p></li><li><p>lockInterruptibly（）：如果当前线程未被中断，获取锁 </p></li><li><p>tryLock（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁 </p></li><li><p>tryLock(long timeout TimeUnit unit)：如果锁在给定等待时间内没有被另一个线程保持，则获取该锁。 </p></li></ol><p><strong>非公平锁</strong> ：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;JVM 按随机、就近原则分配锁的机制则称为不公平锁，ReentrantLock 在构造函数中提供了是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。</p><p><strong>公平锁</strong>： </p><p>&nbsp;&nbsp;&nbsp;&nbsp;公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁， ReentrantLock 在构造函数中提供了是否公平锁的初始化方式来定义公平锁。 </p><p><strong>ReentrantLock与synchronized</strong>：</p><ol><li><p>ReentrantLock 通过方法 lock()与 unlock()来进行加锁与解锁操作，<strong>与 synchronized 会被 JVM 自动解锁机制不同，ReentrantLock 加锁后需要手动进行解锁</strong>。为了避免程序出现异常而无法正常解锁的情况，使用 ReentrantLock 必须在 finally 控制块中进行解锁操作。</p></li><li><p>ReentrantLock 相比 synchronized 的优势是可中断、公平锁、多个锁。这种情况下需要使用 ReentrantLock。 </p></li></ol><p><strong>ReentrantLock实现</strong> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//Lock lock=new ReentrantLock(true);//公平锁</span></span><br><span class="line"> <span class="comment">//Lock lock=new ReentrantLock(false);//非公平锁</span></span><br><span class="line"> <span class="keyword">private</span> Condition condition=lock.newCondition();<span class="comment">//创建 Condition</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> lock.lock();<span class="comment">//lock 加锁</span></span><br><span class="line"><span class="comment">//1：wait 方法等待：</span></span><br><span class="line"> <span class="comment">//System.out.println("开始 wait");</span></span><br><span class="line"> condition.await();</span><br><span class="line"><span class="comment">//通过创建 Condition 对象来使线程 wait，必须先执行 lock.lock 方法获得锁</span></span><br><span class="line"><span class="comment">//:2：signal 方法唤醒</span></span><br><span class="line">condition.signal();<span class="comment">//condition 对象的 signal 方法可以唤醒 wait 线程</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">System.out.println(<span class="string">"ThreadName="</span> + Thread.currentThread().getName()+ (<span class="string">" "</span> + (i + <span class="number">1</span>)));</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">finally</span>&#123;</span><br><span class="line"> lock.unlock();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Condition类和Object类锁方法区别区别</strong> :</p><ol><li><p>Condition 类的 awiat 方法和 Object 类的 wait 方法等效 </p></li><li><p>Condition 类的 signal 方法和 Object 类的 notify 方法等效 </p></li><li><p>Condition 类的 signalAll 方法和 Object 类的 notifyAll 方法等效 </p></li><li><p>ReentrantLock 类可以唤醒指定条件的线程，而 object 的唤醒是随机的 </p></li></ol><p><strong>tryLock和lock和lockInterruptibly 的区别</strong> :</p><ol><li><p>tryLock 能获得锁就返回 true，不能就立即返回 false，tryLock(long timeout,TimeUnit unit)，可以增加时间限制，如果超过该时间段还没获得锁，返回 false </p></li><li><p>lock 能获得锁就返回 true，不能的话一直等待获得锁</p></li><li><p>lock 和 lockInterruptibly，如果两个线程分别执行这两个方法，但此时<strong>中断这两个线程， lock 不会抛出异常，而 lockInterruptibly 会抛出异常</strong>。 </p></li></ol><h3 id="9-6-Semaphore-信号量"><a href="#9-6-Semaphore-信号量" class="headerlink" title="9.6.   Semaphore 信号量"></a>9.6.   Semaphore 信号量</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Semaphore 是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore 可以用来构建一些对象池，资源池之类的，比如数据库连接池 </p><p><strong>实现互斥锁（计数器为1）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们也可以创建计数为 1 的 Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。 </p><p>代码实现，它的用法如下： </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个计数阈值为 5 的信号量对象</span></span><br><span class="line"><span class="comment">// 只能 5 个线程同时访问</span></span><br><span class="line">Semaphore semp = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 申请许可</span></span><br><span class="line">semp.acquire();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="number">13</span>/<span class="number">04</span>/<span class="number">2018</span> Page <span class="number">69</span> of <span class="number">283</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 释放许可</span></span><br><span class="line">semp.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Semaphore与ReentrantLock</strong>：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Semaphore 基本能完成 ReentrantLock 的所有工作，使用方法也与之类似，通过 acquire()与 release()方法来获得和释放临界资源。经实测，Semaphone.acquire()方法默认为可响应中断锁，与 ReentrantLock.lockInterruptibly()作用效果一致，也就是说在等待临界资源的过程中可以被Thread.interrupt()方法中断。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;此外，Semaphore 也实现了<strong>可轮询的锁请求与定时锁的功能</strong>，除了方法名 tryAcquire 与 tryLock 不同，其使用方法与ReentrantLock几乎一致。Semaphore也提供了公平与非公平锁的机制，也可在构造函数中进行设定。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Semaphore的锁释放操作也由手动进行，因此与ReentrantLock 一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在 finally 代码块中完成。 </p><h3 id="9-7-AtomicInteger"><a href="#9-7-AtomicInteger" class="headerlink" title="9.7.   AtomicInteger"></a>9.7.   AtomicInteger</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;首先说明，此处 AtomicInteger，一个提供原子操作的 Integer 的类，常见的还有AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference 等，他们的实现原理相同，区别在与运算对象类型的不同。令人兴奋地，还可以通过 AtomicReference<v>将一个对象的所有操作转化成原子操作。 </v></p><p>&nbsp;&nbsp;&nbsp;&nbsp;我们知道，<strong>在多线程程序中，诸如++i 或 i++等运算不具有原子性，是不安全的线程操作之一</strong>。通常我们会使用 synchronized 将该操作变成一个原子操作，但 JVM 为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常AtomicInteger 的性能是 ReentantLock 的好几倍。 </p><h3 id="9-8-可重入锁（递归锁）"><a href="#9-8-可重入锁（递归锁）" class="headerlink" title="9.8. 可重入锁（递归锁）"></a>9.8. 可重入锁（递归锁）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;本文里面讲的是广义上的可重入锁，而不是单指JAVA 下的ReentrantLock。<strong>可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响</strong>。在 JAVA 环境下 ReentrantLock 和 synchronized 都是 可重入锁。 </p><h3 id="9-9-公平锁与非公平锁"><a href="#9-9-公平锁与非公平锁" class="headerlink" title="9.9. 公平锁与非公平锁"></a><strong>9.9. 公平锁与非公平锁</strong></h3><p><strong>公平锁（Fair）</strong> ：</p><p>&nbsp;&nbsp;&nbsp;&nbsp;加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得 </p><p><strong>非公平锁（Nonfair）</strong> ：</p><p>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待 </p><ol><li><p>非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列</p></li><li><p>Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。 </p></li></ol><h3 id="9-10-ReadWriteLock-读写锁"><a href="#9-10-ReadWriteLock-读写锁" class="headerlink" title="9.10. ReadWriteLock 读写锁"></a>9.10. ReadWriteLock 读写锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>为了提高性能，Java 提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制</strong>，如果没有写锁的情况下，读是无阻塞的,在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由 jvm 自己控制的，你只要上好相应的锁即可。 </p><p><strong>读锁</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁 </p><p><strong>写锁</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！ </p><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 中 读 写 锁 有 个 接 口 java.util.concurrent.locks.ReadWriteLock ， 也 有 具 体 的 实 现ReentrantReadWriteLock。 </p><h3 id="9-11-共享锁和独占锁"><a href="#9-11-共享锁和独占锁" class="headerlink" title="9.11. 共享锁和独占锁"></a>9.11. 共享锁和独占锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;java 并发包提供的加锁模式分为独占锁和共享锁。 </p><p><strong>独占锁</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。</p><p><strong>共享锁</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。</p><ol><li><p>AQS 的内部类 Node 定义了两个常量 SHARED 和 EXCLUSIVE，他们分别标识 AQS 队列中等待线程的锁获取模式。 </p></li><li><p>java 的并发包中提供了 ReadWriteLock，读-写锁。它允许一个资源可以被多个读操作访问，或者被一个 写操作访问，但两者不能同时进行。</p></li></ol><h3 id="9-12-重量级锁（Mutex-Lock）"><a href="#9-12-重量级锁（Mutex-Lock）" class="headerlink" title="9.12. 重量级锁（Mutex Lock）"></a>9.12. 重量级锁（Mutex Lock）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么 Synchronized 效率低的原因。因此，<strong>这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”</strong>。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和“偏向锁”。 </p><h3 id="9-13-轻量级锁"><a href="#9-13-轻量级锁" class="headerlink" title="9.13. 轻量级锁"></a>9.13. 轻量级锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。 </p><p><strong>锁升级</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，<u>轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁</u>。 </p><h3 id="9-14-偏向锁"><a href="#9-14-偏向锁" class="headerlink" title="9.14. 偏向锁"></a>9.14. 偏向锁</h3><p> &nbsp;&nbsp;&nbsp;&nbsp;Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。<u>偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起来让这个线程得到了偏护</u>。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换 ThreadID的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，<u>轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能</u>。 </p><h3 id="9-15-分段锁"><a href="#9-15-分段锁" class="headerlink" title="9.15. 分段锁"></a>9.15. 分段锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</p><h3 id="9-16-锁优化"><a href="#9-16-锁优化" class="headerlink" title="9.16. 锁优化"></a>9.16. 锁优化</h3><p><strong>减少锁持有时间</strong> </p><ul><li>只用在有线程安全要求的程序上加锁 </li></ul><p><strong>减小锁粒度</strong> </p><ul><li>将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是</li></ul><p>ConcurrentHashMap。 </p><p><strong>锁分离</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>最常见的锁分离就是读写锁 ReadWriteLock</strong>，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能，具体也请查看[高并发 Java 五]  JDK 并发包 1。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如LinkedBlockingQueue 从头部取出，从尾部放数据 </p><p><strong>锁粗化</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，<u>如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化</u> 。 </p><p><strong>锁消除</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。</p><p>参考：<a href="https://www.jianshu.com/p/39628e1180a9" target="_blank" rel="noopener">https://www.jianshu.com/p/39628e1180a9</a></p><h2 id="10-线程基本方法"><a href="#10-线程基本方法" class="headerlink" title="10.线程基本方法"></a>10.线程基本方法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;线程相关的基本方法有 wait，notify，notifyAll，sleep，join，yield 等。</p><p><img src="/images/Java_heart_thread/clip_image005.gif" alt="img"> </p><h3 id="10-1-线程等待（wait）"><a href="#10-1-线程等待（wait）" class="headerlink" title="10.1. 线程等待（wait）"></a>10.1. 线程等待（wait）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;调用该方法的线程进入 WAITING 状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用 wait()方法后，<strong>会释放对象的锁</strong>。因此，wait 方法一般用在同步方法或同步代码块中。 </p><h3 id="10-2-线程睡眠（sleep）"><a href="#10-2-线程睡眠（sleep）" class="headerlink" title="10.2. 线程睡眠（sleep）"></a>10.2. 线程睡眠（sleep）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;sleep 导致当前线程休眠，与 wait 方法不同的是 <strong>sleep 不会释放当前占有的锁</strong>,sleep(long)会导致线程进入 TIMED-WATING 状态，而 wait()方法会导致当前线程进入 WATING 状态 </p><h3 id="10-3-线程让步（yield）"><a href="#10-3-线程让步（yield）" class="headerlink" title="10.3. 线程让步（yield）"></a>10.3. 线程让步（yield）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;yield 会使当前线程<strong>让出 CPU 执行时间片</strong>，与其他线程一起重新竞争 CPU 时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到 CPU 时间片，但这又不是 绝对的，有的操作系统对线程优先级并不敏感。 </p><h3 id="10-4-线程中断（interrupt）"><a href="#10-4-线程中断（interrupt）" class="headerlink" title="10.4. 线程中断（interrupt）"></a>10.4. 线程中断（interrupt）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;中断一个线程，其本意是给<strong>这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态(如阻塞，终止等)</strong>。 </p><ol><li><p>调用 interrupt()方法并不会中断一个正在运行的线程。也就是说处于 Running 状态的线程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。</p></li><li><p>若调用 sleep()而使线程处于 TIMED-WATING 状态，这时调用 interrupt()方法，会抛出InterruptedException,从而使线程提前结束 TIMED-WATING 状态。 </p></li><li><p>许多声明抛出InterruptedException 的方法(如 Thread.sleep(long mills 方法))，抛出异常前，都会清除中断标识位，所以抛出异常后，调用 isInterrupted()方法将会返回 false。 </p></li><li><p>中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如,你想终止一个线程thread的时候，可以调用thread.interrupt()方法，在线程的run方法内部可以根据 thread.isInterrupted()的值来优雅的终止线程。 </p></li></ol><h3 id="10-5-Join-等待其他线程终止"><a href="#10-5-Join-等待其他线程终止" class="headerlink" title="10.5. Join 等待其他线程终止"></a>10.5. Join 等待其他线程终止</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;join() 方法，等待其他线程终止，在当前线程中调用一个线程的 join() 方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待 cpu 的宠幸。 </p><h3 id="10-6-为什么要用-join-方法"><a href="#10-6-为什么要用-join-方法" class="headerlink" title="10.6. 为什么要用 join()方法"></a>10.6. 为什么要用 join()方法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到 join() 方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">"线程运行开始!"</span>);</span><br><span class="line">Thread6 thread1 = <span class="keyword">new</span> Thread6();</span><br><span class="line">thread1.setName(<span class="string">"线程 B"</span>);</span><br><span class="line">thread1.join();</span><br><span class="line">System.out.println(<span class="string">"这时 thread1 执行完毕之后才能执行主线程"</span>);</span><br></pre></td></tr></table></figure><h3 id="10-7-线程唤醒（notify）"><a href="#10-7-线程唤醒（notify）" class="headerlink" title="10.7. 线程唤醒（notify）"></a>10.7. 线程唤醒（notify）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Object 类中的 notify() 方法，<strong>唤醒在此对象监视器上等待的单个线程</strong>，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，在对象的监视器上等待，<u>直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程</u>，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程。 </p><h3 id="10-8-其他方法："><a href="#10-8-其他方法：" class="headerlink" title="10.8. 其他方法："></a>10.8. 其他方法：</h3><ol><li><p>sleep()：强迫一个线程睡眠Ｎ毫秒。 </p></li><li><p>isAlive()： 判断一个线程是否存活。 </p></li><li><p>join()： 等待线程终止。 </p></li><li><p>activeCount()： 程序中活跃的线程数。 </p></li><li><p>enumerate()： 枚举程序中的线程。 </p></li><li><p>currentThread()： 得到当前线程。 </p></li><li><p>isDaemon()： 一个线程是否为守护线程。 </p></li><li><p>setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) </p></li><li><p>setName()： 为线程设置一个名称。 </p></li><li><p>wait()： 强迫一个线程等待。 </p></li><li><p>notify()： 通知一个线程继续运行。 </p></li><li><p>setPriority()： 设置一个线程的优先级。 </p></li><li><p>getPriority():：获得一个线程的优先级。</p></li></ol><h2 id="11-线程上下文切换"><a href="#11-线程上下文切换" class="headerlink" title="11.线程上下文切换"></a>11.线程上下文切换</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;巧妙地利用了时间片轮转的方式, CPU 给每个任务都服务一定的  时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，<strong>任务的状态保存及再加载, 这段过程就叫做上下文切换</strong>。时间片轮转的方式使多个任务在同一颗 CPU 上执行变成了可能。 </p><p><img src="/images/Java_heart_thread/clip_image009.gif" alt="img"> </p><h3 id="11-1-进程"><a href="#11-1-进程" class="headerlink" title="11.1. 进程"></a>11.1. 进程</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;（有时候也称做任务）是指一个程序运行的实例。在 Linux 系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。</p><h3 id="11-2-上下文"><a href="#11-2-上下文" class="headerlink" title="11.2. 上下文"></a>11.2. 上下文</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是指某一时间点 CPU 寄存器和程序计数器的内容。 </p><h3 id="11-3-寄存器"><a href="#11-3-寄存器" class="headerlink" title="11.3. 寄存器"></a>11.3. 寄存器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速</p><p>度。 </p><h3 id="11-4-程序计数器"><a href="#11-4-程序计数器" class="headerlink" title="11.4. 程序计数器"></a>11.4. 程序计数器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。</p><h3 id="11-5-PCB-“切换桢”"><a href="#11-5-PCB-“切换桢”" class="headerlink" title="11.5. PCB-“切换桢”"></a>11.5. PCB-“切换桢”</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB 还经常被称作“切换桢”（switchframe）。信息会一直保存到 CPU 的内存中，直到他们被再次使用。 </p><h3 id="11-6-上下文切换的活动"><a href="#11-6-上下文切换的活动" class="headerlink" title="11.6. 上下文切换的活动"></a>11.6. 上下文切换的活动</h3><ol><li><p>挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。</p></li><li><p>在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。 </p></li><li><p>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。</p></li></ol><h3 id="11-7-引起线程上下文切换的原因"><a href="#11-7-引起线程上下文切换的原因" class="headerlink" title="11.7. 引起线程上下文切换的原因"></a>11.7. 引起线程上下文切换的原因</h3><ol><li><p>当前执行任务的时间片用完之后，系统 CPU 正常调度下一个任务； </p></li><li><p>当前执行任务碰到 IO 阻塞，调度器将此任务挂起，继续下一任务；</p></li><li><p>多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；</p></li><li><p>用户代码挂起当前任务，让出 CPU 时间；</p></li><li><p>硬件中断； </p></li></ol><h2 id="12-同步锁与死锁"><a href="#12-同步锁与死锁" class="headerlink" title="12.同步锁与死锁"></a>12.同步锁与死锁</h2><h3 id="12-1-同步锁"><a href="#12-1-同步锁" class="headerlink" title="12.1. 同步锁"></a>12.1. 同步锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要<strong>保证线程同步互斥，就是指并发执行的多个线程</strong>，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。</p><h3 id="12-2-死锁"><a href="#12-2-死锁" class="headerlink" title="12.2. 死锁"></a>12.2. 死锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。 </p><h2 id="13-线程池原理"><a href="#13-线程池原理" class="headerlink" title="13.线程池原理"></a>13.线程池原理</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量<strong>超过了最大数量超出数量的线程排队等候</strong>，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：<strong>线程复用；控制最大并发数；管理线程</strong>。 </p><h3 id="13-1-线程复用"><a href="#13-1-线程复用" class="headerlink" title="13.1.线程复用"></a>13.1.线程复用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 <strong>我们可以继承重写 Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象</strong>。 这就是线程池的实现原理。<u>循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的</u>。 </p><h3 id="13-2-线程池的组成"><a href="#13-2-线程池的组成" class="headerlink" title="13.2.线程池的组成"></a>13.2.线程池的组成</h3><p>一般的线程池主要分为以下 4 个组成部分： </p><ol><li><p>线程池管理器：用于创建并管理线程池 </p></li><li><p>工作线程：线程池中的线程 </p></li><li><p>任务接口：每个任务必须实现的接口，用于工作线程调度其运行 </p></li><li><p>任务队列：用于存放待处理的任务，提供一种缓冲机制 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和 Future、FutureTask 这几个类。 </p><p><img src="/images/Java_heart_thread/clip_image006.gif" alt="img"></p><p>ThreadPoolExecutor 的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>corePoolSize：指定了线程池中的线程数量。 </p></li><li><p>maximumPoolSize：指定了线程池中的最大线程数量。 </p></li><li><p>keepAliveTime：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。 </p></li><li><p>unit：keepAliveTime 的单位。</p></li><li><p>workQueue：任务队列，被提交但尚未被执行的任务。 </p></li><li><p>threadFactory：线程工厂，用于创建线程，一般用默认的即可。 </p></li><li><p>handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。 </p></li></ol><h3 id="13-3-拒绝策略"><a href="#13-3-拒绝策略" class="headerlink" title="13.3. 拒绝策略"></a>13.3. 拒绝策略</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。 </p><p>JDK 内置的拒绝策略如下： </p><ol><li><p>AbortPolicy ： 直接抛出异常，阻止系统正常运行。 </p></li><li><p>CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。 </p></li><li><p>DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 </p></li><li><p>DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。 </p><h3 id="13-4-Java-线程池工作过程"><a href="#13-4-Java-线程池工作过程" class="headerlink" title="13.4. Java 线程池工作过程"></a>13.4. Java 线程池工作过程</h3><ol><li><p>线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p></li><li><p>当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><p>a)   如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务； </p><p>b)   如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； </p><p>c)   如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； </p><p>d)   如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。 </p></li><li><p>当一个线程完成任务时，它会从队列中取下一个任务来执行。 </p></li><li><p>当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。 </p></li></ol><p><img src="/images/Java_heart_thread/clip_image008.jpg" alt="img"> </p><h2 id="14-JAVA-阻塞队列原理"><a href="#14-JAVA-阻塞队列原理" class="headerlink" title="14.JAVA 阻塞队列原理"></a>14.JAVA 阻塞队列原理</h2><p>阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：</p><ol><li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。</li></ol><p><img src="/images/Java_heart_thread/clip_image010.gif" alt="img"> </p><ol start="2"><li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。</li></ol><p><img src="/images/Java_heart_thread/clip_image012.gif" alt="img"> </p><h3 id="14-1-阻塞队列的主要方法"><a href="#14-1-阻塞队列的主要方法" class="headerlink" title="14.1. 阻塞队列的主要方法"></a>14.1. 阻塞队列的主要方法</h3><p><img src="/images/Java_heart_thread/clip_image014.gif" alt="img"> </p><ul><li>抛出异常：抛出一个异常； </li><li>特殊值：返回一个特殊值（null 或 false,视情况而定） </li><li>则塞：在成功操作之前，一直阻塞线程 </li><li>超时：放弃前只在最大的时间内阻塞 </li></ul><p><strong>插入操作：</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;1：public abstract boolean add(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。如果该元素是 NULL，则会抛出 NullPointerException 异常。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;2：public abstract boolean offer(E paramE)：将指定元素插入此队列中（如果立即可行且不会违反容量限制），成功时返回 true，如果当前没有可用的空间，则返回 false。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;3：public abstract void put(E paramE) throws InterruptedException： 将指定元素插入此队列中，将等待可用的空间（如果有必要）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E paramE)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;     </span><br><span class="line">    checkNotNull(paramE); </span><br><span class="line">ReentrantLock localReentrantLock = <span class="keyword">this</span>.lock;              localReentrantLock.lockInterruptibly();     </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.count == <span class="keyword">this</span>.items.length) </span><br><span class="line">        <span class="keyword">this</span>.notFull.await();<span class="comment">//如果队列满了，则线程阻塞等待       enqueue(paramE); </span></span><br><span class="line">     localReentrantLock.unlock(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;       </span><br><span class="line">        localReentrantLock.unlock(); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;4：offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败。 </p><p><strong>获取数据操作：</strong> </p><ol><li><p>poll(time):取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等 time 参数规定的时间,取不到时返回 null; </p></li><li><p>poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在</p><p>指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数据可取，返回失败。 </p></li><li><p>take():取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入。 </p></li><li><p>drainTo():一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。 </p></li></ol><h3 id="14-2-Java-中的阻塞队列"><a href="#14-2-Java-中的阻塞队列" class="headerlink" title="14.2. Java 中的阻塞队列"></a>14.2. Java 中的阻塞队列</h3><ol><li><p>ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。 </p></li><li><p>LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。 </p></li><li><p>PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。 </p></li><li><p>DelayQueue：使用优先级队列实现的无界阻塞队列。 </p></li><li><p>SynchronousQueue：不存储元素的阻塞队列。 </p></li><li><p>LinkedTransferQueue：由链表结构组成的无界阻塞队列。 </p></li><li><p>LinkedBlockingDeque：由链表结构组成的双向阻塞队列 </p></li></ol><p><img src="/images/Java_heart_thread/clip_image016.gif" alt="img">  </p><h3 id="14-3-ArrayBlockingQueue（公平、非公平）"><a href="#14-3-ArrayBlockingQueue（公平、非公平）" class="headerlink" title="14.3.ArrayBlockingQueue（公平、非公平）"></a>14.3.ArrayBlockingQueue（公平、非公平）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。<strong>默认情况下不保证访问者公平的访问队列</strong>，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码<strong>创建一个公平的阻塞队列</strong>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayBlockingQueue fairQueue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1000</span>,<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h3 id="14-4-LinkedBlockingQueue（两个独立锁提高并发）"><a href="#14-4-LinkedBlockingQueue（两个独立锁提高并发）" class="headerlink" title="14.4. LinkedBlockingQueue（两个独立锁提高并发）"></a>14.4. LinkedBlockingQueue（两个独立锁提高并发）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;基于链表的阻塞队列，同ArrayListBlockingQueue类似，此队列按照先进先出（FIFO）的原则对元素进行排序。而 LinkedBlockingQueue 之所以能够高效的<strong>处理并发数据</strong>，还因为其<strong>对于生产者端和消费者端分别采用了独立的锁来控制数据同步</strong>，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。LinkedBlockingQueue 会默认一个类似无限大小的容量（Integer.MAX_VALUE）。 </p><h3 id="14-5-PriorityBlockingQueue（compareTo排序实现优先）"><a href="#14-5-PriorityBlockingQueue（compareTo排序实现优先）" class="headerlink" title="14.5.PriorityBlockingQueue（compareTo排序实现优先）"></a>14.5.PriorityBlockingQueue（compareTo排序实现优先）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是一个<strong>支持优先级的无界队列</strong>。默认情况下元素采取自然顺序升序排列。可以自定义实现 compareTo()方法来指定元素进行排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。</p><h3 id="14-6-DelayQueue（缓存失效、定时任务-）"><a href="#14-6-DelayQueue（缓存失效、定时任务-）" class="headerlink" title="14.6.DelayQueue（缓存失效、定时任务 ）"></a>14.6.DelayQueue（缓存失效、定时任务 ）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是一个支持<strong>延时获取元素的无界阻塞队列</strong>。队列使用PriorityQueue来实现。队列中的元素必须实现 Delayed 接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将 DelayQueue 运用在以下应用场景： </p><ol><li>缓存系统的设计：可以用 DelayQueue 保存缓存元素的有效期，使用一个线程循环查DelayQueue，一旦能从 DelayQueue 中获取元素时，表示缓存有效期到了。</li><li>定时任务调度：使用 DelayQueue 保存当天将会执行的任务和执行时间，一旦从DelayQueue 中获取到任务就开始执行，从比如 TimerQueue 就是使用 DelayQueue 实现的。 </li></ol><h3 id="14-7-SynchronousQueue（不存储数据、可用于传递数据）"><a href="#14-7-SynchronousQueue（不存储数据、可用于传递数据）" class="headerlink" title="14.7.SynchronousQueue（不存储数据、可用于传递数据）"></a>14.7.SynchronousQueue（不存储数据、可用于传递数据）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>是一个不存储元素的阻塞队列。每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素</strong>。 SynchronousQueue 可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另 外 一 个 线 程 使 用 ， SynchronousQueue 的 吞 吐 量 高 于 LinkedBlockingQueue 和ArrayBlockingQueue。 </p><h3 id="14-8-LinkedTransferQueue"><a href="#14-8-LinkedTransferQueue" class="headerlink" title="14.8. LinkedTransferQueue"></a>14.8. LinkedTransferQueue</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是 一 个 由 链 表 结 构 组 成 的 无 界 阻 塞 TransferQueue 队 列 。 相 对 于 其 他 阻 塞 队 列 ，LinkedTransferQueue 多了 tryTransfer 和 transfer 方法。 </p><ol><li><p>transfer 方法：如果当前有消费者正在等待接收元素（消费者使用 take()方法或带时间限制的 poll()方法时），transfer 方法可以<strong>把生产者传入的元素立刻 transfer（传输）给消费者</strong>。如果没有消费者在等待接收元素，transfer 方法会将元素存放在队列的 tail 节点，并等到该元素被消费者消费了才返回。 </p></li><li><p>tryTransfer 方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回 false。和 transfer 方法的区别是 tryTransfer 方法无论消费者是否接收，方法立即返回。而 transfer 方法是必须等到消费者消费了才返回。</p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;对于带有时间限制的 tryTransfer(E e, long timeout, TimeUnit unit)方法，则是试图把生产者传入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回 false，如果在超时时间内消费了元素，则返回 true。 </p><h3 id="14-9-LinkedBlockingDeque"><a href="#14-9-LinkedBlockingDeque" class="headerlink" title="14.9. LinkedBlockingDeque"></a>14.9. LinkedBlockingDeque</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是一个由链表结构组成的<strong>双向阻塞队列</strong>。所谓双向队列指的<strong>你可以从队列的两端插入和移出元素</strong>。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，LinkedBlockingDeque 多了 addFirst，addLast，offerFirst，offerLast， peekFirst，peekLast 等方法，以 First 单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素。以 Last 单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法 add 等同于 addLast，移除方法 remove 等效于 removeFirst。但是 take 方法却等同于 takeFirst，不知道是不是 Jdk 的 bug，使用时还是用带有 First 和 Last 后缀的方法更清楚。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在初始化 LinkedBlockingDeque 时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在“工作窃取”模式中。 </p><h2 id="15-CyclicBarrier、CountDownLatch、Semaphore-的用法"><a href="#15-CyclicBarrier、CountDownLatch、Semaphore-的用法" class="headerlink" title="15.CyclicBarrier、CountDownLatch、Semaphore 的用法"></a>15.CyclicBarrier、CountDownLatch、Semaphore 的用法</h2><h3 id="15-1-CountDownLatch（线程计数器-）"><a href="#15-1-CountDownLatch（线程计数器-）" class="headerlink" title="15.1.CountDownLatch（线程计数器 ）"></a>15.1.CountDownLatch（线程计数器 ）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务 A，它要等待其他 4 个任务执行完毕之后才能执行，此时就可以利用 CountDownLatch 来实现这种功能了。 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> Thread()&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;;&#125;.start();</span><br><span class="line"><span class="keyword">new</span> Thread()&#123; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"正在执行"</span>);</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完毕"</span>);</span><br><span class="line">latch.countDown();</span><br><span class="line">&#125;;&#125;.start();</span><br><span class="line">System.out.println(<span class="string">"等待 2 个子线程执行完毕..."</span>);</span><br><span class="line">latch.await();</span><br><span class="line">System.out.println(<span class="string">"2 个子线程已经执行完毕"</span>);</span><br><span class="line">System.out.println(<span class="string">"继续执行主线程"</span>);</span><br></pre></td></tr></table></figure><h3 id="15-2-CyclicBarrier（回环栅栏-等待至-barrier-状态再全部同时执行）"><a href="#15-2-CyclicBarrier（回环栅栏-等待至-barrier-状态再全部同时执行）" class="headerlink" title="15.2. CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）"></a>15.2. CyclicBarrier（回环栅栏-等待至 barrier 状态再全部同时执行）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier 可以被重用。我们暂且把这个状态就叫做barrier，当调用 await()方法之后，线程就处于 barrier 了。 </p><p>CyclicBarrier 中最重要的方法就是 await 方法，它有 2 个重载版本： </p><ol><li><p>public int await()：用来挂起当前线程，直至所有线程都到达 barrier 状态再同时执行后续任务； </p></li><li><p>public int await(long timeout, TimeUnit unit)：让这些线程等待至一定的时间，如果还有线程没有到达 barrier 状态就直接让到达 barrier 的线程执行后续任务。 </p></li></ol><p>具体使用如下，另外 CyclicBarrier 是可以重用的。 </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line"> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(N);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"> <span class="keyword">new</span> Writer(barrier).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">5000</span>); <span class="comment">//以睡眠来模拟线程需要预定写入数据操作</span></span><br><span class="line">System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"写入数据完毕，等待其他线程写入完毕"</span>);</span><br><span class="line">cyclicBarrier.await();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> System.out.println(<span class="string">"所有线程写入完毕，继续处理其他任务，比如数据操作"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="15-3-Semaphore（信号量-控制同时访问的线程个数）"><a href="#15-3-Semaphore（信号量-控制同时访问的线程个数）" class="headerlink" title="15.3.Semaphore（信号量-控制同时访问的线程个数）"></a>15.3.Semaphore（信号量-控制同时访问的线程个数）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Semaphore 翻译成字面意思为 信号量，<strong>Semaphore 可以控制同时访问的线程个数</strong>，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p><p>Semaphore 类中比较重要的几个方法：</p><ol><li><p>public void acquire(): 用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。</p></li><li><p>public void acquire(int permits):获取 permits 个许可</p></li><li><p>public void release() { } :释放许可。注意，在释放许可之前，必须先获获得许可。 </p></li><li><p>public void release(int permits) { }:释放 permits 个许可 </p></li></ol><p>上面 4 个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法 </p><ol><li><p>public boolean tryAcquire():尝试获取一个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false </p></li><li><p>public boolean tryAcquire(long timeout, TimeUnit unit):尝试获取一个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false </p></li><li><p>public boolean tryAcquire(int permits):尝试获取 permits 个许可，若获取成功，则立即返回 true，若获取失败，则立即返回 false </p></li><li><p>public boolean tryAcquire(int permits, long timeout, TimeUnit unit): 尝试获取 permits 个许可，若在指定的时间内获取成功，则立即返回 true，否则则立即返回 false </p></li><li><p>还可以通过 availablePermits()方法得到可用的许可数目。 </p></li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;例子：若一个工厂有5 台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过 Semaphore 来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = <span class="number">8</span>; <span class="comment">//工人数</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>); <span class="comment">//机器数目</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line"><span class="keyword">new</span> Worker(i,semaphore).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"><span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(<span class="keyword">int</span> num,Semaphore semaphore)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.num = num;</span><br><span class="line"><span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">semaphore.acquire();</span><br><span class="line">System.out.println(<span class="string">"工人"</span>+<span class="keyword">this</span>.num+<span class="string">"占用一个机器在生产..."</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">System.out.println(<span class="string">"工人"</span>+<span class="keyword">this</span>.num+<span class="string">"释放出机器"</span>);</span><br><span class="line">semaphore.release();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CountDownLatch 和 CyclicBarrier 都能够实现线程之间的等待，只不过它们侧重点不 同；CountDownLatch 一般用于某个线程 A 等待若干个其他线程执行完任务之后，它才执行；而 <strong>CyclicBarrier 一般用于一组线程互相等待至某个状态</strong>，然后这一组线程再同时执行；另外，CountDownLatch 是不能够重用的，而 CyclicBarrier 是可以重用的。 </li><li>Semaphore 其实和锁有点类似，它一般用于控制对某组资源的访问权限。</li></ul><h2 id="16-volatile-关键字的作用（变量可见性、禁止重排序）"><a href="#16-volatile-关键字的作用（变量可见性、禁止重排序）" class="headerlink" title="16.volatile 关键字的作用（变量可见性、禁止重排序）"></a>16.volatile 关键字的作用（变量可见性、禁止重排序）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 语言提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。volatile 变量具备两种特性，volatile 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 volatile 类型的变量时总会返回最新写入的值。 </p><p><strong>变量可见性</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;<u>其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。</u> </p><p><strong>禁止重排序</strong> </p><p> <u>volatile 禁止了指令重排。</u> </p><p>比sychronized更轻量级的同步锁 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在访问 volatile 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 volatile 变量是一种比 sychronized 关键字更轻量级的同步机制。volatile 适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。 </p><p><img src="/images/Java_heart_thread/clip_image017.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到 CPU 缓存中。如果计算机有多个 CPU，每个线程可能在不同的 CPU 上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。 </p><p><strong>适用场景</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;值得说明的是对 volatile 变量的单次读/写操作可以保证原子性的，如 long 和 double 类型变量，但是并不能保证 i++这种操作的原子性，因为本质上 i++是读、写两次操作。在某些场景下可以代替 Synchronized。但是,volatile 的不能完全取代 Synchronized 的位置，只有在一些特殊的场景下，才能适用 volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：</p><p> （1）对变量的写操作不依赖于当前值（比如 i++），或者说是单纯的变量赋值（boolean flag = true）。</p><p>（2）该变量没有包含在具有其他变量的不变式中，也就是说，不同的 volatile 变量之间，不能互相依赖。<strong>只有在状态真正独立于程序内其他内容时才能使用 volatile</strong>。 </p><h2 id="17-如何在两个线程之间共享数据"><a href="#17-如何在两个线程之间共享数据" class="headerlink" title="17.如何在两个线程之间共享数据"></a>17.如何在两个线程之间共享数据</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。Java 内存模型（JMM）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到“同步”和“互斥”。有以下常规实现方法： </p><ul><li>将数据抽象成一个类，并将数据的操作作为这个类的方法 </li></ul><ol><li>将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到同步，只要在方法上加”synchronized“ </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"> j++;</span><br><span class="line">System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line"> j--;</span><br><span class="line"> System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> j;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> MyData data;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">AddRunnable</span><span class="params">(MyData data)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.data= data;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> data.add();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"> MyData data;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DecRunnable</span><span class="params">(MyData data)</span></span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.data = data;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> data.dec();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line"> Runnable add = <span class="keyword">new</span> AddRunnable(data);</span><br><span class="line"> Runnable dec = <span class="keyword">new</span> DecRunnable(data);</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">new</span> Thread(add).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(dec).start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Runnable对象作为一个类的内部类 </li></ul><ol start="2"><li>将 Runnable 对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个 Runnable 对象调用外部类的这些方法。 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line"> j++;</span><br><span class="line"> System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</span><br><span class="line"> j--;</span><br><span class="line"> System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j 为："</span>+j);</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">final</span> MyData data = <span class="keyword">new</span> MyData();</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line"> <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> data.add();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;).start();</span><br><span class="line"> <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> data.dec();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;).start();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-ThreadLocal-作用（线程本地存储）"><a href="#18-ThreadLocal-作用（线程本地存储）" class="headerlink" title="18.ThreadLocal 作用（线程本地存储）"></a>18.ThreadLocal 作用（线程本地存储）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，ThreadLocal 的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。 </p><p><strong>ThreadLocalMap（线程的一个属性）</strong> </p><ol><li><p>每个线程中都有一个自己的 ThreadLocalMap 类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。 </p></li><li><p>将一个共用的 ThreadLocal 静态实例作为 key，将不同对象的引用保存到不同线程的 ThreadLocalMap 中，然后在线程执行的各处通过这个静态 ThreadLocal 实例的 get()方法取得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。 </p></li><li><p>ThreadLocalMap 其实就是线程里面的一个属性，它在 Thread 类中定义 </p><p>ThreadLocal.ThreadLocalMap threadLocals = null; </p></li></ol><p><img src="/images/Java_heart_thread/clip_image018.gif" alt="img"> </p><p><strong>使用场景</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;最常见的 ThreadLocal 使用场景为 用来解决 数据库连接、Session 管理等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;</span><br><span class="line"> Session s = (Session) threadSession.get();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;</span><br><span class="line"> s = getSessionFactory().openSession();</span><br><span class="line"> threadSession.set(s);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-synchronized-和-ReentrantLock-的区别"><a href="#19-synchronized-和-ReentrantLock-的区别" class="headerlink" title="19.synchronized 和 ReentrantLock 的区别"></a>19.synchronized 和 ReentrantLock 的区别</h2><h3 id="19-1-两者的共同点："><a href="#19-1-两者的共同点：" class="headerlink" title="19.1. 两者的共同点："></a>19.1. 两者的共同点：</h3><ol><li><p>都是用来协调多线程对共享对象、变量的访问 </p></li><li><p>都是可重入锁，同一线程可以多次获得同一个锁 </p></li><li><p>都保证了可见性和互斥性 </p></li></ol><h3 id="19-2-两者的不同点："><a href="#19-2-两者的不同点：" class="headerlink" title="19.2. 两者的不同点："></a>19.2. 两者的不同点：</h3><ol><li><p>ReentrantLock 显示的获得、释放锁，synchronized 隐式获得释放锁 </p></li><li><p>ReentrantLock 可响应中断、可轮回，synchronized 是不可以响应中断的，为处理锁的不可用性提供了更高的灵活性 </p></li><li><p><strong>ReentrantLock 是 API 级别的，synchronized 是 JVM 级别的</strong></p></li><li><p>ReentrantLock 可以实现公平锁 </p></li><li><p>ReentrantLock 通过 Condition 可以绑定多个条件</p></li><li><p>底层实现不一样， <strong>synchronized 是同步阻塞，使用的是悲观并发策略，lock 是同步非阻塞，采用的是乐观并发策略</strong> </p></li><li><p>Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现。 </p></li><li><p><strong>synchronized 在发生异常时，会自动释放线程占有的锁</strong>，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁。 </p></li><li><p><strong>Lock 可以让等待锁的线程响应中断</strong>，而 synchronized 却不行，使用 synchronized 时，等待的线程会一直等待下去，不能够响应中断。 </p></li><li><p>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。 </p></li><li><p>Lock 可以提高多个线程进行读操作的效率，既就是实现读写锁等。 </p></li></ol><h2 id="20-ConcurrentHashMap-并发"><a href="#20-ConcurrentHashMap-并发" class="headerlink" title="20.ConcurrentHashMap 并发"></a>20.ConcurrentHashMap 并发</h2><h3 id="20-1-减小锁粒度"><a href="#20-1-减小锁粒度" class="headerlink" title="20.1.  减小锁粒度"></a>20.1.  减小锁粒度</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;减小锁粒度是指缩小锁定对象的范围，从而减小锁冲突的可能性，从而提高系统的并发能力。减小锁粒度是一种削弱多线程锁竞争的有效手段，这种技术典型的应用是 ConcurrentHashMap(高性能的 HashMap)类的实现。对于 HashMap 而言，最重要的两个方法是 get 与 set 方法，如果我们对整个 HashMap 加锁，可以得到线程安全的对象，但是加锁粒度太大。Segment 的大小也被<strong>称为 ConcurrentHashMap 的并发度</strong>。 </p><h3 id="20-2-ConcurrentHashMap-分段锁"><a href="#20-2-ConcurrentHashMap-分段锁" class="headerlink" title="20.2.  ConcurrentHashMap 分段锁"></a>20.2.  ConcurrentHashMap 分段锁</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap，它内部细分了若干个小的 HashMap，称之为段(Segment)。<strong>默认情况下一个 ConcurrentHashMap 被进一步细分为 16 个段</strong>，既就是锁的并发度。 如果需要在 ConcurrentHashMap 中添加一个新的表项，并不是将整个 HashMap 加锁，而是首先根据hashcode得到该表项应该存放在哪个段中，然后对该段加锁，并完成put操作。在多线程环境中，如果多个线程同时进行put操作，只要被加入的表项不存放在同一个段中，则线程间可以做到真正的并行。 </p><p><strong>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成。Segment 是一种可重入锁 ReentrantLock，在 ConcurrentHashMap 里扮演锁的角色，HashEntry 则用于存储键值对数据。一个 ConcurrentHashMap 里包含一个 Segment 数组，Segment 的结构和 HashMap 类似，是一种数组和链表结构， 一个 Segment 里包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素， <strong>每个 Segment 守护一个 HashEntry 数组里的元素,当对 HashEntry 数组的数据进行修改时，必须首先获得它对应的 Segment 锁。</strong> </p><p><img src="/images/Java_heart_thread/clip_image19.gif" alt="img"> </p><h2 id="21-Java-中用到的线程调度"><a href="#21-Java-中用到的线程调度" class="headerlink" title="21.Java 中用到的线程调度"></a>21.Java 中用到的线程调度</h2><h3 id="21-1-抢占式调度："><a href="#21-1-抢占式调度：" class="headerlink" title="21.1.  抢占式调度："></a>21.1.  抢占式调度：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。</p><h3 id="21-2-协同式调度："><a href="#21-2-协同式调度：" class="headerlink" title="21.2.  协同式调度："></a>21.2.  协同式调度：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。</p><p><img src="/images/Java_heart_thread/clip_image20.gif" alt="img"> </p><h3 id="21-3-JVM-的线程调度实现（抢占式调度）"><a href="#21-3-JVM-的线程调度实现（抢占式调度）" class="headerlink" title="21.3.  JVM 的线程调度实现（抢占式调度）"></a>21.3.  JVM 的线程调度实现（抢占式调度）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;java 使用的线程调使用抢占式调度，Java 中线程会按优先级分配 CPU 时间片运行，<strong>且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片</strong>，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。</p><h3 id="21-4-线程让出-cpu-的情况："><a href="#21-4-线程让出-cpu-的情况：" class="headerlink" title="21.4.  线程让出 cpu 的情况："></a>21.4.  线程让出 cpu 的情况：</h3><ol><li><p>当前运行线程主动放弃 CPU，JVM 暂时放弃 CPU 操作（基于时间片轮转调度的 JVM 操作系统不会让线程永久放弃 CPU，或者说放弃本次时间片的执行权），例如调用 yield()方法。 </p></li><li><p>当前运行线程因为某些原因进入阻塞状态，例如阻塞在 I/O 上。 </p></li><li><p>当前运行线程结束，即运行完 run()方法里面的任务。</p></li></ol><h2 id="22-进程调度算法"><a href="#22-进程调度算法" class="headerlink" title="22.进程调度算法"></a>22.进程调度算法</h2><h3 id="22-1-优先调度算法"><a href="#22-1-优先调度算法" class="headerlink" title="22.1. 优先调度算法"></a>22.1. 优先调度算法</h3><ol><li>先来先服务调度算法（FCFS）    </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。在进程调度中采用 FCFS 算法时，则每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机，特点是：算法比较简单，可以实现基本上的公平。 </p><ol start="2"><li>短作业(进程)优先调度算法 </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。该算法未照顾紧迫型作业。</p><h3 id="22-2-高优先权优先调度算法"><a href="#22-2-高优先权优先调度算法" class="headerlink" title="22.2. 高优先权优先调度算法"></a>22.2. 高优先权优先调度算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是把处理机分配给就绪队列中优先权最高的进程。</p><ol><li>非抢占式优先权算法 </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><ol start="2"><li>抢占式优先权调度算法 </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。<strong>但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程</strong>(原优先权最高的进程) 的执行，重新将处理机分配给新到的优先权最高的进程。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p><ol start="3"><li>高响应比优先调度算法    </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;在批处理系统中，短作业优先算法是一种比较好的算法，其主要的不足之处是长作业的运行得不到保证。如果我们能为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a 提高，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为： </p><p><img src="/images/Java_heart_thread/clip_image010.jpg" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;(1)   如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;(2)   当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;(3)   对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。</p><h3 id="22-3-基于时间片的轮转调度算法"><a href="#22-3-基于时间片的轮转调度算法" class="headerlink" title="22.3. 基于时间片的轮转调度算法"></a>22.3. 基于时间片的轮转调度算法</h3><ol><li>时间片轮转法 </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几 ms 到几百 ms。<strong>当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片</strong>。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。 </p><ol start="2"><li>多级反馈队列调度算法 </li></ol><p>&nbsp;&nbsp;&nbsp;&nbsp;1)、应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，……，第 i+1 个队列的时间片要比第 i 个队列的时间片长一倍。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;2)、当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第 n 队列后，在第 n 队列便采取按时间片轮转的方式运行。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;3)、仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第 1～(i-1)队列均空时，才会调度第 i 队列中的进程运行。如果处理机正在第 i 队列中为某进程服务时，又有新进程进入优先权较高的队列(第 1～(i-1)中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第 i 队列的末尾，把处理机分配给新到的高优先权进程。  </p><p>&nbsp;&nbsp;&nbsp;&nbsp;在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能够较好的满足各种类型用户的需要。</p><h2 id="23-什么是-CAS（比较并交换-乐观锁机制-锁自旋）"><a href="#23-什么是-CAS（比较并交换-乐观锁机制-锁自旋）" class="headerlink" title="23.什么是 CAS（比较并交换-乐观锁机制-锁自旋）"></a>23.什么是 CAS（比较并交换-乐观锁机制-锁自旋）</h2><h3 id="23-1-概念及特性"><a href="#23-1-概念及特性" class="headerlink" title="23.1.  概念及特性"></a>23.1.  概念及特性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数 CAS(V,E,N)。<strong>V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;CAS 操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。<strong>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作</strong>。基于这样的原理， CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。 </p><h3 id="23-2-原子包-java-util-concurrent-atomic（锁自旋）"><a href="#23-2-原子包-java-util-concurrent-atomic（锁自旋）" class="headerlink" title="23.2.  原子包 java.util.concurrent.atomic（锁自旋）"></a>23.2.  原子包 java.util.concurrent.atomic（锁自旋）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;JDK1.5 的原子包：java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，<strong>即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入</strong>，这只是一种逻辑上的理解。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;相对于对于 synchronized 这种阻塞算法，CAS 是非阻塞算法的一种常见实现。<strong>由于一般 CPU 切换时间比 CPU 指令集操作更加长</strong>， 所以 J.U.C 在性能上有了很大的提升。如下代码： </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> value;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (;;) &#123; <span class="comment">//CAS 自旋，一直尝试，直达成功</span></span><br><span class="line"> <span class="keyword">int</span> current = get();</span><br><span class="line"> <span class="keyword">int</span> next = current + <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span> (compareAndSet(current, next))</span><br><span class="line"> <span class="keyword">return</span> current;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;getAndIncrement 采用了 CAS 操作，每次从内存中读取数据然后将此数据和+1 后的结果进行 CAS 操作，如果成功就返回结果，否则重试直到成功为止。而 compareAndSet 利用 JNI 来完成 CPU 指令的操作。 </p><p><img src="/images/Java_heart_thread/clip_image022.gif" alt="img"> </p><h3 id="23-3-ABA-问题"><a href="#23-3-ABA-问题" class="headerlink" title="23.3.  ABA 问题"></a>23.3.  ABA 问题</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;CAS 会导致“ABA 问题”。<strong>CAS 算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化</strong>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;比如说一个线程 <strong>one 从内存位置 V 中取出 A</strong>，这时候另一个线程 <strong>two 也从内存中取出 A</strong>，并且 <strong>two 进行了一些操作变成了 B</strong>，然后 <strong>two 又将 V 位置的数据变成 A</strong>，这时候线程 <strong>one 进行 CAS 操作发现内存中仍然是 A</strong>，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但是不代表这个过程就是没有问题的。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;部分乐观锁的实现是通过版本号（version）的方式来解决 ABA 问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1 操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加不会减少。</p><h2 id="24-什么是-AQS（抽象的队列同步器）"><a href="#24-什么是-AQS（抽象的队列同步器）" class="headerlink" title="24.什么是 AQS（抽象的队列同步器）"></a>24.什么是 AQS（抽象的队列同步器）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，<strong>AQS 定义了一套多线程访问共享资源的同步器框架</strong>，许多同步类实现都依赖于它，如常用的ReentrantLock、Semaphore、CountDownLatch。 </p><p><img src="/images/Java_heart_thread/clip_image023.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的访问方式有三种: </p><ul><li>getState() </li><li>setState() </li><li>compareAndSetState() </li></ul><p><strong>AQS 定义两种资源共享方式</strong> </p><p><strong>Exclusive独占资源-ReentrantLock</strong></p><p><strong>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）</strong> </p><p><strong>Share共享资源-Semaphore/CountDownLatch</strong></p><p><strong>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。</strong></p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现</strong>，AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS)之所以没有定义成 abstract，是因为独占模式下只用实现 tryAcquire-tryRelease，而共享模式下只用实现 tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/ 唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法： </p><ol><li><p>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。 </p></li><li><p>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。 3． tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。 </p></li><li><p>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 </p></li><li><p>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。 </p></li></ol><p><strong>同步器的实现是ABS核心（state资源状态计数）</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;同步器的实现是 ABS 核心，以 ReentrantLock 为例，<strong>state 初始化为 0，表示未锁定状态。A 线程 lock()时，会调用 tryAcquire()独占该锁并将 state+1。此后，其他线程再 tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止</strong>，其它线程才有机会获取该锁。当然，释放锁之前，<strong>A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念</strong>。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown()一次，state 会 CAS 减1。等到所有子线程都执行完后(即state=0)，会 unpark()主调用线程，然后主调用线程就会从 await()函数返回，继续后余动作。 </p><p><strong>ReentrantReadWriteLock实现独占和共享两种方式</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 <strong>AQS 也支持自定义同步器同时实现独占和共享两种方式，如 ReentrantReadWriteLock</strong>。</p><h2 id="25-最后"><a href="#25-最后" class="headerlink" title="25.最后"></a>25.最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-JAVA并发知识库&quot;&gt;&lt;a href=&quot;#1-JAVA并发知识库&quot; class=&quot;headerlink&quot; title=&quot;1.JAVA并发知识库&quot;&gt;&lt;/a&gt;1.JAVA并发知识库&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/Java_heart_thread/clip_image003.gif&quot; alt=&quot;img&quot;&gt; &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java核心(二)之集合</title>
    <link href="https://quietair.gitee.io/Java_heart_list/"/>
    <id>https://quietair.gitee.io/Java_heart_list/</id>
    <published>2019-11-09T06:32:07.000Z</published>
    <updated>2020-05-04T07:04:49.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-接口继承关系和实现"><a href="#1-接口继承关系和实现" class="headerlink" title="1.接口继承关系和实现"></a>1.接口继承关系和实现</h2><p>集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。</p><ol><li><p>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。</p></li><li><p>Iterator：迭代器，可以通过迭代器遍历集合中的数据 </p></li><li><p>Map：是映射表的基础接口 </p></li></ol><a id="more"></a><p><img src="/images/Java_heart_list/clip_image003.gif" alt> </p><p><img src="/images/Java_heart_list/clip_image005.gif" alt="img"> </p><h2 id="2-List"><a href="#2-List" class="headerlink" title="2.List"></a>2.List</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Java 的 List 是非常常用的数据类型。<strong>List 是有序的 Collection</strong>。Java List 一共三个实现类：分别是 ArrayList、Vector 和 LinkedList。 </p><p><img src="/images/Java_heart_list/clip_image007.jpg" alt="img"> </p><h3 id="2-1-ArrayList（数组）"><a href="#2-1-ArrayList（数组）" class="headerlink" title="2.1.  ArrayList（数组）"></a>2.1.  ArrayList（数组）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 </p><h3 id="2-2-Vector（数组实现、线程同步）"><a href="#2-2-Vector（数组实现、线程同步）" class="headerlink" title="2.2.  Vector（数组实现、线程同步）"></a>2.2.  Vector（数组实现、线程同步）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Vector 与 ArrayList 一样，也是通过数组实现的，不同的是<strong>它支持线程的同步，即某一时刻只有一个线程能够写 Vector</strong>，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 </p><h3 id="2-3-LinkList（链表）"><a href="#2-3-LinkList（链表）" class="headerlink" title="2.3.  LinkList（链表）"></a>2.3.  LinkList（链表）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除</strong>，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 </p><h2 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Set 注重独一无二的性质,该体系集合用于存储无序(存入和取出的顺序不一定相同)元素，<strong>值不能重复</strong>。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，<strong>如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法</strong>。 </p><p><img src="/images/Java_heart_list/clip_image009.gif" alt="img"> </p><h3 id="3-1-HashSet（Hash-表）"><a href="#3-1-HashSet（Hash-表）" class="headerlink" title="3.1.HashSet（Hash 表）"></a>3.1.HashSet（Hash 表）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的 hashcode 方法来获取的，** HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。** </p><p>&nbsp;&nbsp;&nbsp;&nbsp;哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。 </p><p><img src="/images/Java_heart_list/clip_image011.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;HashSet 通过 hashCode 值来确定元素在内存中的位置。<strong>一个 hashCode 位置上可以存放多个元素</strong>。 </p><h3 id="3-2-TreeSet（二叉树）"><a href="#3-2-TreeSet（二叉树）" class="headerlink" title="3.2.TreeSet（二叉树）"></a>3.2.TreeSet（二叉树）</h3><ol><li><p>TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 </p></li><li><p>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，<strong>自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数</strong>，才可以正常使用。 </p></li><li><p>在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序 </p></li><li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p></li></ol><h3 id="3-3-LinkHashSet（HashSet-LinkedHashMap）"><a href="#3-3-LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="3.3.LinkHashSet（HashSet+LinkedHashMap）"></a>3.3.LinkHashSet（HashSet+LinkedHashMap）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。 LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 </p><h2 id="4-Map"><a href="#4-Map" class="headerlink" title="4.Map"></a>4.Map</h2><p><img src="/images/Java_heart_list/clip_image013.gif" alt="img"> </p><h3 id="4-1-HashMap（数组-链表-红黑树）"><a href="#4-1-HashMap（数组-链表-红黑树）" class="headerlink" title="4.1. HashMap（数组+链表+红黑树）"></a>4.1. HashMap（数组+链表+红黑树）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍HashMap 的结构。</p><h4 id="4-1-1-JAVA7-实现"><a href="#4-1-1-JAVA7-实现" class="headerlink" title="4.1.1.   JAVA7 实现"></a>4.1.1.   JAVA7 实现</h4><p><img src="/images/Java_heart_list/clip_image015.gif" alt="img"> </p><p>&nbsp;&nbsp;&nbsp;&nbsp;大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：<strong>key, value, hash 值和用于单向链表</strong>的 next。 </p><ol><li><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 </p></li><li><p>loadFactor：负载因子，默认为 0.75。</p></li><li><p>threshold：扩容的阈值，等于 capacity * loadFactor </p></li></ol><h4 id="4-1-2-JAVA8-实现"><a href="#4-1-2-JAVA8-实现" class="headerlink" title="4.1.2.   JAVA8 实现"></a>4.1.2.   JAVA8 实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp; Java8对 HashMap 进行了一些修改，<strong>最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树组成</strong>。 </p><p>&nbsp;&nbsp;&nbsp;&nbsp;根据Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，<strong>需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)</strong>。为了降低这部分的开销，在 Java8 中，<strong>当链表中的元素超过了 8 个以后，会将链表转换为红黑树</strong>，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 </p><p><img src="/images/Java_heart_list/clip_image017.gif" alt="img"> </p><h3 id="4-2-ConcurrentHashMap"><a href="#4-2-ConcurrentHashMap" class="headerlink" title="4.2. ConcurrentHashMap"></a>4.2. ConcurrentHashMap</h3><h4 id="4-2-1-Segment段"><a href="#4-2-1-Segment段" class="headerlink" title="4.2.1.   Segment段"></a>4.2.1.   Segment段</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了“槽”来代表一个 </p><p>segment。 </p><h4 id="4-2-2-线程安全Segment继承ReentrantLock加锁）"><a href="#4-2-2-线程安全Segment继承ReentrantLock加锁）" class="headerlink" title="4.2.2.线程安全Segment继承ReentrantLock加锁）"></a>4.2.2.线程安全Segment继承ReentrantLock加锁）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="/images/Java_heart_list/clip_image019.gif" alt="img"> </p><h4 id="4-2-3-并行度（默认16）"><a href="#4-2-3-并行度（默认16）" class="headerlink" title="4.2.3.并行度（默认16）"></a>4.2.3.并行度（默认16）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 <strong>ConcurrentHashMap 有 16 个 Segments</strong>，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 </p><h4 id="4-2-4-Java8-实现（引入了红黑树）"><a href="#4-2-4-Java8-实现（引入了红黑树）" class="headerlink" title="4.2.4. Java8 实现（引入了红黑树）"></a>4.2.4. Java8 实现（引入了红黑树）</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;Java8 对 ConcurrentHashMap 进行了比较大的改动,Java8 也引入了红黑树。 </p><p><img src="/images/Java_heart_list/clip_image021.gif" alt="img"> </p><h3 id="4-3-HashTable（线程安全）"><a href="#4-3-HashTable（线程安全）" class="headerlink" title="4.3. HashTable（线程安全）"></a>4.3. HashTable（线程安全）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。 </p><h3 id="4-4-TreeMap（可排序）"><a href="#4-4-TreeMap（可排序）" class="headerlink" title="4.4. TreeMap（可排序）"></a>4.4. TreeMap（可排序）</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。 如果使用排序的映射，建议使用 TreeMap。 </p><p>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。 </p><p>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html</a></p><p><strong>4.5. LinkHashMap</strong>（记录插入顺序） </p><p>&nbsp;&nbsp;&nbsp;&nbsp;LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 </p><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5.最后"></a>5.最后</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;java核心这部分，偶然所得的一份pdf文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-接口继承关系和实现&quot;&gt;&lt;a href=&quot;#1-接口继承关系和实现&quot; class=&quot;headerlink&quot; title=&quot;1.接口继承关系和实现&quot;&gt;&lt;/a&gt;1.接口继承关系和实现&lt;/h2&gt;&lt;p&gt;集合类存放于 Java.util 包中，主要有 3 种：set(集）、list(列表包含 Queue）和 map(映射)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Collection：Collection 是集合 List、Set、Queue 的最基本的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Iterator：迭代器，可以通过迭代器遍历集合中的数据 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Map：是映射表的基础接口 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
</feed>
