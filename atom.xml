<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>QuietAir</title>
  
  <subtitle>沉静的空气，环绕身边，让时间失衡</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://quietair.gitee.io/"/>
  <updated>2020-03-23T15:11:52.682Z</updated>
  <id>https://quietair.gitee.io/</id>
  
  <author>
    <name>QuietAir</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot 与日志</title>
    <link href="https://quietair.gitee.io/spring-boot-logging/"/>
    <id>https://quietair.gitee.io/spring-boot-logging/</id>
    <published>2020-03-12T02:47:23.000Z</published>
    <updated>2020-03-23T15:11:52.682Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-日志框架"><a href="#1-日志框架" class="headerlink" title="1. 日志框架"></a>1. 日志框架</h2><p>一个统一的接口层；日志门面（日志的一个抽象层）；</p><p>给项目中导入具体的日志实现就行了；之前的日志框架都是实现的抽象层；</p><p>市面上的日志框架:</p><p>JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j……</p><a id="more"></a><table><thead><tr><th>日志门面  （日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL（Jakarta  Commons Logging）</del>    SLF4j（Simple  Logging Facade for Java）    <strong><del>jboss-logging</del></strong></td><td>Log4j  JUL（java.util.logging）  Log4j2  <strong>Logback</strong></td></tr></tbody></table><p>左边选一个门面（抽象层）、右边来选一个实现；</p><p>日志门面：  SLF4J；</p><p>日志实现：Logback；</p><p>SpringBoot：底层是 Spring 框架，Spring 框架默认是用 JCL；</p><p>​    <strong>SpringBoot 选用 SLF4j 和 logback；</strong></p><h2 id="2-SLF4j-使用"><a href="#2-SLF4j-使用" class="headerlink" title="2.SLF4j 使用"></a>2.SLF4j 使用</h2><h3 id="2-1-如何在系统中使用-SLF4j"><a href="#2-1-如何在系统中使用-SLF4j" class="headerlink" title="2.1. 如何在系统中使用 SLF4j"></a>2.1. 如何在系统中使用 SLF4j</h3><p><a href="http://www.slf4j.org/manual.html" target="_blank" rel="noopener">用户文档</a></p><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法；</p><p>给系统里面导入 slf4j 的 jar 和  logback 的实现 jar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger (HelloWorld.class);</span><br><span class="line">    logger.info (<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图示；</p><p><img src="/images/spring-boot-logging/concrete-bindings.png" alt="images/concrete-bindings.png"></p><p>每一个日志的实现框架都有自己的配置文件。使用 slf4j 以后，** 配置文件还是做成日志实现框架自己本身的配置文件；**</p><h3 id="2-2-遗留问题"><a href="#2-2-遗留问题" class="headerlink" title="2.2. 遗留问题"></a>2.2. 遗留问题</h3><p>a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx</p><p>统一日志记录，即使是别的框架和我一起统一使用 slf4j 进行输出？</p><p><img src="/images/spring-boot-logging/legacy.png" alt></p><p>** 如何让系统中所有的日志都统一到 slf4j；**</p><p>1、将系统中其他日志框架先排除出去；</p><p>2、用中间包来替换原有的日志框架；</p><p>3、我们导入 slf4j 其他的实现；</p><h2 id="3-SpringBoot-日志关系"><a href="#3-SpringBoot-日志关系" class="headerlink" title="3.SpringBoot 日志关系"></a>3.SpringBoot 日志关系</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot 使用它来做日志功能；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>底层依赖关系</p><p><img src="/images/spring-boot-logging/20200311190119.png" alt></p><p>总结：</p><p>​    1）、SpringBoot 底层也是使用 slf4j+logback 的方式进行日志记录</p><p>​    2）、SpringBoot 也把其他的日志都替换成了 slf4j；</p><p>​    3）、中间替换包？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = <span class="string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory ();</span><br></pre></td></tr></table></figure><p><img src="/images/spring-boot-logging/20200311190307.png" alt></p><p>​    4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？</p><p>​            Spring 框架用的是 commons-logging；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SpringBoot 能自动适配所有的日志，而且底层使用 slf4j+logback 的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；</strong></p><h2 id="4-日志使用"><a href="#4-日志使用" class="headerlink" title="4. 日志使用"></a>4. 日志使用</h2><h3 id="4-1-默认配置"><a href="#4-1-默认配置" class="headerlink" title="4.1. 默认配置"></a>4.1. 默认配置</h3><p>SpringBoot 默认帮我们配置好了日志；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录器 </span></span><br><span class="line">Logger logger = LoggerFactory.getLogger (getClass ());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//System.out.println ();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志的级别；</span></span><br><span class="line">    <span class="comment">// 由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line">    <span class="comment">// 可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 </span></span><br><span class="line">    logger.trace (<span class="string">"这是 trace 日志..."</span>);</span><br><span class="line">    logger.debug (<span class="string">"这是 debug 日志..."</span>);</span><br><span class="line">    <span class="comment">//SpringBoot 默认给我们使用的是 info 级别的，没有指定级别的就用 SpringBoot 默认规定的级别；root 级别 </span></span><br><span class="line">    logger.info (<span class="string">"这是 info 日志..."</span>);</span><br><span class="line">    logger.warn (<span class="string">"这是 warn 日志..."</span>);</span><br><span class="line">    logger.error (<span class="string">"这是 error 日志..."</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">--</span> </span></span><br><span class="line"><span class="tag">  日志输出格式：</span></span><br><span class="line"><span class="tag">%<span class="attr">d</span> 表示日期时间，</span></span><br><span class="line"><span class="tag">%<span class="attr">thread</span> 表示线程名，</span></span><br><span class="line"><span class="tag">%<span class="attr">-5level</span>：级别从左显示 < span class="attr">5</span> 个字符宽度 </span><br><span class="line"><span class="tag">%<span class="attr">logger</span>&#123;<span class="attr">50</span>&#125; 表示 < span class="attr">logger</span> 名字最长 < span class="attr">50</span> 个字符，否则按照句点分割。 <br><span class="line"><span class="tag">%<span class="attr">msg</span>：日志消息，</span></span><br><span class="line"><span class="tag">%<span class="attr">n</span> 是换行符 </span></span><br><span class="line"><span class="tag">  <span class="attr">--</span>&gt;</span></span><br><span class="line">  % d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [% thread] %-5level % logger&#123;50&#125; - % msg% n</span><br></pre></td></tr></table></figure><p>SpringBoot 修改日志的默认配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.com.atguigu</span>=<span class="string">trace</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.path=(过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前项目下生成 my.log 日志 </span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">my.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.file=G:/springboot.log (过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#logging.file.path= 文件名  直接在跟目录下创建该文件且自动 帮你创建好 spring.log 文件 </span></span><br><span class="line"><span class="meta">logging.file.name</span>=<span class="string">/log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前磁盘的根路径下创建 spring 文件夹和里面的 log 文件夹；使用 spring.log 作为默认文件 </span></span><br><span class="line"><span class="meta">logging.path</span>=<span class="string">/spring/log (过时)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  在控制台输出的日志的格式 </span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">% d&#123;yyyy-MM-dd&#125; [% thread] %-5level % logger&#123;50&#125; - % msg% n</span></span><br><span class="line"><span class="comment"># 指定文件中日志输出的格式 </span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">% d&#123;yyyy-MM-dd&#125; === [% thread] === %-5level === % logger&#123;50&#125; ==== % msg% n</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>logging.file.name</th><th>logging.file.name</th><th>Example</th><th>Description</th></tr></thead><tbody><tr><td>(none)</td><td>(none)</td><td></td><td>仅控制台记录。</td></tr><tr><td>指定文件名</td><td>(none)</td><td>my.log</td><td>写入指定的日志文件。名称可以是确切的位置，也可以相对于当前目录。</td></tr><tr><td>(none)</td><td>指定目录</td><td>/var/log</td><td>写入 <code>spring.log</code> 指定的目录。名称可以是确切的位置，也可以相对于当前目录。</td></tr></tbody></table><h3 id="4-2-指定配置"><a href="#4-2-指定配置" class="headerlink" title="4.2. 指定配置"></a>4.2. 指定配置</h3><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#boot-features-logging" target="_blank" rel="noopener">官方日志文档</a>；给类路径下放上每个日志框架自己的配置文件即可；SpringBoot 就不使用他默认配置的了</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p>官方建议将 <code>-spring</code> 变体用于日志记录配置（例如，<code>logback-spring.xml</code> 而不是 <code>logback.xml</code>）。如果使用标准配置位置，Spring 将无法完全控制日志初始化。</p><p>如果用 logback.xml：直接就被日志框架识别了；</p><p><strong>logback-spring.xml</strong>：日志框架就不直接加载日志的配置项，由 SpringBoot 解析日志配置，可以使用 SpringBoot 的高级 Profile 功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"staging"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configuration to be enabled when the "staging" profile is active --&gt;</span></span><br><span class="line">  可以指定某段配置只在某个环境下生效 </span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"stdout"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">% d 表示日期时间，</span></span><br><span class="line"><span class="comment">% thread 表示线程名，</span></span><br><span class="line"><span class="comment">%-5level：级别从左显示 5 个字符宽度 </span></span><br><span class="line"><span class="comment">% logger&#123;50&#125; 表示 logger 名字最长 50 个字符，否则按照句点分割。 </span></span><br><span class="line"><span class="comment">% msg：日志消息，</span></span><br><span class="line"><span class="comment">% n 是换行符 </span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>% d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [% thread] ---&gt; %-5level % logger&#123;50&#125; - % msg% n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"!dev"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>% d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [% thread] ==== %-5level % logger&#123;50&#125; - % msg% n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果使用 logback.xml 作为日志配置文件，还要使用 profile 功能，会有以下错误:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no applicable action for [springProfile]</span><br></pre></td></tr></table></figure><h2 id="5-切换日志框架"><a href="#5-切换日志框架" class="headerlink" title="5. 切换日志框架"></a>5. 切换日志框架</h2><p>可以按照 slf4j 的日志适配图，进行相关的切换；</p><p>slf4j+log4j 的方式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>切换为 log4j2:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-最后"><a href="#6-最后" class="headerlink" title="6. 最后"></a>6. 最后</h2><p>​    此 spring boot 部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-日志框架&quot;&gt;&lt;a href=&quot;#1-日志框架&quot; class=&quot;headerlink&quot; title=&quot;1. 日志框架&quot;&gt;&lt;/a&gt;1. 日志框架&lt;/h2&gt;&lt;p&gt;一个统一的接口层；日志门面（日志的一个抽象层）；&lt;/p&gt;
&lt;p&gt;给项目中导入具体的日志实现就行了；之前的日志框架都是实现的抽象层；&lt;/p&gt;
&lt;p&gt;市面上的日志框架:&lt;/p&gt;
&lt;p&gt;JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j……&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 配置文件解析</title>
    <link href="https://quietair.gitee.io/spring-boot-configuration/"/>
    <id>https://quietair.gitee.io/spring-boot-configuration/</id>
    <published>2020-03-05T07:46:27.000Z</published>
    <updated>2020-03-22T15:55:29.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h2><p>SpringBoot 使用一个全局的配置文件，配置文件名是固定的；</p><p>・application.properties</p><p>・application.yml</p><p>配置文件的作用：修改 SpringBoot 自动配置的默认值；SpringBoot 在底层都给我们自动配置好；</p><a id="more"></a><p>YAML（YAML Ain’t Markup Language）</p><p>​    YAML  A Markup Language：是一个标记语言</p><p>​    YAML   isn’t Markup Language：不是一个标记语言；</p><p>标记语言：</p><p>​    以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong> 文件；</p><p>​    YAML：** 以数据为中心 **，比 json、xml 等更适合做配置文件；</p><p>​    YAML：配置例子</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>​    XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-YAML-语法："><a href="#2-YAML-语法：" class="headerlink" title="2.YAML 语法："></a>2.YAML 语法：</h2><h3 id="2-1-基本语法"><a href="#2-1-基本语法" class="headerlink" title="2.1. 基本语法"></a>2.1. 基本语法</h3><p>k:(空格) v：表示一对键值对（空格必须有）；</p><p>以 ** 空格 ** 的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p>属性和值也是大小写敏感；</p><h3 id="2-2-值的写法"><a href="#2-2-值的写法" class="headerlink" title="2.2. 值的写法"></a>2.2. 值的写法</h3><p>** 字面量：普通的值（数字，字符串，布尔）**</p><p>​    k: v：字面直接来写；</p><p>​        字符串默认不用加上单引号或者双引号；</p><p>​        “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p><p>​                name:   “zhangsan \n lisi”：输出；zhangsan 换行  lisi</p><p>​        ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>​                name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</p><h3 id="2-3-对象、Map（属性和值）（键值对）："><a href="#2-3-对象、Map（属性和值）（键值对）：" class="headerlink" title="2.3. 对象、Map（属性和值）（键值对）："></a>2.3. 对象、Map（属性和值）（键值对）：</h3><p>​    k: v：在下一行来写对象的属性和值的关系；注意缩进</p><p>​        对象还是 k: v 的方式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">        <span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">        <span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>行内写法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-数组（List、Set）："><a href="#2-4-数组（List、Set）：" class="headerlink" title="2.4. 数组（List、Set）："></a>2.4. 数组（List、Set）：</h3><p>用 - 值表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure><p>行内写法</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure><h2 id="3-配置文件值注入"><a href="#3-配置文件值注入" class="headerlink" title="3. 配置文件值注入"></a>3. 配置文件值注入</h2><p>配置文件:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">    lastName:</span> <span class="string">hello</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">    boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line"><span class="attr">    maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">    lists:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">lisi</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">zhaoliu</span></span><br><span class="line"><span class="attr">    dog:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string"> 小狗 </span></span><br><span class="line"><span class="attr">      age:</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>javaBean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的 < span class="doctag">@ConfigurationProperties</span> 功能；</span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>我们可以导入配置文件处理器，以后编写配置就有提示了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-properties-配置文件在-idea-中默认-utf-8-可能会乱码"><a href="#3-1-properties-配置文件在-idea-中默认-utf-8-可能会乱码" class="headerlink" title="3.1.properties 配置文件在 idea 中默认 utf-8 可能会乱码"></a>3.1.properties 配置文件在 idea 中默认 utf-8 可能会乱码</h3><p>调整:</p><p><img src="/images/spring-boot-configuration/20200302190132.png" alt="idea 配置乱码"></p><h3 id="3-2-Value-获取值和-ConfigurationProperties-获取值比较"><a href="#3-2-Value-获取值和-ConfigurationProperties-获取值比较" class="headerlink" title="3.2.@Value 获取值和 @ConfigurationProperties 获取值比较"></a>3.2.@Value 获取值和 @ConfigurationProperties 获取值比较</h3><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL (Spring 表达式)</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303 数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>配置文件 yml 还是 properties 他们都能获取到值；</p><p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用 @Value；</p><p>如果说，我们专门编写了一个 javaBean 来和配置文件进行映射，我们就直接使用 @ConfigurationProperties；</p><h3 id="3-3-配置文件注入值数据校验"><a href="#3-3-配置文件注入值数据校验" class="headerlink" title="3.3. 配置文件注入值数据校验"></a>3.3. 配置文件注入值数据校验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量 /$&#123;key&#125; 从环境变量、配置文件中获取值 /#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName 必须是邮箱格式 </span></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="comment">//@Value ("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value ("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value ("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><h3 id="3-4-PropertySource-amp-ImportResource-amp-Bean"><a href="#3-4-PropertySource-amp-ImportResource-amp-Bean" class="headerlink" title="3.4.@PropertySource&amp;@ImportResource&amp;@Bean"></a>3.4.@PropertySource&amp;@ImportResource&amp;@Bean</h3><p>@<strong>PropertySource</strong>：加载指定的配置文件；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将配置文件中配置的每一个属性的值，映射到这个组件中 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ConfigurationProperties</span>：告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定；</span></span><br><span class="line"><span class="comment"> *      prefix = "person"：配置文件中哪个下面的所有属性进行一一映射 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 只有这个组件是容器中的组件，才能容器提供的 < span class="doctag">@ConfigurationProperties</span> 功能；</span><br><span class="line"><span class="comment"> *  <span class="doctag">@ConfigurationProperties</span>(prefix = "person") 默认从全局配置文件中获取值；</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="comment">//@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *      &lt;property name="lastName" value="字面量 /$&#123;key&#125; 从环境变量、配置文件中获取值 /#&#123;SpEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;bean/&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//lastName 必须是邮箱格式 </span></span><br><span class="line">   <span class="comment">// @Email</span></span><br><span class="line">    <span class="comment">//@Value ("$&#123;person.last-name&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="comment">//@Value ("#&#123;11*2&#125;")</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//@Value ("true")</span></span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure><p>@<strong>ImportResource</strong>：导入 Spring 的配置文件，让配置文件里面的内容生效；</p><p>Spring Boot 里面没有 Spring 的配置文件，我们自己编写的配置文件，也不能自动识别；</p><p>想让 Spring 的配置文件生效，加载进来；@<strong>ImportResource</strong> 标注在一个配置类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line"> 导入 Spring 的配置文件让其生效 </span><br></pre></td></tr></table></figure><p>不来编写 Spring 的配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloService"</span> <span class="attr">class</span>=<span class="string">"com.atguigu.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot 推荐给容器中添加组件的方式；推荐使用全注解的方式</p><p>1、配置类 <strong>@Configuration</strong>——&gt;Spring 配置文件</p><p>2、使用 <strong>@Bean</strong> 给容器中添加组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来替代之前的 Spring 配置文件 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用 & lt;bean&gt;&lt;bean/&gt; 标签添加组件 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将方法的返回值添加到容器中；容器中这个组件默认的 id 就是方法名 </span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println (<span class="string">"配置类 @Bean 给容器中添加组件了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##4、配置文件占位符</p><p>*<em>1. 随机数 *</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.value&#125;、$&#123;random.<span class="keyword">int</span>&#125;、$&#123;random.<span class="keyword">long</span>&#125;</span><br><span class="line">$&#123;random.<span class="keyword">int</span>(<span class="number">10</span>)&#125;、$&#123;random.<span class="keyword">int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure><p>*<em>2. 占位符获取之前配置的值，如果没有可以是用：指定默认值 *</em></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.last-name</span>=<span class="string"> 张三 $&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">person.age</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">person.birth</span>=<span class="string">2017/12/15</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">14</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">$&#123;person.hello:hello&#125;_dog</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure><h2 id="4-Profile"><a href="#4-Profile" class="headerlink" title="4.Profile"></a>4.Profile</h2><p>Profile 是 spring 对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境。</p><h3 id="4-1-多-Profile-文件"><a href="#4-1-多-Profile-文件" class="headerlink" title="4.1. 多 Profile 文件"></a>4.1. 多 Profile 文件</h3><p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</p><p>默认使用 application.properties 的配置；</p><h3 id="4-2-yml-支持多文档块方式"><a href="#4-2-yml-支持多文档块方式" class="headerlink" title="4.2.yml 支持多文档块方式"></a>4.2.yml 支持多文档块方式</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">prod</span> <span class="comment"># 指定激活哪个环境 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8083</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8084</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span>  <span class="comment"># 指定属于哪个环境 </span></span><br></pre></td></tr></table></figure><h3 id="4-3-激活指定-profile"><a href="#4-3-激活指定-profile" class="headerlink" title="4.3. 激活指定 profile"></a>4.3. 激活指定 profile</h3><p>​    1、在配置文件中指定  spring.profiles.active=dev</p><p>​    2、命令行：</p><p>​        java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev；</p><p>​        可以直接在测试的时候，配置传入命令行参数</p><p>​    3、虚拟机参数；</p><p>​        -Dspring.profiles.active=dev</p><h2 id="5-配置文件加载位置"><a href="#5-配置文件加载位置" class="headerlink" title="5. 配置文件加载位置"></a>5. 配置文件加载位置</h2><p>springboot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring boot 的默认配置文件</p><p><img src="/images/spring-boot-configuration/20200304195848.png" alt></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#application.properties 文件内容 </span></span><br><span class="line"><span class="meta">server.post</span>=<span class="string">8081</span></span><br><span class="line"><span class="comment">#server.servlet.context-path=/boot #配置项目得访问路径 </span></span><br></pre></td></tr></table></figure><p>–file:./config/</p><p>–file:./</p><p>–classpath:/config/</p><p>–classpath:/</p><p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p><p>SpringBoot 会从这四个位置全部加载主配置文件；** 互补配置 **；</p><p>== 我们还可以通过 spring.config.location 来改变默认的配置文件位置 ==</p><p>** 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；**</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar  G:/application.properties</p><h2 id="6-外部配置加载顺序"><a href="#6-外部配置加载顺序" class="headerlink" title="6. 外部配置加载顺序"></a>6. 外部配置加载顺序</h2><p>*<em>SpringBoot 也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置 *</em></p><p>*<em>1. 命令行参数 *</em></p><p>所有的配置都可以在命令行上进行指定</p><p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087  –server.context-path=/abc</p><p>多个配置用空格分开； – 配置项 = 值</p><ol start="2"><li>来自 java:comp/env 的 JNDI 属性</li></ol><p>3.Java 系统属性（System.getProperties ()）</p><ol start="4"><li>操作系统环境变量</li></ol><p>5.RandomValuePropertySource 配置的 random.* 属性值</p><p>** 由 jar 包外向 jar 包内进行寻找；**</p><p>** 优先加载带 profile**</p><p>*<em>6.jar 包外部的 application-{profile}.properties 或 application.yml (带 spring.profile) 配置文件 *</em></p><p>*<em>7.jar 包内部的 application-{profile}.properties 或 application.yml (带 spring.profile) 配置文件 *</em></p><p>** 再来加载不带 profile**</p><p>*<em>8.jar 包外部的 application.properties 或 application.yml (不带 spring.profile) 配置文件 *</em></p><p>*<em>9.jar 包内部的 application.properties 或 application.yml (不带 spring.profile) 配置文件 *</em></p><p>10.@Configuration 注解类上的 @PropertySource</p><ol start="11"><li>通过 SpringApplication.setDefaultProperties 指定的默认属性</li></ol><p>所有支持的配置加载来源；</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">参考官方文档</a></p><p><img src="/images/spring-boot-configuration/20200305123720.png" alt="支持的配置"></p><h2 id="7-自动配置原理"><a href="#7-自动配置原理" class="headerlink" title="7. 自动配置原理"></a>7. 自动配置原理</h2><p>配置文件到底能写什么？怎么写？自动配置原理；</p><p><a href="https://docs.spring.io/spring-boot/docs/2.2.4.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">配置文件能配置的属性参照</a></p><h3 id="7-1-自动配置原理："><a href="#7-1-自动配置原理：" class="headerlink" title="7.1.** 自动配置原理：**"></a>7.1.** 自动配置原理：**</h3><p>1）、SpringBoot 启动的时候加载主配置类，开启了自动配置功能 <strong>@EnableAutoConfiguration</strong></p><p>2）、<strong>@EnableAutoConfiguration 作用：</strong></p><ul><li>利用 EnableAutoConfigurationImportSelector 给容器中导入一些组件；<ul><li>可以查看 selectImports () 方法的内容；</li><li>List<string> configurations = getCandidateConfigurations (annotationMetadata,      attributes); 获取候选的配置</string></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames ()</span><br><span class="line"><span class="comment">// 扫描所有 jar 包类路径下  META-INF/spring.factories</span></span><br><span class="line"><span class="comment">// 把扫描到的这些文件的内容包装成 properties 对象 </span></span><br><span class="line"><span class="comment">// 从 properties 中获取到 EnableAutoConfiguration.class 类（类名）对应的值，然后把他们添加在容器中 </span></span><br></pre></td></tr></table></figure><p>将 类路径下  META-INF/spring.factories 里面配置的所有 EnableAutoConfiguration 的值加入到了容器中；</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span></span><br></pre></td></tr></table></figure><p>每一个这样的  xxxAutoConfiguration 类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；</p><p>3）、每一个自动配置类进行自动配置功能；</p><p>4）、以 <strong>HttpEncodingAutoConfiguration（Http 编码自动配置）</strong> 为例解释自动配置原理；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>   <span class="comment">// 表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件 </span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HttpEncodingProperties.class)  <span class="comment">// 启动指定类的 ConfigurationProperties 功能；将配置文件中对应的值和 HttpEncodingProperties 绑定起来；并把 HttpEncodingProperties 加入到 ioc 容器中 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span> <span class="comment">//Spring 底层 @Conditional 注解（Spring 注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是 web 应用，如果是，当前配置类生效 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CharacterEncodingFilter.class)  <span class="comment">// 判断当前项目有没有这个类 CharacterEncodingFilter；SpringMVC 中进行乱码解决的过滤器；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.http.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)  <span class="comment">// 判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的 </span></span><br><span class="line"><span class="comment">// 即使我们配置文件中不配置 pring.http.encoding.enabled=true，也是默认生效的；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 他已经和 SpringBoot 的配置文件映射了 </span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 只有一个有参构造器的情况下，参数的值就会从容器中拿 </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">// 给容器中添加一个组件，这个组件的某些值需要从 properties 中获取 </span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span>(CharacterEncodingFilter.class) <span class="comment">// 判断容器没有这个组件？</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter ();</span><br><span class="line">        filter.setEncoding (<span class="keyword">this</span>.properties.getCharset ().name ());</span><br><span class="line">        filter.setForceRequestEncoding (<span class="keyword">this</span>.properties.shouldForce (Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding (<span class="keyword">this</span>.properties.shouldForce (Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据当前不同的条件判断，决定这个配置类是否生效？</p><p>一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的 properties 类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>5）、所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>)  <span class="comment">// 从配置文件中获取指定的值和 bean 的属性进行绑定 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Charset DEFAULT_CHARSET = Charset.forName (<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure><p>** 精髓：**</p><p>​    *<em>1）、SpringBoot 启动会加载大量的自动配置类 *</em></p><p>​    <strong>2）、我们看我们需要的功能有没有 SpringBoot 默认写好的自动配置类；</strong></p><p>​    <strong>3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）</strong></p><p>​    <strong>4）、给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性。我们就可以在配置文件中指定这些属性的值；</strong></p><p>xxxxAutoConfigurartion：自动配置类；</p><p>给容器中添加组件</p><p>xxxxProperties: 封装配置文件中相关属性；</p><h3 id="7-2-细节"><a href="#7-2-细节" class="headerlink" title="7.2. 细节"></a>7.2. 细节</h3><p><strong>@Conditional 派生注解（Spring 注解版原生的 @Conditional 作用）</strong></p><p>作用：必须是 @Conditional 指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；</p><table><thead><tr><th>@Conditional 扩展注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的 java 版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定 Bean；</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定 Bean；</td></tr><tr><td>@ConditionalOnExpression</td><td>满足 SpEL 表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的 Bean，或者这个 Bean 是首选 Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是 web 环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是 web 环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI 存在指定项</td></tr></tbody></table><p>** 自动配置类必须在一定的条件下才能生效；**</p><p>我们怎么知道哪些自动配置类生效；</p><p>** 我们可以通过启用  debug=true 属性；来让控制台打印自动配置报告 **，这样我们就可以很方便的知道哪些自动配置类生效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">=========================</span><br><span class="line">AUTO-CONFIGURATION REPORT</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Positive matches:（自动配置类启用的）</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">DispatcherServlet</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">      - @<span class="title">ConditionalOnWebApplication</span> <span class="params">(required)</span> found <span class="title">StandardServletEnvironment</span> <span class="params">(OnWebApplicationCondition)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">Negative matches:（没有启动，没有匹配成功的自动配置类）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">   AopAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' <span class="params">(OnClassCondition)</span></span></span><br></pre></td></tr></table></figure><h2 id="8-最后"><a href="#8-最后" class="headerlink" title="8. 最后"></a>8. 最后</h2><p>​    此 spring boot 部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-配置文件&quot;&gt;&lt;a href=&quot;#1-配置文件&quot; class=&quot;headerlink&quot; title=&quot;1. 配置文件&quot;&gt;&lt;/a&gt;1. 配置文件&lt;/h2&gt;&lt;p&gt;SpringBoot 使用一个全局的配置文件，配置文件名是固定的；&lt;/p&gt;
&lt;p&gt;・application.properties&lt;/p&gt;
&lt;p&gt;・application.yml&lt;/p&gt;
&lt;p&gt;配置文件的作用：修改 SpringBoot 自动配置的默认值；SpringBoot 在底层都给我们自动配置好；&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 入门</title>
    <link href="https://quietair.gitee.io/spring-boot-01/"/>
    <id>https://quietair.gitee.io/spring-boot-01/</id>
    <published>2020-02-29T12:24:00.000Z</published>
    <updated>2020-03-22T15:55:27.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Spring-Boot-简介"><a href="#1-Spring-Boot-简介" class="headerlink" title="1.Spring Boot 简介"></a>1.Spring Boot 简介</h2><ul><li><p>简化 Spring 应用开发的一个框架；</p></li><li><p>整个 Spring 技术栈的一个大整合；</p></li></ul><p>-J2EE 开发的一站式解决方案；</p><a id="more"></a><h2 id="2-微服务"><a href="#2-微服务" class="headerlink" title="2. 微服务"></a>2. 微服务</h2><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务；可以通过 HTTP 的方式进行互通；</p><p>单体应用：ALL IN ONE</p><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="noopener">详细参照微服务文档</a></p><h2 id="3-环境准备"><a href="#3-环境准备" class="headerlink" title="3. 环境准备"></a>3. 环境准备</h2><p>环境约束:</p><p>–jdk1.8：Spring Boot 推荐 jdk1.7 及以上；</p><p>–maven3.x：maven 3.3 以上版本；</p><p>–IntelliJIDEA：IntelliJ IDEA </p><p>–SpringBoot 1.5.9.RELEASE：1.5.9；</p><h3 id="3-1-MAVEN-设置"><a href="#3-1-MAVEN-设置" class="headerlink" title="3.1.MAVEN 设置"></a>3.1.MAVEN 设置</h3><p>给 maven 的 settings.xml 配置文件的 profiles 标签添加 (可以添加，也可以不用)；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-IDEA-设置"><a href="#3-2-IDEA-设置" class="headerlink" title="3.2.IDEA 设置"></a>3.2.IDEA 设置</h3><p>首先对 maven 进行整合；</p><p><img src="/images/spring-boot-01/20200229191224.png" alt="idea 设置"></p><p><img src="/images/spring-boot-01/20200229191357.png" alt="images/"></p><h2 id="4-Spring-Boot-HelloWorld"><a href="#4-Spring-Boot-HelloWorld" class="headerlink" title="4.Spring Boot HelloWorld"></a>4.Spring Boot HelloWorld</h2><p>实现一个简单的功能：</p><p>浏览器发送 hello 请求，服务器接受请求并处理，响应 Hello World 字符串；</p><h3 id="4-1-创建一个-maven-工程（jar）"><a href="#4-1-创建一个-maven-工程（jar）" class="headerlink" title="4.1. 创建一个 maven 工程（jar）"></a>4.1. 创建一个 maven 工程（jar）</h3><h3 id="4-2-导入-spring-boot-相关的依赖"><a href="#4-2-导入-spring-boot-相关的依赖" class="headerlink" title="4.2. 导入 spring boot 相关的依赖"></a>4.2. 导入 spring boot 相关的依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-3-编写一个主程序；启动-Spring-Boot-应用"><a href="#4-3-编写一个主程序；启动-Spring-Boot-应用" class="headerlink" title="4.3. 编写一个主程序；启动 Spring Boot 应用"></a>4.3. 编写一个主程序；启动 Spring Boot 应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个 Spring Boot 应用 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把 Spring 应用启动起来 </span></span><br><span class="line">        SpringApplication.run (HelloWorldMainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-编写相关的-Controller、Service"><a href="#4-4-编写相关的-Controller、Service" class="headerlink" title="4.4. 编写相关的 Controller、Service"></a>4.4. 编写相关的 Controller、Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-运行主程序测试"><a href="#4-5-运行主程序测试" class="headerlink" title="4.5. 运行主程序测试"></a>4.5. 运行主程序测试</h3><h3 id="4-6-简化部署"><a href="#4-6-简化部署" class="headerlink" title="4.6. 简化部署"></a>4.6. 简化部署</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个插件，可以将应用打包成一个可执行的 jar 包；--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将这个应用打成 jar 包，再 window 下或者 Linux 下直接使用 java -jar 的命令进行执行；</p><h2 id="5-Hello-World-探究"><a href="#5-Hello-World-探究" class="headerlink" title="5.Hello World 探究"></a>5.Hello World 探究</h2><h3 id="5-1-POM-文件"><a href="#5-1-POM-文件" class="headerlink" title="5.1.POM 文件"></a>5.1.POM 文件</h3><h4 id="5-1-1-父项目"><a href="#5-1-1-父项目" class="headerlink" title="5.1.1 父项目"></a>5.1.1 父项目</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> 上面的父项目是 </span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> 它来真正管理 Spring Boot 应用里面的所有依赖版本；</span><br></pre></td></tr></table></figure><p>Spring Boot 的版本仲裁中心；</p><p>以后我们导入依赖默认是不需要写版本；（没有在 dependencies 里面管理的依赖自然需要声明版本号）</p><h4 id="5-1-2-启动器"><a href="#5-1-2-启动器" class="headerlink" title="5.1.2 启动器"></a>5.1.2 启动器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring-boot-starter-<strong>web</strong>：</p><p>​    spring-boot-starter：spring-boot 场景启动器；帮我们导入了 web 模块正常运行所依赖的组件；</p><p>总结：Spring Boot 将所有的功能场景都抽取出来，做成一个个的 starters（启动器），只需要在项目里面引入这些 starter 相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p><h3 id="5-2-主程序类，主入口类"><a href="#5-2-主程序类，主入口类" class="headerlink" title="5.2. 主程序类，主入口类"></a>5.2. 主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@SpringBootApplication</span> 来标注一个主程序类，说明这是一个 Spring Boot 应用 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Spring 应用启动起来 </span></span><br><span class="line">        SpringApplication.run (HelloWorldMainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootApplication</strong>:    Spring Boot 应用标注在某个类上说明这个类是 SpringBoot 的主配置类，SpringBoot 就应该运行这个类的 main 方法来启动 SpringBoot 应用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123;</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">      <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p>@<strong>SpringBootConfiguration</strong>:Spring Boot 的配置类；</p><p>​        标注在某个类上，表示这是一个 Spring Boot 的配置类；</p><p>​        @<strong>Configuration</strong>: 配置类上来标注这个注解；</p><p>​            配置类 —–  配置文件；配置类也是容器中的一个组件；<strong>@Component</strong></p><p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p><p>​        以前我们需要配置的东西，Spring Boot 帮我们自动配置；@<strong>EnableAutoConfiguration</strong> 告诉 SpringBoot 开启自动配置功能；这样自动配置才能生效；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure><p>​    @<strong>AutoConfigurationPackage</strong>：自动配置包</p><p>​        @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p><p>​        Spring 的底层注解 <strong>@Import</strong>，给容器中导入一个组件；导入的组件由 AutoConfigurationPackages.Registrar.class；</p><p>将主配置类（@SpringBootApplication 标注的类）的所在包及下面所有子包里面的所有组件扫描到 Spring 容器；</p><p>​    @<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p><p>​        给容器中导入组件？</p><p>​        <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p><p>​        将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p><p>​        会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；        <img src="/images/spring-boot-01/20200229203810.png" alt="自动配置类"></p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p><p>​        SpringFactoriesLoader.loadFactoryNames (EnableAutoConfiguration.class,classLoader)；</p><p>总结：Spring Boot 在启动的时候从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；== 以前我们需要自己配置的东西，自动配置类都帮我们；</p><p>J2EE 的整体整合解决方案和自动配置都在 spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p><h2 id="6-IDEA：使用-Spring-Initializer-快速创建-spring-boot-项目"><a href="#6-IDEA：使用-Spring-Initializer-快速创建-spring-boot-项目" class="headerlink" title="6.IDEA：使用 Spring Initializer 快速创建 spring boot 项目"></a>6.IDEA：使用 Spring Initializer 快速创建 spring boot 项目</h2><p>IDE 都支持使用 Spring 的项目创建向导快速创建一个 Spring Boot 项目；</p><p>选择我们需要的模块；向导会联网创建 Spring Boot 项目；</p><p>默认生成的 Spring Boot 项目；</p><ul><li>主程序已经生成好了，我们只需要我们自己的逻辑</li><li>resources 文件夹中目录结构<ul><li>static：保存所有的静态资源； js css  images；</li><li>templates：保存所有的模板页面；（Spring Boot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面）；可以使用模板引擎（freemarker、thymeleaf）；</li><li>application.properties：Spring Boot 应用的配置文件；可以修改一些默认设置；</li></ul></li></ul><h2 id="7-最后"><a href="#7-最后" class="headerlink" title="7. 最后"></a>7. 最后</h2><p>​    此 spring boot 部分，来自尚硅谷教学视频，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Spring-Boot-简介&quot;&gt;&lt;a href=&quot;#1-Spring-Boot-简介&quot; class=&quot;headerlink&quot; title=&quot;1.Spring Boot 简介&quot;&gt;&lt;/a&gt;1.Spring Boot 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简化 Spring 应用开发的一个框架；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;整个 Spring 技术栈的一个大整合；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;-J2EE 开发的一站式解决方案；&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://quietair.gitee.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java 核心 (二) 之集合</title>
    <link href="https://quietair.gitee.io/Java_heart_list/"/>
    <id>https://quietair.gitee.io/Java_heart_list/</id>
    <published>2019-11-09T06:32:07.000Z</published>
    <updated>2020-03-23T14:41:18.908Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-接口继承关系和实现"><a href="#1-接口继承关系和实现" class="headerlink" title="1. 接口继承关系和实现"></a>1. 接口继承关系和实现</h2><p>集合类存放于 Java.util 包中，主要有 3 种：set (集）、list (列表包含 Queue）和 map (映射)。</p><ol><li><p>Collection：Collection 是集合 List、Set、Queue 的最基本的接口。</p></li><li><p>Iterator：迭代器，可以通过迭代器遍历集合中的数据 </p></li><li><p>Map：是映射表的基础接口 </p></li></ol><a id="more"></a><p><img src="/images/Java_heart_list/clip_image003.gif" alt> </p><p><img src="/images/Java_heart_list/clip_image005.gif" alt="img"> </p><h2 id="2-List"><a href="#2-List" class="headerlink" title="2.List"></a>2.List</h2><p>Java 的 List 是非常常用的数据类型。<strong>List 是有序的 Collection</strong>。Java List 一共三个实现类：分别是 ArrayList、Vector 和 LinkedList。 </p><p><img src="/images/Java_heart_list/clip_image007.jpg" alt="img"> </p><h3 id="2-1-ArrayList（数组）"><a href="#2-1-ArrayList（数组）" class="headerlink" title="2.1.  ArrayList（数组）"></a>2.1.  ArrayList（数组）</h3><p>ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，** 当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除 **。 </p><h3 id="2-2-Vector（数组实现、线程同步）"><a href="#2-2-Vector（数组实现、线程同步）" class="headerlink" title="2.2.  Vector（数组实现、线程同步）"></a>2.2.  Vector（数组实现、线程同步）</h3><p>Vector 与 ArrayList 一样，也是通过数组实现的，不同的是 ** 它支持线程的同步，即某一时刻只有一个线程能够写 Vector**，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 </p><h3 id="2-3-LinkList（链表）"><a href="#2-3-LinkList（链表）" class="headerlink" title="2.3.  LinkList（链表）"></a>2.3.  LinkList（链表）</h3><p>*<em>LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除 *</em>，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 </p><h2 id="3-Set"><a href="#3-Set" class="headerlink" title="3.Set"></a>3.Set</h2><p>Set 注重独一无二的性质，该体系集合用于存储无序 (存入和取出的顺序不一定相同) 元素，** 值不能重复 <strong>。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，</strong> 如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法 **。 </p><p><img src="/images/Java_heart_list/clip_image009.gif" alt="img"> </p><h3 id="3-1-HashSet（Hash-表）"><a href="#3-1-HashSet（Hash-表）" class="headerlink" title="3.1.HashSet（Hash 表）"></a>3.1.HashSet（Hash 表）</h3><p>哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的 hashcode 方法来获取的，<strong>HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。</strong> </p><p>哈希值相同 equals 为 false 的元素是怎么存储呢，就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。 </p><p><img src="/images/Java_heart_list/clip_image011.gif" alt="img"> </p><p>HashSet 通过 hashCode 值来确定元素在内存中的位置。** 一个 hashCode 位置上可以存放多个元素 **。 </p><h3 id="3-2-TreeSet（二叉树）"><a href="#3-2-TreeSet（二叉树）" class="headerlink" title="3.2.TreeSet（二叉树）"></a>3.2.TreeSet（二叉树）</h3><ol><li><p>TreeSet () 是使用二叉树的原理对新 add () 的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 </p></li><li><p>Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，** 自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo () 函数 **，才可以正常使用。 </p></li><li><p>在覆写 compare () 函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序 </p></li><li><p>比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。</p></li></ol><h3 id="3-3-LinkHashSet（HashSet-LinkedHashMap）"><a href="#3-3-LinkHashSet（HashSet-LinkedHashMap）" class="headerlink" title="3.3.LinkHashSet（HashSet+LinkedHashMap）"></a>3.3.LinkHashSet（HashSet+LinkedHashMap）</h3><p>对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。 LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 </p><h2 id="4-Map"><a href="#4-Map" class="headerlink" title="4.Map"></a>4.Map</h2><p><img src="/images/Java_heart_list/clip_image013.gif" alt="img"> </p><h3 id="4-1-HashMap（数组-链表-红黑树）"><a href="#4-1-HashMap（数组-链表-红黑树）" class="headerlink" title="4.1. HashMap（数组 + 链表 + 红黑树）"></a>4.1. HashMap（数组 <strong>+</strong> 链表 <strong>+</strong> 红黑树）</h3><p>HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍 HashMap 的结构。</p><h4 id="4-1-1-JAVA7-实现"><a href="#4-1-1-JAVA7-实现" class="headerlink" title="4.1.1.   JAVA7 实现"></a>4.1.1.   JAVA7 实现</h4><p><img src="/images/Java_heart_list/clip_image015.gif" alt="img"> </p><p>大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：*<em>key, value, hash 值和用于单向链表 *</em> 的 next。 </p><ol><li><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 </p></li><li><p>loadFactor：负载因子，默认为 0.75。</p></li><li><p>threshold：扩容的阈值，等于 capacity * loadFactor </p></li></ol><h4 id="4-1-2-JAVA8-实现"><a href="#4-1-2-JAVA8-实现" class="headerlink" title="4.1.2.   JAVA8 实现"></a>4.1.2.   JAVA8 实现</h4><p>Java8 对 HashMap 进行了一些修改，** 最大的不同就是利用了红黑树，所以其由 数组 + 链表 + 红黑树组成 **。 </p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，** 需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O (n)<strong>。为了降低这部分的开销，在 Java8 中，</strong> 当链表中的元素超过了 8 个以后，会将链表转换为红黑树 **，在这些位置进行查找的时候可以降低时间复杂度为 O (logN)。 </p><p><img src="/images/Java_heart_list/clip_image017.gif" alt="img"> </p><h3 id="4-2-ConcurrentHashMap"><a href="#4-2-ConcurrentHashMap" class="headerlink" title="4.2. ConcurrentHashMap"></a>4.2. ConcurrentHashMap</h3><h4 id="4-2-1-Segment-段"><a href="#4-2-1-Segment-段" class="headerlink" title="4.2.1.   Segment 段"></a>4.2.1.   Segment 段</h4><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表” 部分 “或” 一段 “的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了 “槽” 来代表一个 </p><p>segment。 </p><h4 id="4-2-2-线程安全-Segment-继承-ReentrantLock-加锁）"><a href="#4-2-2-线程安全-Segment-继承-ReentrantLock-加锁）" class="headerlink" title="4.2.2. 线程安全 Segment 继承 ReentrantLock 加锁）"></a>4.2.2. 线程安全 Segment 继承 ReentrantLock 加锁）</h4><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 </p><p>ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="/images/Java_heart_list/clip_image019.gif" alt="img"> </p><h4 id="4-2-3-并行度（默认-16）"><a href="#4-2-3-并行度（默认-16）" class="headerlink" title="4.2.3. 并行度（默认 16）"></a>4.2.3. 并行度（默认 16）</h4><p>concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 <strong>ConcurrentHashMap 有 16 个 Segments</strong>，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 </p><h4 id="4-2-4-Java8-实现（引入了红黑树）"><a href="#4-2-4-Java8-实现（引入了红黑树）" class="headerlink" title="4.2.4. Java8 实现（引入了红黑树）"></a>4.2.4. Java8 实现（引入了红黑树）</h4><p>Java8 对 ConcurrentHashMap 进行了比较大的改动，Java8 也引入了红黑树。 </p><p><img src="/images/Java_heart_list/clip_image021.gif" alt="img"> </p><h3 id="4-3-HashTable（线程安全）"><a href="#4-3-HashTable（线程安全）" class="headerlink" title="4.3. HashTable（线程安全）"></a>4.3. HashTable（线程安全）</h3><p>Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。 </p><h3 id="4-4-TreeMap（可排序）"><a href="#4-4-TreeMap（可排序）" class="headerlink" title="4.4. TreeMap（可排序）"></a>4.4. TreeMap（可排序）</h3><p>TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。 如果使用排序的映射，建议使用 TreeMap。 </p><p>在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。 </p><p>参考：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html</a> <a href="https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html" target="_blank" rel="noopener"> </a></p><p><strong>4.5. LinkHashMap</strong>（记录插入顺序） </p><p>LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 </p><p>参考 1 <a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">：</a> <a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">http://www.importnew.com/28263.html</a> <a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener"> </a></p><p>参考 2 <a href="http://www.importnew.com/20386.html#comment-648123" target="_blank" rel="noopener">：</a> <a href="http://www.importnew.com/20386.html#comment-648123" target="_blank" rel="noopener">http://www.importnew.com/20386.html#comment-648123</a> <a href="http://www.importnew.com/20386.html#comment-648123" target="_blank" rel="noopener"> </a></p><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>java 核心这部分，偶然所得的一份 pdf 文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-接口继承关系和实现&quot;&gt;&lt;a href=&quot;#1-接口继承关系和实现&quot; class=&quot;headerlink&quot; title=&quot;1. 接口继承关系和实现&quot;&gt;&lt;/a&gt;1. 接口继承关系和实现&lt;/h2&gt;&lt;p&gt;集合类存放于 Java.util 包中，主要有 3 种：set (集）、list (列表包含 Queue）和 map (映射)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Collection：Collection 是集合 List、Set、Queue 的最基本的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Iterator：迭代器，可以通过迭代器遍历集合中的数据 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Map：是映射表的基础接口 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java 核心 (一) 之 JVM</title>
    <link href="https://quietair.gitee.io/Java_heart_JVM/"/>
    <id>https://quietair.gitee.io/Java_heart_JVM/</id>
    <published>2019-10-24T07:24:00.000Z</published>
    <updated>2020-03-23T14:23:47.097Z</updated>
    
    <content type="html"><![CDATA[<p>(1) 基本概念：</p><p>​    JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。 </p><a id="more"></a><p><img src="/images/Java_heart_JVM/java_1_jvm_01.png" alt></p><p><strong>(2) 运行过程：</strong> </p><p>​    我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件， 而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。也就是如下：<br>​     ① Java 源文件 —-&gt; 编译器 —-&gt; 字节码文件<br>​     ② 字节码文件 —-&gt;JVM—-&gt; 机器码<br>​     每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够 跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会 存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不 能共享。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_02.png" alt></p><h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h2><p>​    这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。 <u>Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系 </u>。** 当线程本地存储、缓 冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可 用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run () 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。** </p><p>Hotspot JVM 后台运行的系统线程主要有下面几个：</p><table><thead><tr><th align="center">名称</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">虚拟机线程 （VM thread）</td><td align="center">这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当 堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。</td></tr><tr><td align="center">周期性任务线程</td><td align="center">这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</td></tr><tr><td align="center">GC 线程</td><td align="center">这些线程支持 JVM 中不同的垃圾回收活动。</td></tr><tr><td align="center">编译器线程</td><td align="center">这些线程在运行时将字节码动态编译成本地平台相关的机器码。</td></tr><tr><td align="center">信号分发线程</td><td align="center">这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。</td></tr></tbody></table><h2 id="2-JVM-内存区域"><a href="#2-JVM-内存区域" class="headerlink" title="2.JVM 内存区域"></a>2.JVM 内存区域</h2><p><img src="/images/Java_heart_JVM/java_1_jvm_03.png" alt></p><p>​    JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区 域【JAVA 堆、方法区】、直接内存。<br>​    ** 线程私有数据区域生命周期与线程相同，依赖用户线程的启动 / 结束 而 创建 / 销毁 (在 Hotspot VM 内，** 每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存 / 否跟随本地线程的 生 / 死对应)。 </p><p>​    ** 线程共享区域随虚拟机的启动 / 关闭而创建 / 销毁。**<br>​    直接内存并不是 JVM 运行时数据区的一部分，但也会被频繁的使用：在 JDK 1.4 引入的 NIO 提 供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作 (详见: Java I/O 扩展), 这样就避免了在 Java 堆和 Native 堆中来回复制数据，因此在一些场景中可以显著提高性能。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_04.png" alt></p><h3 id="2-1-程序计数器-线程私有"><a href="#2-1-程序计数器-线程私有" class="headerlink" title="2.1. 程序计数器 (线程私有)"></a>2.1. 程序计数器 (线程私有)</h3><p>​    一块较小的内存空间，** 是当前线程所执行的字节码的行号指示器 **，每条线程都要有一个独立的 程序计数器，这类内存也称为 “线程私有” 的内存。<br>​    正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如 果还是 Native 方法，则为空。<br>​    这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。 </p><h3 id="2-2-虚拟机栈-线程私有"><a href="#2-2-虚拟机栈-线程私有" class="headerlink" title="2.2. 虚拟机栈 (线程私有)"></a>2.2. 虚拟机栈 (线程私有)</h3><p>​    是描述 java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<u> 每一个方法从调用直至执行完成 的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</u><br>​    栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接 (Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。<u> 栈帧随着方法调用而创建，随着方法结束而销毁 </u>—— 无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异 常）都算作方法结束。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_05.png" alt></p><h3 id="2-3-本地方法区-线程私有"><a href="#2-3-本地方法区-线程私有" class="headerlink" title="2.3. 本地方法区 (线程私有)"></a>2.3. 本地方法区 (线程私有)</h3><p>​    本地方法区和 *<em>Java Stack 作用类似 *</em>, 区别是虚拟机栈为执行 Java 方法服务，而 ** 本地方法栈则为 Native 方法服务 **, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用，那么该栈将会是一个 C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。 </p><h3 id="2-4-堆（Heap-线程共享）运行时数据区"><a href="#2-4-堆（Heap-线程共享）运行时数据区" class="headerlink" title="2.4. 堆（Heap - 线程共享）运行时数据区"></a>2.4. 堆（Heap - 线程共享）运行时数据区</h3><p>​    是被线程共享的一块内存区域，** 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行 垃圾收集的最重要的内存区域 **。由于现代 VM 采用分代收集算法，因此 Java 堆从 GC 的角度还可以 细分为：新生代 ( Eden 区 、 From Survivor 区 和 To Survivor 区 ) 和老年代。 </p><h3 id="2-5-方法区-永久代（线程共享）"><a href="#2-5-方法区-永久代（线程共享）" class="headerlink" title="2.5. 方法区 / 永久代（线程共享）"></a>2.5. 方法区 / 永久代（线程共享）</h3><p>​    即我们常说的 ** 永久代 (Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静 态变量、即时编译器编译后的代码 ** 等数据. HotSpot VM 把 GC 分代收集扩展至方法区，即使用 Java 堆的永久代来实现方法区，这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存，而不必为方法区开发专门的内存管理器 (永久带的内存回收的主要目标是针对常量池的回收和类型 的卸载，因此收益一般很小)。 </p><p>​    <u> 运行时常量池 </u>（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版 本、字段、方法、接口等描述等信息外，还有一项信息是常量池 Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加 载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量 池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会 被虚拟机认可、装载和执行。 </p><h2 id="3-JVM-运行时内存"><a href="#3-JVM-运行时内存" class="headerlink" title="3. JVM 运行时内存"></a>3. JVM 运行时内存</h2><p>​    Java 堆从 GC 的角度还可以细分为: <u> 新生代 </u>( Eden 区 、 From Survivor 区 和 To Survivor 区 ) 和 &lt; u &gt; 老年代 。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_06.png" alt></p><h3 id="3-1-新生代"><a href="#3-1-新生代" class="headerlink" title="3.1. 新生代"></a>3.1. 新生代</h3><p>​    是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。</p><h4 id="3-1-1-Eden-区"><a href="#3-1-1-Eden-区" class="headerlink" title="3.1.1. Eden 区"></a>3.1.1. Eden 区</h4><p>​    *<em>Java 新对象的出生地 *</em>（如果新创建的对象占用内存很大，则直接分配到老 年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行 一次垃圾回收。</p><h4 id="3-1-2-ServivorFrom"><a href="#3-1-2-ServivorFrom" class="headerlink" title="3.1.2. ServivorFrom"></a>3.1.2. ServivorFrom</h4><p>​    上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 </p><h4 id="3-1-3-ServivorTo"><a href="#3-1-3-ServivorTo" class="headerlink" title="3.1.3. ServivorTo"></a>3.1.3. ServivorTo</h4><p>​    保留了一次 MinorGC 过程中的幸存者。 </p><h4 id="3-1-4-MinorGC-的过程（复制-gt-清空-gt-互换）"><a href="#3-1-4-MinorGC-的过程（复制-gt-清空-gt-互换）" class="headerlink" title="3.1.4.  MinorGC 的过程（复制 -&gt; 清空 -&gt; 互换）"></a>3.1.4.  MinorGC 的过程（复制 -&gt; 清空 -&gt; 互换）</h4><p>​    MinorGC 采用 ** 复制算法 **。 </p><p><strong>1 ： eden 、 servicorFrom 复制到 ServicorTo ，年龄 + 1</strong></p><p>​    首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年 龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄 + 1（如果 ServicorTo 不 够位置了就放到老年区）； </p><p><strong>2 ： 清空 eden 、 servicorFrom</strong> </p><p>​    然后，清空 Eden 和 ServicorFrom 中的对象； </p><p>*<em>3 ： ServicorTo 和 ServicorFrom 互换 *</em></p><p>​    最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom 区。 </p><h3 id="3-2-老年代"><a href="#3-2-老年代" class="headerlink" title="3.2. 老年代"></a>3.2. 老年代</h3><p>​    主要存放应用程序中生命周期长的内存对象。<br>​    老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行 了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足 够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。<br>​    MajorGC 采用 ** 标记清除算法 **：首先扫描一次所有老年代，标记出存活的对象，然后回收没 有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减 少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的 时候，就会抛出 OOM（Out of Memory）异常。 </p><h3 id="3-3-永久代"><a href="#3-3-永久代" class="headerlink" title="3.3. 永久代"></a>3.3. 永久代</h3><p>​    指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息，Class 在被加载的时候被 放入永久区域，它和和存放实例的区域不同，*<em>GC 不会在主程序运行期对永久区域进行清理 *</em>。所以这 也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。 </p><h4 id="3-3-1-JAVA8-与元数据"><a href="#3-3-1-JAVA8-与元数据" class="headerlink" title="3.3.1. JAVA8 与元数据"></a>3.3.1. JAVA8 与元数据</h4><p>在 Java8 中，<u> 永久代已经被移除，被一个称为 “元数据区”（元空间）的区域所取代 </u>。元空间 的本质和永久代类似，元空间与永久代之间最大的区别在于：** 元空间并不在虚拟机中，而是使用 本地内存 <strong>。因此，默认情况下，元空间的大小仅受本地内存限制。</strong> 类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中 **，这样可以加载多少类的元数据就不再由 MaxPermSize 控制，而由系统的实际可用空间来控制。 </p><h2 id="4-垃圾回收与算法"><a href="#4-垃圾回收与算法" class="headerlink" title="4. 垃圾回收与算法"></a>4. 垃圾回收与算法</h2><p><img src="/images/Java_heart_JVM/java_1_jvm_07.png" alt></p><h3 id="4-1-如何确定垃圾"><a href="#4-1-如何确定垃圾" class="headerlink" title="4.1. 如何确定垃圾"></a>4.1. 如何确定垃圾</h3><h4 id="4-1-1-引用计数法"><a href="#4-1-1-引用计数法" class="headerlink" title="4.1.1. 引用计数法"></a>4.1.1. 引用计数法</h4><p>​    在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单 的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个 ** 对象如果没有任何与之关 联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。** </p><h4 id="4-1-2-可达性分析"><a href="#4-1-2-可达性分析" class="headerlink" title="4.1.2. 可达性分析"></a>4.1.2. 可达性分析</h4><p>​    为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的 “GC roots” 对象作为起点搜索。如果 ** 在 “GC roots” 和一个对象之间没有可达路径，则称该对象是不可达的。**</p><p>​    要注意的是，** 不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程 **。两次标记后仍然是可回收对象，则将面临回收。 </p><h3 id="4-2-标记清除算法（Mark-Sweep）"><a href="#4-2-标记清除算法（Mark-Sweep）" class="headerlink" title="4.2. 标记清除算法（Mark-Sweep）"></a>4.2. 标记清除算法（Mark-Sweep）</h3><p>​    最基础的垃圾回收算法，分为 ** 两个阶段，标注和清除 **。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间。如图:</p><p><img src="/images/Java_heart_JVM/java_1_jvm_08.png" alt></p><p>​    从图中我们就可以发现，该算法 ** 最大的问题是内存碎片化严重 **，后续可能发生大对象不能找到可 利用空间的问题。 </p><h3 id="4-3-复制算法（copying）"><a href="#4-3-复制算法（copying）" class="headerlink" title="4.3. 复制算法（copying）"></a>4.3. 复制算法（copying）</h3><p>​    为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小 的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用 的内存清掉，如图： </p><p><img src="/images/Java_heart_JVM/java_1_jvm_09.png" alt></p><p>​    这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原 本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。 </p><h3 id="4-4-标记整理算法-Mark-Compact"><a href="#4-4-标记整理算法-Mark-Compact" class="headerlink" title="4.4. 标记整理算法 (Mark-Compact)"></a>4.4. 标记整理算法 (Mark-Compact)</h3><p>​    结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清 理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图： </p><p><img src="/images/Java_heart_JVM/java_1_jvm_10.png" alt></p><h3 id="4-5-分代收集算法"><a href="#4-5-分代收集算法" class="headerlink" title="4.5. 分代收集算法"></a>4.5. 分代收集算法</h3><p>​    分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存 划分为不同的域，一般情况下将 GC 堆划分为老生代 (Tenured/Old Generation) 和新生代 (Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃 圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。 </p><h4 id="4-5-1-新生代与复制算法"><a href="#4-5-1-新生代与复制算法" class="headerlink" title="4.5.1. 新生代与复制算法"></a>4.5.1. 新生代与复制算法</h4><p>​    目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要 回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代 划分为一块较大的 Eden 空间和两个较小的 Survivor 空间 (From Space, To Space)，每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另 一块 Survivor 空间中。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_11.1.png" alt></p><h4 id="4-5-2-老年代与标记复制算法"><a href="#4-5-2-老年代与标记复制算法" class="headerlink" title="4.5.2. 老年代与标记复制算法"></a>4.5.2. 老年代与标记复制算法</h4><p>​    而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。 </p><ol><li>JAVA 虚拟机提到过的处于 ** 方法区的永生代 (Permanet Generation)，它用来存储 class 类， 常量，方法描述 ** 等。对永生代的回收主要包括废弃常量和无用的类。 </li><li>对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space (Survivor 目 前存放对象的那一块)，少数情况会直接分配到老生代。 </li><li>当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。 </li><li>如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。 </li><li>在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。 </li><li>当对象在 Survivor 区躲过一次 GC 后，其年龄就会 + 1。** 默认情况下年龄到达 15 的对象会被 移到老生代中。** </li></ol><h2 id="5-JAVA-四中引用类型"><a href="#5-JAVA-四中引用类型" class="headerlink" title="5.JAVA 四中引用类型"></a>5.JAVA 四中引用类型</h2><h3 id="5-1-强引用"><a href="#5-1-强引用" class="headerlink" title="5.1. 强引用"></a>5.1. 强引用</h3><p>​    在 Java 中最常见的就是强引用，** 把一个对象赋给一个引用变量，这个引用变量就是一个强引 用。当一个对象被强引用变量引用时 **，它处于可达状态，它是不可能被垃圾回收机制回收的，即 使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之 一。 </p><h3 id="5-2-软引用"><a href="#5-2-软引用" class="headerlink" title="5.2. 软引用"></a>5.2. 软引用</h3><p>​    ** 软引用需要用 SoftReference 类来实现 **，对于只有软引用的对象来说，当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。 </p><h3 id="5-3-弱引用"><a href="#5-3-弱引用" class="headerlink" title="5.3. 弱引用"></a>5.3. 弱引用</h3><p>​    弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。 </p><h3 id="5-4-虚引用"><a href="#5-4-虚引用" class="headerlink" title="5.4. 虚引用"></a>5.4. 虚引用</h3><p>​    虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。** 虚引用的主要作用是跟踪对象被垃圾回收的状态 **。</p><h2 id="6-GC-分代收集算法-VS-分区收集算法"><a href="#6-GC-分代收集算法-VS-分区收集算法" class="headerlink" title="6.GC 分代收集算法  VS 分区收集算法"></a>6.GC 分代收集算法  VS 分区收集算法</h2><h3 id="6-1-分代收集算法"><a href="#6-1-分代收集算法" class="headerlink" title="6.1. 分代收集算法"></a>6.1. 分代收集算法</h3><p>​    当前主流 VM 垃圾收集都采用” 分代收集”(Generational Collection) 算法，这种算法会根据 对象存活周期的不同将内存划分为几块，如 JVM 中的 新生代、老年代、永久代，这样就可以根据 各年代特点分别采用最适当的 GC 算法 </p><h4 id="6-1-1-在新生代-复制算法"><a href="#6-1-1-在新生代-复制算法" class="headerlink" title="6.1.1. 在新生代 - 复制算法"></a>6.1.1. 在新生代 - 复制算法</h4><p>​    每次垃圾收集都能发现大批对象已死，只有少量存活。因此选用复制算法，只需要付出少量 存活对象的复制成本就可以完成收集. </p><h4 id="6-1-2-在老年代-标记整理算法"><a href="#6-1-2-在老年代-标记整理算法" class="headerlink" title="6.1.2. 在老年代 - 标记整理算法"></a>6.1.2. 在老年代 - 标记整理算法</h4><p>​    因为对象存活率高、没有额外空间对它进行分配担保，就必须采用 <strong>“标记 — 清理” 或 “标 记 — 整理”</strong> 算法来进行回收，不必进行内存复制，且直接腾出空闲内存. </p><h3 id="6-2-分区收集算法"><a href="#6-2-分区收集算法" class="headerlink" title="6.2. 分区收集算法"></a>6.2. 分区收集算法</h3><p>​    分区算法则将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。这样做的 好处是可以控制一次回收多少个小区间，根据目标停顿时间，每次合理地回收若干个小区间 (而不是 整个堆), 从而减少一次 GC 所产生的停顿。 </p><h2 id="7-GC-垃圾收集器"><a href="#7-GC-垃圾收集器" class="headerlink" title="7. GC 垃圾收集器"></a>7. GC 垃圾收集器</h2><p>​    Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记 - 清除垃圾回收算法； 年老代主要使用标记 - 整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不 同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下：</p><p> <img src="/images/Java_heart_JVM/java_1_jvm_11.png" alt></p><h3 id="7-1-Serial-垃圾收集器（单线程、复制算法）"><a href="#7-1-Serial-垃圾收集器（单线程、复制算法）" class="headerlink" title="7.1.  Serial 垃圾收集器（单线程、复制算法）"></a>7.1.  Serial 垃圾收集器（单线程、复制算法）</h3><p>​    *<em>Serial（英文连续）是最基本垃圾收集器，使用复制算法 *</em>，曾经是 JDK1.3.1 之前新生代唯一的垃圾 收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工 作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。 Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限 定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial 垃圾收集器依然是 *<em>java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器 *</em>。 </p><h3 id="7-2-ParNew-垃圾收集器（Serial-多线程）"><a href="#7-2-ParNew-垃圾收集器（Serial-多线程）" class="headerlink" title="7.2.  ParNew 垃圾收集器（Serial + 多线程）"></a>7.2.  ParNew 垃圾收集器（Serial + 多线程）</h3><p>​    ParNew 垃圾收集器其实是 *<em>Serial 收集器的多线程版本 *</em>，也使用复制算法，除了使用多线程进行垃 圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也 要暂停所有其他的工作线程。 </p><p>​    ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过 - XX:ParallelGCThreads 参数来限 制垃圾收集器的线程数。【Parallel：平行的】 ParNew 虽然是除了多线程外和 Serial 收集器几乎完全一样，但是 ParNew 垃圾收集器是 ** 很多 java 虚拟机运行在 Server 模式下新生代的默认垃圾收集器 **。 </p><h3 id="7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）"><a href="#7-3-Parallel-Scavenge-收集器（多线程复制算法、高效）" class="headerlink" title="7.3. Parallel Scavenge 收集器（多线程复制算法、高效）"></a>7.3. Parallel Scavenge 收集器（多线程复制算法、高效）</h3><p>​    Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃 圾收集器，它 ** 重点关注的是程序达到一个可控制的吞吐量 **（Thoughput，CPU 用于运行用户代码 的时间 / CPU 总消耗时间，即吞吐量 = 运行用户代码时间 /(运行用户代码时间 + 垃圾收集时间)）， 高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而 不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个 重要区别。 </p><h3 id="7-4-Serial-Old-收集器（单线程标记整理算法-）"><a href="#7-4-Serial-Old-收集器（单线程标记整理算法-）" class="headerlink" title="7.4. Serial Old 收集器（单线程标记整理算法 ）"></a>7.4. Serial Old 收集器（单线程标记整理算法 ）</h3><p>​    *<em>Serial Old 是 Serial 垃圾收集器年老代版本 *</em>，它同样是个单线程的收集器，使用标记 - 整理算法， 这个收集器也主要是 ** 运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器 **。 在 Server 模式下，主要有两个用途： </p><ol><li>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</li><li>作为年老代中使用 CMS 收集器的后备垃圾收集方案。 新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图： </li></ol><p><img src="/images/Java_heart_JVM/java_1_jvm_12.png" alt></p><p>​    新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使 用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代 Parallel Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图： </p><p><img src="/images/Java_heart_JVM/java_1_jvm_13.png" alt></p><h3 id="7-5-Parallel-Old-收集器（多线程标记整理算法）"><a href="#7-5-Parallel-Old-收集器（多线程标记整理算法）" class="headerlink" title="7.5. Parallel Old 收集器（多线程标记整理算法）"></a>7.5. Parallel Old 收集器（多线程标记整理算法）</h3><p>​    Parallel Old 收集器是 Parallel Scavenge 的年老代版本，使用多线程的标记 - 整理算法，在 JDK1.6 才开始提供。 </p><p>​    在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只 能保证新生代的吞吐量优先，无法保证整体的吞吐量，*<em>Parallel Old 正是为了在年老代同样提供吞 吐量优先的垃圾收集器 *</em>，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge 和年老代 Parallel Old 收集器的搭配策略。 新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图： </p><p><img src="/images/Java_heart_JVM/java_1_jvm_14.png" alt></p><h3 id="7-6-CMS-收集器（多线程标记清除算法）"><a href="#7-6-CMS-收集器（多线程标记清除算法）" class="headerlink" title="7.6. CMS 收集器（多线程标记清除算法）"></a>7.6. CMS 收集器（多线程标记清除算法）</h3><p>​    Concurrent mark sweep (CMS) 收集器是一种年老代垃圾收集器，其最 ** 主要目标是获取最短垃圾回收停顿时间 **，和其他年老代使用标记 - 整理算法不同，它使用多线程的标记 - 清除算法。 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。  CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段： </p><h4 id="7-6-1-初始标记"><a href="#7-6-1-初始标记" class="headerlink" title="7.6.1. 初始标记"></a>7.6.1. 初始标记</h4><p>​    只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 </p><h4 id="7-6-2-并发标记"><a href="#7-6-2-并发标记" class="headerlink" title="7.6.2. 并发标记"></a>7.6.2. 并发标记</h4><p>​    进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。 </p><h4 id="7-6-3-重新标记"><a href="#7-6-3-重新标记" class="headerlink" title="7.6.3. 重新标记"></a>7.6.3. 重新标记</h4><p>​    为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记 记录，仍然需要暂停所有的工作线程。 </p><h4 id="7-6-4-并发清除"><a href="#7-6-4-并发清除" class="headerlink" title="7.6.4. 并发清除"></a>7.6.4. 并发清除</h4><p>​    清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并 发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以 ** 总体上来看 CMS 收集器的内存回收和用户线程是一起并发地执行 **。 CMS 收集器工作过程： </p><p><img src="/images/Java_heart_JVM/java_1_jvm_15.png" alt></p><h3 id="7-7-G1-收集器"><a href="#7-7-G1-收集器" class="headerlink" title="7.7. G1 收集器"></a>7.7. G1 收集器</h3><p>​    Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收 集器两个最突出的改进是： </p><ol><li>基于标记 - 整理算法，不产生内存碎片。 </li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 <strong>G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域 **，并且跟踪这些区域 的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，</strong> 优先回收垃圾最多的区域 **。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收 集效率。 </li></ol><h2 id="8-JAVA-IO-NIO"><a href="#8-JAVA-IO-NIO" class="headerlink" title="8.  JAVA IO/NIO"></a>8.  JAVA IO/NIO</h2><h3 id="8-1-阻塞-IO-模型"><a href="#8-1-阻塞-IO-模型" class="headerlink" title="8.1. 阻塞 IO 模型"></a>8.1. 阻塞 IO 模型</h3><p>​    最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内 核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用 户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：<strong>data = socket.read ()</strong>; 如果数据没有就 绪，就会一直阻塞在 read 方法。 </p><h3 id="8-2-非阻塞-IO-模型"><a href="#8-2-非阻塞-IO-模型" class="headerlink" title="8.2. 非阻塞 IO 模型"></a>8.2. 非阻塞 IO 模型</h3><p>​    当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备 好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;  </span><br><span class="line">    data = socket.read ();</span><br><span class="line">    <span class="keyword">if</span>(data!= error)&#123;  </span><br><span class="line">        处理数据  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    但是对于非阻塞 IO 就有一个非常严重的问题，<u> 在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高 </u>，因此一般情况下很少使用 while 循环这种方式来读取数据。 </p><h3 id="8-3-多路复用-IO-模型"><a href="#8-3-多路复用-IO-模型" class="headerlink" title="8.3. 多路复用 IO 模型"></a>8.3. 多路复用 IO 模型</h3><p>​    多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO 模型中，** 会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真 正调用实际的 IO 读写操作 **。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通 过 selector.select () 去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这 种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当 socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连 接数比较多的情况。</p><p>​    <u> 另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态 时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效 率要比用户线程要高的多。</u> </p><p>​    不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件 逐一进行响应。因此对于多路复用 IO 模型来说，** 一旦事件响应体很大，那么就会导致后续的事件 迟迟得不到处理，并且会影响新的事件轮询 **。 </p><h3 id="8-4-信号驱动-IO-模型"><a href="#8-4-信号驱动-IO-模型" class="headerlink" title="8.4. 信号驱动 IO 模型"></a>8.4. 信号驱动 IO 模型</h3><p>​    在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函 数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到 信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。 </p><h3 id="8-5-异步-IO-模型"><a href="#8-5-异步-IO-模型" class="headerlink" title="8.5. 异步 IO 模型"></a>8.5. 异步 IO 模型</h3><p>​    异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就 可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后， 它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内 核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程 发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何 进行的，** 只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接 去使用数据了。** </p><p>​    也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完 成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的 读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据 已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号 表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。 </p><p>** 注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。**<br>更多参考： <a href="http://www.importnew.com/19816.html" target="_blank" rel="noopener">http://www.importnew.com/19816.html</a> </p><h3 id="8-6-JAVA-IO-包"><a href="#8-6-JAVA-IO-包" class="headerlink" title="8.6. JAVA IO 包"></a>8.6. JAVA IO 包</h3><p><img src="/images/Java_heart_JVM/java_1_jvm_16.png" alt></p><h3 id="8-7-JAVA-NIO"><a href="#8-7-JAVA-NIO" class="headerlink" title="8.7. JAVA NIO"></a>8.7. JAVA NIO</h3><p>​    NIO 主要有三大核心部分：Channel (通道)，Buffer (缓冲区), Selector。传统 IO 基于字节流和字 符流进行操作，而 *<em>NIO 基于 Channel 和 Buffer (缓冲区) 进行操作，数据总是从通道读取到缓冲区 中，或者从缓冲区写入到通道中 *</em>。Selector (选择区) 用于监听多个通道的事件（比如：连接打开， 数据到达）。因此，单个线程可以监听多个数据通道。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_17.png" alt></p><p>​    NIO 和传统 IO 之间第一个最大的区别是，*<em>IO 是面向流的，NIO 是面向缓冲区的 *</em>。 </p><h4 id="8-7-1-NIO-的缓冲区"><a href="#8-7-1-NIO-的缓冲区" class="headerlink" title="8.7.1. NIO 的缓冲区"></a>8.7.1. NIO 的缓冲区</h4><p>​    Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何 地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓 存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在 缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所 有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的 数据。 </p><h4 id="8-7-2-NIO-的非阻塞"><a href="#8-7-2-NIO-的非阻塞" class="headerlink" title="8.7.2. NIO 的非阻塞"></a>8.7.2. NIO 的非阻塞</h4><p>​    IO 的各种流是阻塞的。这意味着，当一个线程调用 read () 或 write () 时，该线程被阻塞，直到有 一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式， 使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可 用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以 继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它 完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上 执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_18.png" alt></p><h3 id="8-8-Channel"><a href="#8-8-Channel" class="headerlink" title="8.8. Channel"></a>8.8. Channel</h3><p>​    首先说一下 Channel，国内大多翻译成 “通道”。Channel 和 IO 中的 Stream (流) 是差不多一个 等级的。** 只不过 Stream 是单向的 **，譬如：InputStream, OutputStream，而 Channel 是双向 的，既可以用来进行读操作，又可以用来进行写操作。 NIO 中的 Channel 的主要实现有： </p><p>​    1.FileChannel </p><p>​    2.DatagramChannel </p><p>​    3.SocketChannel </p><p>​    4.ServerSocketChannel </p><p>​    这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。 下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。 </p><h3 id="8-9-Buffer"><a href="#8-9-Buffer" class="headerlink" title="8.9. Buffer"></a>8.9. Buffer</h3><p>​    Buffer，故名思意，** 缓冲区，实际上是一个容器，是一个连续数组 **。Channel 提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。</p><p><img src="/images/Java_heart_JVM/java_1_jvm_19.png" alt> </p><p>​    上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送 数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必 须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。 </p><p>​    在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有： ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、 ShortBuffer </p><h3 id="8-10-Selector"><a href="#8-10-Selector" class="headerlink" title="8.10. Selector"></a>8.10. Selector</h3><p>​    Selector 类是 NIO 的核心类，*<em>Selector 能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理 *</em>。这样一来，只是用一个单线程就可 以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用 函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护 多个线程，并且避免了多线程之间的上下文切换导致的开销。 </p><h2 id="9-JVM-类加载机制"><a href="#9-JVM-类加载机制" class="headerlink" title="9. JVM 类加载机制"></a>9. JVM 类加载机制</h2><h3 id="9-1JVM-类加载"><a href="#9-1JVM-类加载" class="headerlink" title="9.1JVM 类加载"></a>9.1JVM 类加载</h3><p>​    JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这 五个过程。</p><p><img src="/images/Java_heart_JVM/java_1_jvm_20.png" alt></p><h4 id="9-1-1-加载"><a href="#9-1-1-加载" class="headerlink" title="9.1.1. 加载"></a>9.1.1. 加载</h4><p>​    加载是类加载过程中的一个阶段，** 这个阶段会在内存中生成一个代表这个类 java.lang.Class 对象，作为方法区这个类的各种数据的入口 **。注意这里不一定非得要从一个 Class 文件获取，这里既 可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理）， 也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 </p><h4 id="9-1-2-验证"><a href="#9-1-2-验证" class="headerlink" title="9.1.2. 验证"></a>9.1.2. 验证</h4><p>​    这一阶段的主要目的是为了 ** 确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求 **，并 且不会危害虚拟机自身的安全。 </p><h4 id="9-1-3-准备"><a href="#9-1-3-准备" class="headerlink" title="9.1.3. 准备"></a>9.1.3. 准备</h4><p>​    准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即 ** 在方法区中分配这些变量所使用的内存空间 **。注意这里所说的初始值概念，比如一个类变量定义为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>​    ** 实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080<strong>，将 v 赋值为 8080 的 put static 指令是程序被编译后，</strong> 存放于类构造器 &lt; client &gt; 方法之中 **。 </p><p>​    但是注意如果声明为： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">8080</span>;</span><br></pre></td></tr></table></figure><p>​    在编译阶段会为 v 生成 ConstantValue 属性，在 ** 准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。** </p><h4 id="9-1-4-解析"><a href="#9-1-4-解析" class="headerlink" title="9.1.4. 解析"></a>9.1.4. 解析</h4><p>​    解析阶段是指 ** 虚拟机将常量池中的符号引用替换为直接引用的过程 **。符号引用就是 class 文件中 的： </p><p>​    1.CONSTANT_Class_info </p><p>​    2.CONSTANT_Field_info </p><p>​    3.CONSTANT_Method_info </p><h4 id="9-1-5-符号引用"><a href="#9-1-5-符号引用" class="headerlink" title="9.1.5. 符号引用"></a>9.1.5. 符号引用</h4><p>​    符号引用与虚拟机实现的布局无关，** 引用的目标并不一定要已经加载到内存中。各种虚拟 机实现的内存布局可以各不相同 **，但是它们能接受的符号引用必须是一致的，因为符号引 用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 </p><h4 id="9-1-6-直接引用"><a href="#9-1-6-直接引用" class="headerlink" title="9.1.6. 直接引用"></a>9.1.6. 直接引用</h4><p>​    直接引用可以是 ** 指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄 *<em>。如果有 了直接引用，那 *</em> 引用的目标必定已经在内存中存在 **。 </p><h4 id="9-1-7-初始化"><a href="#9-1-7-初始化" class="headerlink" title="9.1.7. 初始化"></a>9.1.7. 初始化</h4><p>​    初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载 器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 </p><h4 id="9-1-8-类构造器-client"><a href="#9-1-8-类构造器-client" class="headerlink" title="9.1.8. 类构造器 client"></a>9.1.8. 类构造器 client</h4><p>​    ** 初始化阶段是执行类构造器 client 方法的过程 <strong>。client 方法是由编译器自动收集类中的类变 量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子 client 方法执行之前，父类 的 client 方法已经执行完毕，</strong> 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译 器可以不为这个类生成 client () 方法 **。 </p><p>​    注意以下几种情况不会执行类初始化： </p><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 </li><li>定义对象数组，不会触发该类的初始化。 </li><li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触 发定义常量所在的类。 </li><li>通过类名获取 Class 对象，不会触发类的初始化。 </li><li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初 始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li><li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 </li></ol><h3 id="9-2-类加载器"><a href="#9-2-类加载器" class="headerlink" title="9.2. 类加载器"></a>9.2. 类加载器</h3><p>​    虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提 供了 3 种类加载器： </p><h4 id="9-2-1-启动类加载器-Bootstrap-ClassLoader"><a href="#9-2-1-启动类加载器-Bootstrap-ClassLoader" class="headerlink" title="9.2.1. 启动类加载器 (Bootstrap ClassLoader)"></a>9.2.1. 启动类加载器 (Bootstrap ClassLoader)</h4><p>​    1. 负责加载 <strong>JAVA_HOME\lib</strong> 目录中的，或通过 - Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。 </p><h4 id="9-2-2-扩展类加载器-Extension-ClassLoader"><a href="#9-2-2-扩展类加载器-Extension-ClassLoader" class="headerlink" title="9.2.2. 扩展类加载器 (Extension ClassLoader)"></a>9.2.2. 扩展类加载器 (Extension ClassLoader)</h4><p>​    2. 负责加载 <strong>JAVA_HOME\lib\ext</strong> 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。 </p><h4 id="9-2-3-应用程序类加载器-Application-ClassLoader-："><a href="#9-2-3-应用程序类加载器-Application-ClassLoader-：" class="headerlink" title="9.2.3. 应用程序类加载器 (Application ClassLoader)："></a>9.2.3. 应用程序类加载器 (Application ClassLoader)：</h4><ol start="3"><li><p>负责 ** 加载用户路径（classpath）上的类库 **。 JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。 </p><p><img src="/images/Java_heart_JVM/java_1_jvm_21.png" alt></p></li></ol><h3 id="9-3-双亲委派"><a href="#9-3-双亲委派" class="headerlink" title="9.3. 双亲委派"></a>9.3. 双亲委派</h3><p>​    ** 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父 类去完成 <strong>，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中， 只有当 ** 父类加载器反馈自己无法完成这个请求的时候 **（在它的加载路径下没有找到所需加载的 Class），</strong> 子类加载器才会尝试自己去加载 **。 </p><p>​    采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载 器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就 ** 保证了使用不同的类加载 器最终得到的都是同样一个 Object 对象 **。<br><img src="/images/Java_heart_JVM/java_1_jvm_22.png" alt></p><h3 id="9-4-OSGI（动态模型系统）"><a href="#9-4-OSGI（动态模型系统）" class="headerlink" title="9.4. OSGI（动态模型系统）"></a>9.4. OSGI（动态模型系统）</h3><p>​    OSGi (Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系 统的一系列规范。 </p><h4 id="9-4-1-动态改变构造"><a href="#9-4-1-动态改变构造" class="headerlink" title="9.4.1. 动态改变构造"></a>9.4.1. 动态改变构造</h4><p>​    OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使 这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。 </p><h4 id="9-4-2-模块化编程与热插拔"><a href="#9-4-2-模块化编程与热插拔" class="headerlink" title="9.4.2. 模块化编程与热插拔"></a>9.4.2. 模块化编程与热插拔</h4><p>​    OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以 ** 实现模块级的热插拔功能 **，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企 业级程序开发来说是非常具有诱惑力的特性。<br>​    </p><p>​    OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时 也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大 功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。 </p><h2 id="10-最后"><a href="#10-最后" class="headerlink" title="10. 最后"></a>10. 最后</h2><p>​    java 核心这部分，偶然所得的一份 pdf 文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;(1) 基本概念：&lt;/p&gt;
&lt;p&gt;​    JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Java" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>查看 ubuntu 是 32 位还是 64 位</title>
    <link href="https://quietair.gitee.io/ubuntu-see-64or32bit/"/>
    <id>https://quietair.gitee.io/ubuntu-see-64or32bit/</id>
    <published>2019-10-17T07:56:33.000Z</published>
    <updated>2020-03-22T16:19:44.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-查看操作系统是-32-位的还是-64-位的"><a href="#1-查看操作系统是-32-位的还是-64-位的" class="headerlink" title="1. 查看操作系统是 32 位的还是 64 位的"></a>1. 查看操作系统是 32 位的还是 64 位的</h2><p>在控制台输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uname --m</span><br></pre></td></tr></table></figure><p>** 回车后：**<br>** 如果显示 i686, 则表示安装了 32 位操作系统 **<br>** 如果显示 x86_64，则表示安装了 64 位操作系统 **</p><a id="more"></a><h2 id="2-如果想知道更多信息可以试试如下命令："><a href="#2-如果想知道更多信息可以试试如下命令：" class="headerlink" title="2. 如果想知道更多信息可以试试如下命令："></a>2. 如果想知道更多信息可以试试如下命令：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo uname --s <span class="comment"># 显示内核名字 </span></span><br><span class="line">$ sudo uname --r <span class="comment"># 显示内核版本 </span></span><br><span class="line">$ sudo uname --n <span class="comment"># 显示网络主机名 </span></span><br><span class="line">$ sudo uname --p <span class="comment"># 显示 cpu</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-查看操作系统是-32-位的还是-64-位的&quot;&gt;&lt;a href=&quot;#1-查看操作系统是-32-位的还是-64-位的&quot; class=&quot;headerlink&quot; title=&quot;1. 查看操作系统是 32 位的还是 64 位的&quot;&gt;&lt;/a&gt;1. 查看操作系统是 32 位的还是 64 位的&lt;/h2&gt;&lt;p&gt;在控制台输入：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo uname --m&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;** 回车后：**&lt;br&gt;** 如果显示 i686, 则表示安装了 32 位操作系统 **&lt;br&gt;** 如果显示 x86_64，则表示安装了 64 位操作系统 **&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux" scheme="https://quietair.gitee.io/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="https://quietair.gitee.io/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="https://quietair.gitee.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>jQuery.validator.addMethod 自定义验证规则</title>
    <link href="https://quietair.gitee.io/jQuery-validator-addMethod/"/>
    <id>https://quietair.gitee.io/jQuery-validator-addMethod/</id>
    <published>2019-10-09T05:51:19.000Z</published>
    <updated>2020-03-22T15:56:20.059Z</updated>
    
    <content type="html"><![CDATA[<p>​    jQuery.validate 是一款非常不错的表单验证工具，简单易上手，而且能达到很好的体验效果</p><h2 id="1-用前必备"><a href="#1-用前必备" class="headerlink" title="1. 用前必备"></a>1. 用前必备</h2><p>​    官方网站：<a href="http://bassistance.de/jquery-plugins/jquery-plugin-validation/（注意下载最新版）" target="_blank" rel="noopener">http://bassistance.de/jquery-plugins/jquery-plugin-validation/（注意下载最新版）</a><br>​    需要 JQuery 版本：1.2.6+, 兼容 1.3.2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"../js/jquery.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"../js/jquery.validate.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="2-默认校验规则"><a href="#2-默认校验规则" class="headerlink" title="2. 默认校验规则"></a>2. 默认校验规则</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">required:<span class="literal">true</span> <span class="comment"># 必输字段 </span></span><br><span class="line">remote:<span class="string">"check.php"</span> <span class="comment"># 使用 ajax 方法调用 check.php 验证输入值 </span></span><br><span class="line">email:<span class="literal">true</span> <span class="comment"># 必须输入正确格式的电子邮件 </span></span><br><span class="line">url:<span class="literal">true</span> <span class="comment"># 必须输入正确格式的网址 </span></span><br><span class="line">date:<span class="literal">true</span> <span class="comment"># 必须输入正确格式的日期 </span></span><br><span class="line">dateISO:<span class="literal">true</span> <span class="comment"># 必须输入正确格式的日期 (ISO)，例如：2009-06-23，1998/01/22 只验证格式，不验证有效性 </span></span><br><span class="line">number:<span class="literal">true</span> <span class="comment"># 必须输入合法的数字 (负数，小数)</span></span><br><span class="line">digits:<span class="literal">true</span> <span class="comment"># 必须输入整数 </span></span><br><span class="line">creditcard: <span class="comment"># 必须输入合法的信用卡号 </span></span><br><span class="line">equalTo:<span class="string">"#field"</span> <span class="comment"># 输入值必须和 #field 相同 </span></span><br><span class="line">accept: <span class="comment"># 输入拥有合法后缀名的字符串（上传文件的后缀）</span></span><br><span class="line">maxlength:5 <span class="comment"># 输入长度最多是 5 的字符串 (汉字算一个字符)</span></span><br><span class="line">minlength:10 <span class="comment"># 输入长度最小是 10 的字符串 (汉字算一个字符)</span></span><br><span class="line">rangelength:[5,10] <span class="comment"># 输入长度必须介于 5 和 10 之间的字符串 ")(汉字算一个字符)</span></span><br><span class="line">range:[5,10] <span class="comment"># 输入值必须介于 5 和 10 之间 </span></span><br><span class="line">max:5 <span class="comment"># 输入值不能大于 5</span></span><br><span class="line">min:10 <span class="comment"># 输入值不能小于 10</span></span><br></pre></td></tr></table></figure><h2 id="3-默认的提示"><a href="#3-默认的提示" class="headerlink" title="3. 默认的提示"></a>3. 默认的提示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">messages: &#123;</span><br><span class="line">required: <span class="string">"This field is required."</span>,</span><br><span class="line">remote: <span class="string">"Please fix this field."</span>,</span><br><span class="line">email: <span class="string">"Please enter a valid email address."</span>,</span><br><span class="line">url: <span class="string">"Please enter a valid URL."</span>,</span><br><span class="line">date: <span class="string">"Please enter a valid date."</span>,</span><br><span class="line">dateISO: <span class="string">"Please enter a valid date (ISO)."</span>,</span><br><span class="line">dateDE: <span class="string">"Bitte geben Sie ein g 眉 ltiges Datum ein."</span>,</span><br><span class="line">number: <span class="string">"Please enter a valid number."</span>,</span><br><span class="line">numberDE: <span class="string">"Bitte geben Sie eine Nummer ein."</span>,</span><br><span class="line">digits: <span class="string">"Please enter only digits"</span>,</span><br><span class="line">creditcard: <span class="string">"Please enter a valid credit card number."</span>,</span><br><span class="line">equalTo: <span class="string">"Please enter the same value again."</span>,</span><br><span class="line">accept: <span class="string">"Please enter a value with a valid extension."</span>,</span><br><span class="line">maxlength: $.validator.format (<span class="string">"Please enter no more than &#123;0&#125; characters."</span>),</span><br><span class="line">minlength: $.validator.format (<span class="string">"Please enter at least &#123;0&#125; characters."</span>),</span><br><span class="line">rangelength: $.validator.format (<span class="string">"Please enter a value between &#123;0&#125; and &#123;1&#125; characters long."</span>),</span><br><span class="line">range: $.validator.format (<span class="string">"Please enter a value between &#123;0&#125; and &#123;1&#125;."</span>),</span><br><span class="line">max: $.validator.format (<span class="string">"Please enter a value less than or equal to &#123;0&#125;."</span>),</span><br><span class="line">min: $.validator.format (<span class="string">"Please enter a value greater than or equal to &#123;0&#125;."</span>)</span><br><span class="line">&#125;, 如需要修改，可在 js 代码中加入：jQuery.extend (jQuery.validator.messages, &#123;</span><br><span class="line">required: <span class="string">"必选字段"</span>,</span><br><span class="line">remote: <span class="string">"请修正该字段"</span>,</span><br><span class="line">email: <span class="string">"请输入正确格式的电子邮件"</span>,</span><br><span class="line">url: <span class="string">"请输入合法的网址"</span>,</span><br><span class="line">date: <span class="string">"请输入合法的日期"</span>,</span><br><span class="line">dateISO: <span class="string">"请输入合法的日期 (ISO)."</span>,</span><br><span class="line">number: <span class="string">"请输入合法的数字"</span>,</span><br><span class="line">digits: <span class="string">"只能输入整数"</span>,</span><br><span class="line">creditcard: <span class="string">"请输入合法的信用卡号"</span>,</span><br><span class="line">equalTo: <span class="string">"请再次输入相同的值"</span>,</span><br><span class="line">accept: <span class="string">"请输入拥有合法后缀名的字符串"</span>,</span><br><span class="line">maxlength: jQuery.validator.format (<span class="string">"请输入一个长度最多是 &#123;0&#125; 的字符串"</span>),</span><br><span class="line">minlength: jQuery.validator.format (<span class="string">"请输入一个长度最少是 &#123;0&#125; 的字符串"</span>),</span><br><span class="line">rangelength: jQuery.validator.format (<span class="string">"请输入一个长度介于 &#123;0&#125; 和 &#123;1&#125; 之间的字符串"</span>),</span><br><span class="line">range: jQuery.validator.format (<span class="string">"请输入一个介于 &#123;0&#125; 和 &#123;1&#125; 之间的值"</span>),</span><br><span class="line">max: jQuery.validator.format (<span class="string">"请输入一个最大为 &#123;0&#125; 的值"</span>),</span><br><span class="line">min: jQuery.validator.format (<span class="string">"请输入一个最小为 &#123;0&#125; 的值"</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 推荐做法，将此文件放入 messages_cn.js 中，在页面中引入 </span><br><span class="line">&lt;script src=<span class="string">"../js/messages_cn.js"</span> <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="4-使用方法"><a href="#4-使用方法" class="headerlink" title="4. 使用方法"></a>4. 使用方法</h2><p><strong>html:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//head 里需要加入 </span><br><span class="line"><span class="comment">#&lt;script src="../js/jquery.js" type="text/javascript"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">#&lt;script src="../js/jquery.validate.js" type="text/javascript"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">#&lt;script src="./js/messages_cn.js" type="text/javascript"&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">""</span> method=<span class="string">"post"</span> id=<span class="string">"registerForm"</span> onsubmit=<span class="string">"return toVaild ()"</span>&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"userName"</span> class=<span class="string">"username"</span> placeholder=<span class="string">" 您的用户名 "</span> autocomplete=<span class="string">"off"</span>/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                        &lt;input <span class="built_in">type</span>=<span class="string">"password"</span> name=<span class="string">"userPw"</span> class=<span class="string">"password"</span> placeholder=<span class="string">" 输入密码 "</span> oncontextmenu=<span class="string">"return false"</span> onpaste=<span class="string">"return false"</span> /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                        &lt;input <span class="built_in">type</span>=<span class="string">"password"</span> name=<span class="string">"confirm_password"</span> class=<span class="string">"confirm_password"</span> placeholder=<span class="string">" 再次输入密码 "</span> oncontextmenu=<span class="string">"return false"</span> onpaste=<span class="string">"return false"</span> /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                        &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> name=<span class="string">"userPhoneNum"</span> class=<span class="string">"phone_number"</span> placeholder=<span class="string">" 输入手机号码 "</span> autocomplete=<span class="string">"off"</span> id=<span class="string">"number"</span>/&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                        &lt;input <span class="built_in">type</span>=<span class="string">"email"</span> name=<span class="string">"userMail"</span> class=<span class="string">"email"</span> placeholder=<span class="string">" 输入邮箱地址 "</span> oncontextmenu=<span class="string">"return false"</span> onpaste=<span class="string">"return false"</span> /&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">        &lt;button id=<span class="string">"submit"</span> <span class="built_in">type</span>=<span class="string">"submit"</span>&gt; 注 册 & lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p><strong>messages_cn.js:</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">//jquery.validate 表单验证 </span><br><span class="line">$(document).ready (<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    // 注册表单验证 </span><br><span class="line">        $(<span class="string">"#registerForm"</span>).validate (&#123;</span><br><span class="line">                rules:&#123;</span><br><span class="line">                        userName:&#123;</span><br><span class="line">                                required:<span class="literal">true</span>,// 必填 </span><br><span class="line">                                minlength:3, // 最少 3 个字符 </span><br><span class="line">                                maxlength:32,// 最多 20 个字符 </span><br><span class="line">                                uName:<span class="literal">true</span>,// 自定义的规则 </span><br><span class="line">                                /*remote:&#123;</span><br><span class="line">                                        url:<span class="string">"http://kouss.com/demo/Sharelink/remote.json"</span>,// 用户名重复检查，别跨域调用 </span><br><span class="line">                                        <span class="built_in">type</span>:<span class="string">"post"</span>,</span><br><span class="line">                                &#125;,*/</span><br><span class="line">                        &#125;,</span><br><span class="line">                        userPw:&#123;</span><br><span class="line">                                required:<span class="literal">true</span>,</span><br><span class="line">                                minlength:3,</span><br><span class="line">                                maxlength:32,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        userMail:&#123;</span><br><span class="line">                                required:<span class="literal">true</span>,</span><br><span class="line">                                email:<span class="literal">true</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        confirm_password:&#123;</span><br><span class="line">                                required:<span class="literal">true</span>,</span><br><span class="line">                                minlength:3,</span><br><span class="line">                                equalTo:<span class="string">'.password'</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        userPhoneNum:&#123;</span><br><span class="line">                                required:<span class="literal">true</span>,</span><br><span class="line">                                userPhoneNum:<span class="literal">true</span>,// 自定义的规则 </span><br><span class="line">                                digits:<span class="literal">true</span>,// 整数 </span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 错误信息提示 </span><br><span class="line">                messages:&#123;</span><br><span class="line">                        userName:&#123;</span><br><span class="line">                                required:<span class="string">"必须填写用户名"</span>,</span><br><span class="line">                                minlength:<span class="string">"用户名至少为 3 个字符"</span>,</span><br><span class="line">                                maxlength:<span class="string">"用户名至多为 32 个字符"</span>,</span><br><span class="line">                                //remote: <span class="string">"用户名已存在"</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        userPw:&#123;</span><br><span class="line">                                required:<span class="string">"必须填写密码"</span>,</span><br><span class="line">                                minlength:<span class="string">"密码至少为 3 个字符"</span>,</span><br><span class="line">                                maxlength:<span class="string">"密码至多为 32 个字符"</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                        userMail:&#123;</span><br><span class="line">                                required:<span class="string">"请输入邮箱地址"</span>,</span><br><span class="line">                                email: <span class="string">"请输入正确的 email 地址"</span></span><br><span class="line">                        &#125;,</span><br><span class="line">                        confirm_password:&#123;</span><br><span class="line">                                required: <span class="string">"请再次输入密码"</span>,</span><br><span class="line">                                minlength: <span class="string">"确认密码不能少于 3 个字符"</span>,</span><br><span class="line">                                equalTo: <span class="string">"两次输入密码不一致"</span>,// 与另一个元素相同 </span><br><span class="line">                        &#125;,</span><br><span class="line">                        userPhoneNum:&#123;</span><br><span class="line">                                required:<span class="string">"请输入手机号码"</span>,</span><br><span class="line">                                digits:<span class="string">"请输入正确的手机号码"</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    // 字母和数字的验证 </span><br><span class="line">        jQuery.validator.addMethod (<span class="string">"uName"</span>, <span class="keyword">function</span>(value, element) &#123;</span><br><span class="line">                var uName = /^([a-zA-Z0-9]+)$/;</span><br><span class="line">                <span class="built_in">return</span> this.optional (element) || (uName.test (value));</span><br><span class="line">        &#125;, <span class="string">"用户名仅支持非空，数字和英文"</span>);</span><br><span class="line"></span><br><span class="line">        // 添加自定义验证规则 </span><br><span class="line">        jQuery.validator.addMethod (<span class="string">"userPhoneNum"</span>, <span class="keyword">function</span>(value, element) &#123;</span><br><span class="line">                var length = value.length;</span><br><span class="line">                var userPhoneNum = /^1 [3456789]\d&#123;9&#125;$/</span><br><span class="line">                <span class="built_in">return</span> this.optional (element) || (length == 11 &amp;&amp; userPhoneNum.test (value));</span><br><span class="line">        &#125;, <span class="string">"手机号码格式错误"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>** 方法：$.validator.addMethod (name,function (value,element){  return true||false },message)；**</p><pre><code>参数：  第一个参数：用于 type 匹配的名称，自定义。  第二个参数：是一个 function 函数，决定了验证是否成功！里面是自定义验证。  第三个参数：当验证不成功时返回的提示错误信息。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    jQuery.validate 是一款非常不错的表单验证工具，简单易上手，而且能达到很好的体验效果&lt;/p&gt;
&lt;h2 id=&quot;1-用前必备&quot;&gt;&lt;a href=&quot;#1-用前必备&quot; class=&quot;headerlink&quot; title=&quot;1. 用前必备&quot;&gt;&lt;/a&gt;1. 用前必备&lt;/h2&gt;&lt;p&gt;​    官方网站：&lt;a href=&quot;http://bassistance.de/jquery-plugins/jquery-plugin-validation/（注意下载最新版）&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://bassistance.de/jquery-plugins/jquery-plugin-validation/（注意下载最新版）&lt;/a&gt;&lt;br&gt;​    需要 JQuery 版本：1.2.6+, 兼容 1.3.2&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&lt;span class=&quot;string&quot;&gt;&quot;../js/jquery.js&quot;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&lt;span class=&quot;string&quot;&gt;&quot;../js/jquery.validate.js&quot;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://quietair.gitee.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JQuery" scheme="https://quietair.gitee.io/tags/JQuery/"/>
    
      <category term="Html" scheme="https://quietair.gitee.io/tags/Html/"/>
    
      <category term="Validate" scheme="https://quietair.gitee.io/tags/Validate/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 配置 Tomcat80 端口</title>
    <link href="https://quietair.gitee.io/ubuntu-tomcat/"/>
    <id>https://quietair.gitee.io/ubuntu-tomcat/</id>
    <published>2019-09-30T03:01:10.000Z</published>
    <updated>2020-03-22T16:01:10.171Z</updated>
    
    <content type="html"><![CDATA[<p>本地环境：<br>*ubuntu 18.04 LTS<br>*jdk 1.8.0_181<br>*tomcat 9.0.26</p><p>​    使用 Ubuntu 18.04 环境部署 Java Web 应用，在配置 Tomcat 时，发现 8080 端口没问题，改为 80 端口后就报错，然后自己网上找了些资料改去改来，不是 [“http-nio-80”]，就 APR，要么就拒绝连接。明天前面都用得好好的！后来又网上看了很多，才发现问题，然后就写这篇记忆下。</p><a id="more"></a><p>​    具体问题为在 Linux 中对非 root 用户只能使用 1024 及以上的端口号，所以 80 端口对非 root 用户为禁用状态。第一种解决方法：使用 root 用户去配置并启动 Tomcat。这里讲的是第二种解决方法：使用 iptables 的转发功能，将 80 端口消息转发给 8080 端口。如果嫌麻烦，建议第一种。自己记住就行了。第二种教程如下：</p><h2 id="1-前期工作"><a href="#1-前期工作" class="headerlink" title="1. 前期工作"></a>1. 前期工作</h2><h3 id="1-1-系统是否安装防火墙："><a href="#1-1-系统是否安装防火墙：" class="headerlink" title="1.1. 系统是否安装防火墙："></a>1.1. 系统是否安装防火墙：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ whereis iptables</span><br></pre></td></tr></table></figure><h3 id="1-2-安装则下面显示为："><a href="#1-2-安装则下面显示为：" class="headerlink" title="1.2. 安装则下面显示为："></a>1.2. 安装则下面显示为：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ iptables: </span><br><span class="line">$ /sbin/iptables/etc/iptables.rules/usr/share/iptables/usr/share/man/man8/iptables.8.gz</span><br></pre></td></tr></table></figure><h3 id="1-3-反之，安装防火墙："><a href="#1-3-反之，安装防火墙：" class="headerlink" title="1.3. 反之，安装防火墙："></a>1.3. 反之，安装防火墙：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install iptables</span><br></pre></td></tr></table></figure><h3 id="1-4-查看防火墙信息："><a href="#1-4-查看防火墙信息：" class="headerlink" title="1.4. 查看防火墙信息："></a>1.4. 查看防火墙信息：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -L -n</span><br></pre></td></tr></table></figure><h2 id="2-配置防火墙"><a href="#2-配置防火墙" class="headerlink" title="2. 配置防火墙"></a>2. 配置防火墙</h2><h3 id="2-1-创建-iptables-rules-文件："><a href="#2-1-创建-iptables-rules-文件：" class="headerlink" title="2.1. 创建 iptables.rules 文件："></a>2.1. 创建 iptables.rules 文件：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/iptables.rules</span><br></pre></td></tr></table></figure><h3 id="2-2-按-i-进入编辑模式，添加以下规则："><a href="#2-2-按-i-进入编辑模式，添加以下规则：" class="headerlink" title="2.2. 按 i 进入编辑模式，添加以下规则："></a>2.2. 按 i 进入编辑模式，添加以下规则：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT DROP [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">:syn-flood - [0:0]</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 8443 -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 100/sec --<span class="built_in">limit</span>-burst 100 -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 1/s --<span class="built_in">limit</span>-burst 10 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j syn-flood</span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A syn-flood -p tcp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 3/sec --<span class="built_in">limit</span>-burst 6 -j RETURN</span><br><span class="line">-A syn-flood -j REJECT --reject-with icmp-port-unreachable</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">22   端口为 SSH 默认端口 </span><br><span class="line">80   端口为 HTTP 默认端口 </span><br><span class="line">443  端口为 HTTPS 默认端口 </span><br><span class="line">8080 端口为 Tomcat 默认的 HTTP 端口 </span><br><span class="line">8443 端口为 Tomcat 默认的 HTTPS 端口 </span><br></pre></td></tr></table></figure><h3 id="2-3-使防火墙规则生效："><a href="#2-3-使防火墙规则生效：" class="headerlink" title="2.3. 使防火墙规则生效："></a>2.3. 使防火墙规则生效：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables-restore &lt; /etc/iptables.rules</span><br></pre></td></tr></table></figure><h3 id="2-4-配置防火墙规则开机启动："><a href="#2-4-配置防火墙规则开机启动：" class="headerlink" title="2.4. 配置防火墙规则开机启动："></a>2.4. 配置防火墙规则开机启动：</h3><ul><li>创建 iptables 文件：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vi /etc/network/<span class="keyword">if</span>-pre-up.d/iptables</span><br></pre></td></tr></table></figure><ul><li>添加以下内容：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ !/bin/bash</span><br><span class="line">$ iptables-restore &lt; /etc/iptables.rules</span><br></pre></td></tr></table></figure><h3 id="2-5-为-iptables-文件添加执行权限："><a href="#2-5-为-iptables-文件添加执行权限：" class="headerlink" title="2.5. 为 iptables 文件添加执行权限："></a>2.5. 为 iptables 文件添加执行权限：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x /etc/network/<span class="keyword">if</span>-pre-up.d/iptables</span><br></pre></td></tr></table></figure><h3 id="2-6-查看规则是否生效："><a href="#2-6-查看规则是否生效：" class="headerlink" title="2.6. 查看规则是否生效："></a>2.6. 查看规则是否生效：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -L -n</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Chain INPUT (policy DROP)</span><br><span class="line">target     prot opt <span class="built_in">source</span>           destination         </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0        0.0.0.0/0           </span><br><span class="line">ACCEPT     all  --  0.0.0.0/0        0.0.0.0/0        state RELATED,ESTABLISHED</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0        0.0.0.0/0        state NEW tcp dpt:22</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0        0.0.0.0/0        state NEW tcp dpt:80</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0        0.0.0.0/0        state NEW tcp dpt:443</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0        0.0.0.0/0        state NEW tcp dpt:8080</span><br><span class="line">ACCEPT     tcp  --  0.0.0.0/0        0.0.0.0/0        state NEW tcp dpt:8443</span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0        0.0.0.0/0        <span class="built_in">limit</span>: avg 100/sec burst 100</span><br><span class="line">ACCEPT     icmp --  0.0.0.0/0        0.0.0.0/0        <span class="built_in">limit</span>: avg 1/sec burst 10</span><br><span class="line">syn-flood  tcp  --  0.0.0.0/0        0.0.0.0/0        tcp flags:0x17/0x02</span><br><span class="line">REJECT     all  --  0.0.0.0/0        0.0.0.0/0        reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>           destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt <span class="built_in">source</span>           destination         </span><br><span class="line"></span><br><span class="line">Chain syn-flood (1 references)</span><br><span class="line">target     prot opt <span class="built_in">source</span>           destination         </span><br><span class="line">RETURN     tcp  --  0.0.0.0/0        0.0.0.0/0        <span class="built_in">limit</span>: avg 3/sec burst 6</span><br><span class="line">REJECT     all  --  0.0.0.0/0        0.0.0.0/0        reject-with icmp-port-unreachable</span><br></pre></td></tr></table></figure><h2 id="3-新增转发规则"><a href="#3-新增转发规则" class="headerlink" title="3. 新增转发规则"></a>3. 新增转发规则</h2><h3 id="3-1-将-80-端口转发至-8080-端口"><a href="#3-1-将-80-端口转发至-8080-端口" class="headerlink" title="3.1. 将 80 端口转发至 8080 端口"></a>3.1. 将 80 端口转发至 8080 端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080</span><br></pre></td></tr></table></figure><h3 id="3-2-查看-80-端口相关的转发规则"><a href="#3-2-查看-80-端口相关的转发规则" class="headerlink" title="3.2. 查看 80 端口相关的转发规则"></a>3.2. 查看 80 端口相关的转发规则</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -L -n | grep 80</span><br></pre></td></tr></table></figure><p>返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ REDIRECT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 redir ports 8080</span><br></pre></td></tr></table></figure><h3 id="3-3-配置-Tomcat-服务端口为-8080"><a href="#3-3-配置-Tomcat-服务端口为-8080" class="headerlink" title="3.3. 配置 Tomcat 服务端口为 8080"></a>3.3. 配置 Tomcat 服务端口为 8080</h3><ul><li>找到 Tomcat 安装目录下的 ../conf/server.xml 配置文件并且打开编辑如下内容，改为 8080 端口即可。</li><li>&lt;Connector port=”8080” protocol=”HTTP/1.1”</li></ul><h3 id="3-4-重启-Tomcat-服务，试一下应该就可以进行正常访问-80-端口了。"><a href="#3-4-重启-Tomcat-服务，试一下应该就可以进行正常访问-80-端口了。" class="headerlink" title="3.4. 重启 Tomcat 服务，试一下应该就可以进行正常访问 80 端口了。"></a>3.4. 重启 Tomcat 服务，试一下应该就可以进行正常访问 80 端口了。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service tomcat restart</span><br></pre></td></tr></table></figure><h2 id="4-删除转发规则"><a href="#4-删除转发规则" class="headerlink" title="4. 删除转发规则"></a>4. 删除转发规则</h2><h3 id="4-1-将转发规则以数字序号排列显示"><a href="#4-1-将转发规则以数字序号排列显示" class="headerlink" title="4.1. 将转发规则以数字序号排列显示:"></a>4.1. 将转发规则以数字序号排列显示:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -L -n --line-numbers</span><br></pre></td></tr></table></figure><ul><li>Chain PREROUTING (policy ACCEPT)</li><li>num target prot opt source destination</li><li>1 REDIRECT tcp – 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 redir ports 8080</li></ul><h3 id="4-2-删除-8080-端口对于的转发规则："><a href="#4-2-删除-8080-端口对于的转发规则：" class="headerlink" title="4.2. 删除 8080 端口对于的转发规则："></a>4.2. 删除 8080 端口对于的转发规则：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ iptables -t nat -D PREROUTING 1</span><br></pre></td></tr></table></figure><h2 id="5-相关问题"><a href="#5-相关问题" class="headerlink" title="5. 相关问题"></a>5. 相关问题</h2><p>​    上述配置完成后，即可使用 IP 地址（或域名）+ 应用程序页面访问路径。如需直接使用 IP 地址（或域名）访问应用程序默认页面，应另外配置。另外，若参照上述配置时使用的是通过 域名 进行访问，则需要进行域名备案，同时需要指定访问的应用。当然可以暂且使用 域名：8080 进行访问，或是使用 https:// 域名 进行访问。</p><h2 id="6-文章参考"><a href="#6-文章参考" class="headerlink" title="6. 文章参考"></a>6. 文章参考</h2><p><a href="https://blog.csdn.net/xh_257/article/details/81982320" target="_blank" rel="noopener">Ubuntu 如何配置 Tomcat 访问 80 端口</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本地环境：&lt;br&gt;*ubuntu 18.04 LTS&lt;br&gt;*jdk 1.8.0_181&lt;br&gt;*tomcat 9.0.26&lt;/p&gt;
&lt;p&gt;​    使用 Ubuntu 18.04 环境部署 Java Web 应用，在配置 Tomcat 时，发现 8080 端口没问题，改为 80 端口后就报错，然后自己网上找了些资料改去改来，不是 [“http-nio-80”]，就 APR，要么就拒绝连接。明天前面都用得好好的！后来又网上看了很多，才发现问题，然后就写这篇记忆下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="后端" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="Linux" scheme="https://quietair.gitee.io/categories/%E5%90%8E%E7%AB%AF/Linux/"/>
    
    
      <category term="Tomcat" scheme="https://quietair.gitee.io/tags/Tomcat/"/>
    
      <category term="Ubuntu" scheme="https://quietair.gitee.io/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="https://quietair.gitee.io/tags/Linux/"/>
    
  </entry>
  
</feed>
