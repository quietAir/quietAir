[{"title":"Spring Boot 与日志","date":"2020-03-12T02:47:23.000Z","path":"spring-boot-logging/","text":"1. 日志框架一个统一的接口层；日志门面（日志的一个抽象层）； 给项目中导入具体的日志实现就行了；之前的日志框架都是实现的抽象层； 市面上的日志框架: JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j…… 日志门面 （日志的抽象层） 日志实现 JCL（Jakarta Commons Logging） SLF4j（Simple Logging Facade for Java） jboss-logging Log4j JUL（java.util.logging） Log4j2 Logback 左边选一个门面（抽象层）、右边来选一个实现； 日志门面： SLF4J； 日志实现：Logback； SpringBoot：底层是 Spring 框架，Spring 框架默认是用 JCL； ​ SpringBoot 选用 SLF4j 和 logback； 2.SLF4j 使用2.1. 如何在系统中使用 SLF4j用户文档 以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法； 给系统里面导入 slf4j 的 jar 和 logback 的实现 jar 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String [] args) &#123; Logger logger = LoggerFactory.getLogger (HelloWorld.class); logger.info (\"Hello World\"); &#125;&#125; 图示； 每一个日志的实现框架都有自己的配置文件。使用 slf4j 以后，** 配置文件还是做成日志实现框架自己本身的配置文件；** 2.2. 遗留问题a（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis、xxxx 统一日志记录，即使是别的框架和我一起统一使用 slf4j 进行输出？ ** 如何让系统中所有的日志都统一到 slf4j；** 1、将系统中其他日志框架先排除出去； 2、用中间包来替换原有的日志框架； 3、我们导入 slf4j 其他的实现； 3.SpringBoot 日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt; SpringBoot 使用它来做日志功能； 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;/dependency&gt; 底层依赖关系 总结： ​ 1）、SpringBoot 底层也是使用 slf4j+logback 的方式进行日志记录 ​ 2）、SpringBoot 也把其他的日志都替换成了 slf4j； ​ 3）、中间替换包？ 123456@SuppressWarnings(\"rawtypes\")public abstract class LogFactory &#123; static String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J = \"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j\"; static LogFactory logFactory = new SLF4JLogFactory (); ​ 4）、如果我们要引入其他框架？一定要把这个框架的默认日志依赖移除掉？ ​ Spring 框架用的是 commons-logging； 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; SpringBoot 能自动适配所有的日志，而且底层使用 slf4j+logback 的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可； 4. 日志使用4.1. 默认配置SpringBoot 默认帮我们配置好了日志； 123456789101112131415161718// 记录器 Logger logger = LoggerFactory.getLogger (getClass ());@Testpublic void contextLoads() &#123; //System.out.println (); // 日志的级别； // 由低到高 trace&lt;debug&lt;info&lt;warn&lt;error // 可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效 logger.trace (\"这是 trace 日志...\"); logger.debug (\"这是 debug 日志...\"); //SpringBoot 默认给我们使用的是 info 级别的，没有指定级别的就用 SpringBoot 默认规定的级别；root 级别 logger.info (\"这是 info 日志...\"); logger.warn (\"这是 warn 日志...\"); logger.error (\"这是 error 日志...\");&#125; 12345678910 &lt;-- 日志输出格式：%d 表示日期时间，%thread 表示线程名，%-5level：级别从左显示 < span class=\"attr\">5 个字符宽度 %logger&#123;50&#125; 表示 < span class=\"attr\">logger 名字最长 < span class=\"attr\">50 个字符，否则按照句点分割。 %msg：日志消息，%n 是换行符 --&gt; % d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [% thread] %-5level % logger&#123;50&#125; - % msg% n SpringBoot 修改日志的默认配置： 1234567891011121314151617181920logging.level.com.atguigu=trace#logging.path=(过时)# 在当前项目下生成 my.log 日志 logging.file.name=my.log#logging.file=G:/springboot.log (过时)#logging.file.path= 文件名 直接在跟目录下创建该文件且自动 帮你创建好 spring.log 文件 logging.file.name=/log# 在当前磁盘的根路径下创建 spring 文件夹和里面的 log 文件夹；使用 spring.log 作为默认文件 logging.path=/spring/log (过时)# 在控制台输出的日志的格式 logging.pattern.console=% d&#123;yyyy-MM-dd&#125; [% thread] %-5level % logger&#123;50&#125; - % msg% n# 指定文件中日志输出的格式 logging.pattern.file=% d&#123;yyyy-MM-dd&#125; === [% thread] === %-5level === % logger&#123;50&#125; ==== % msg% n logging.file.name logging.file.name Example Description (none) (none) 仅控制台记录。 指定文件名 (none) my.log 写入指定的日志文件。名称可以是确切的位置，也可以相对于当前目录。 (none) 指定目录 /var/log 写入 spring.log 指定的目录。名称可以是确切的位置，也可以相对于当前目录。 4.2. 指定配置官方日志文档；给类路径下放上每个日志框架自己的配置文件即可；SpringBoot 就不使用他默认配置的了 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties 官方建议将 -spring 变体用于日志记录配置（例如，logback-spring.xml 而不是 logback.xml）。如果使用标准配置位置，Spring 将无法完全控制日志初始化。 如果用 logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由 SpringBoot 解析日志配置，可以使用 SpringBoot 的高级 Profile 功能 1234&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt; 可以指定某段配置只在某个环境下生效 &lt;/springProfile&gt; 如： 12345678910111213141516171819&lt;appender name=\"stdout\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- 日志输出格式： % d 表示日期时间， % thread 表示线程名， %-5level：级别从左显示 5 个字符宽度 % logger&#123;50&#125; 表示 logger 名字最长 50 个字符，否则按照句点分割。 % msg：日志消息， % n 是换行符 --&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;springProfile name=\"dev\"&gt; &lt;pattern&gt;% d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ----&gt; [% thread] ---&gt; %-5level % logger&#123;50&#125; - % msg% n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;springProfile name=\"!dev\"&gt; &lt;pattern&gt;% d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; ==== [% thread] ==== %-5level % logger&#123;50&#125; - % msg% n&lt;/pattern&gt; &lt;/springProfile&gt; &lt;/layout&gt; &lt;/appender&gt; 如果使用 logback.xml 作为日志配置文件，还要使用 profile 功能，会有以下错误: 1no applicable action for [springProfile] 5. 切换日志框架可以按照 slf4j 的日志适配图，进行相关的切换； slf4j+log4j 的方式: 12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;artifactId&gt;log4j-over-slf4j&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为 log4j2: 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt; 6. 最后​ 此 spring boot 部分，来自尚硅谷教学视频，本着学习所用的态度。","updated":"2020-03-23T15:11:52.682Z","link":"","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quietair.gitee.io/tags/SpringBoot/"}]},{"title":"Spring Boot 配置文件解析","date":"2020-03-05T07:46:27.000Z","path":"spring-boot-configuration/","text":"1. 配置文件SpringBoot 使用一个全局的配置文件，配置文件名是固定的； ・application.properties ・application.yml 配置文件的作用：修改 SpringBoot 自动配置的默认值；SpringBoot 在底层都给我们自动配置好； YAML（YAML Ain’t Markup Language） ​ YAML A Markup Language：是一个标记语言 ​ YAML isn’t Markup Language：不是一个标记语言； 标记语言： ​ 以前的配置文件；大多都使用的是 xxxx.xml 文件； ​ YAML：** 以数据为中心 **，比 json、xml 等更适合做配置文件； ​ YAML：配置例子 12server: port: 8081 ​ XML： 123&lt;server&gt; &lt;port&gt;8081&lt;/port&gt;&lt;/server&gt; 2.YAML 语法：2.1. 基本语法k:(空格) v：表示一对键值对（空格必须有）； 以 ** 空格 ** 的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的 123server: port: 8081 path: /hello 属性和值也是大小写敏感； 2.2. 值的写法** 字面量：普通的值（数字，字符串，布尔）** ​ k: v：字面直接来写； ​ 字符串默认不用加上单引号或者双引号； ​ “”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思 ​ name: “zhangsan \\n lisi”：输出；zhangsan 换行 lisi ​ ‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据 ​ name: ‘zhangsan \\n lisi’：输出；zhangsan \\n lisi 2.3. 对象、Map（属性和值）（键值对）：​ k: v：在下一行来写对象的属性和值的关系；注意缩进 ​ 对象还是 k: v 的方式 123friends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 2.4. 数组（List、Set）：用 - 值表示数组中的一个元素 1234pets: - cat - dog - pig 行内写法 1pets: [cat,dog,pig] 3. 配置文件值注入配置文件: 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 javaBean： 1234567891011121314151617181920/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的 < span class=\"doctag\">@ConfigurationProperties 功能； * */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 我们可以导入配置文件处理器，以后编写配置就有提示了 123456&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 3.1.properties 配置文件在 idea 中默认 utf-8 可能会乱码调整: 3.2.@Value 获取值和 @ConfigurationProperties 获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL (Spring 表达式) 不支持 支持 JSR303 数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件 yml 还是 properties 他们都能获取到值； 如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用 @Value； 如果说，我们专门编写了一个 javaBean 来和配置文件进行映射，我们就直接使用 @ConfigurationProperties； 3.3. 配置文件注入值数据校验123456789101112131415161718192021222324@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量 /$&#123;key&#125; 从环境变量、配置文件中获取值 /#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName 必须是邮箱格式 @Email //@Value (\"$&#123;person.last-name&#125;\") private String lastName; //@Value (\"#&#123;11*2&#125;\") private Integer age; //@Value (\"true\") private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; 3.4.@PropertySource&amp;@ImportResource&amp;@Bean@PropertySource：加载指定的配置文件； 1234567891011121314151617181920212223242526272829/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能容器提供的 < span class=\"doctag\">@ConfigurationProperties 功能； * @ConfigurationProperties(prefix = \"person\") 默认从全局配置文件中获取值； * */@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")//@Validatedpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量 /$&#123;key&#125; 从环境变量、配置文件中获取值 /#&#123;SpEL&#125;\"&gt;&lt;/property&gt; * &lt;bean/&gt; */ //lastName 必须是邮箱格式 // @Email //@Value (\"$&#123;person.last-name&#125;\") private String lastName; //@Value (\"#&#123;11*2&#125;\") private Integer age; //@Value (\"true\") private Boolean boss; @ImportResource：导入 Spring 的配置文件，让配置文件里面的内容生效； Spring Boot 里面没有 Spring 的配置文件，我们自己编写的配置文件，也不能自动识别； 想让 Spring 的配置文件生效，加载进来；@ImportResource 标注在一个配置类上 12@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;) 导入 Spring 的配置文件让其生效 不来编写 Spring 的配置文件 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"helloService\" class=\"com.atguigu.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; SpringBoot 推荐给容器中添加组件的方式；推荐使用全注解的方式 1、配置类 @Configuration——&gt;Spring 配置文件 2、使用 @Bean 给容器中添加组件 12345678910111213141516/** * @Configuration：指明当前类是一个配置类；就是来替代之前的 Spring 配置文件 * * 在配置文件中用 & lt;bean&gt;&lt;bean/&gt; 标签添加组件 * */@Configurationpublic class MyAppConfig &#123; // 将方法的返回值添加到容器中；容器中这个组件默认的 id 就是方法名 @Bean public HelloService helloService02()&#123; System.out.println (\"配置类 @Bean 给容器中添加组件了...\"); return new HelloService (); &#125;&#125; ##4、配置文件占位符 *1. 随机数 * 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; *2. 占位符获取之前配置的值，如果没有可以是用：指定默认值 * 123456789person.last-name= 张三 $&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dogperson.dog.age=15 4.ProfileProfile 是 spring 对不同环境提供不同配置功能的支持，可以通过激活、指定参数等方式快速切换环境。 4.1. 多 Profile 文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml 默认使用 application.properties 的配置； 4.2.yml 支持多文档块方式12345678910111213141516171819server: port: 8081spring: profiles: active: prod # 指定激活哪个环境 ---server: port: 8083spring: profiles: dev---server: port: 8084spring: profiles: prod # 指定属于哪个环境 4.3. 激活指定 profile​ 1、在配置文件中指定 spring.profiles.active=dev ​ 2、命令行： ​ java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar –spring.profiles.active=dev； ​ 可以直接在测试的时候，配置传入命令行参数 ​ 3、虚拟机参数； ​ -Dspring.profiles.active=dev 5. 配置文件加载位置springboot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring boot 的默认配置文件 123#application.properties 文件内容 server.post=8081#server.servlet.context-path=/boot #配置项目得访问路径 –file:./config/ –file:./ –classpath:/config/ –classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置； SpringBoot 会从这四个位置全部加载主配置文件；** 互补配置 **； == 我们还可以通过 spring.config.location 来改变默认的配置文件位置 == ** 项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；** java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar G:/application.properties 6. 外部配置加载顺序*SpringBoot 也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置 * *1. 命令行参数 * 所有的配置都可以在命令行上进行指定 java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar –server.port=8087 –server.context-path=/abc 多个配置用空格分开； – 配置项 = 值 来自 java:comp/env 的 JNDI 属性 3.Java 系统属性（System.getProperties ()） 操作系统环境变量 5.RandomValuePropertySource 配置的 random.* 属性值 ** 由 jar 包外向 jar 包内进行寻找；** ** 优先加载带 profile** *6.jar 包外部的 application-{profile}.properties 或 application.yml (带 spring.profile) 配置文件 * *7.jar 包内部的 application-{profile}.properties 或 application.yml (带 spring.profile) 配置文件 * ** 再来加载不带 profile** *8.jar 包外部的 application.properties 或 application.yml (不带 spring.profile) 配置文件 * *9.jar 包内部的 application.properties 或 application.yml (不带 spring.profile) 配置文件 * 10.@Configuration 注解类上的 @PropertySource 通过 SpringApplication.setDefaultProperties 指定的默认属性 所有支持的配置加载来源； 参考官方文档 7. 自动配置原理配置文件到底能写什么？怎么写？自动配置原理； 配置文件能配置的属性参照 7.1.** 自动配置原理：**1）、SpringBoot 启动的时候加载主配置类，开启了自动配置功能 @EnableAutoConfiguration 2）、@EnableAutoConfiguration 作用： 利用 EnableAutoConfigurationImportSelector 给容器中导入一些组件； 可以查看 selectImports () 方法的内容； List configurations = getCandidateConfigurations (annotationMetadata, attributes); 获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames ()// 扫描所有 jar 包类路径下 META-INF/spring.factories// 把扫描到的这些文件的内容包装成 properties 对象 // 从 properties 中获取到 EnableAutoConfiguration.class 类（类名）对应的值，然后把他们添加在容器中 将 类路径下 META-INF/spring.factories 里面配置的所有 EnableAutoConfiguration 的值加入到了容器中； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration 每一个这样的 xxxAutoConfiguration 类都是容器中的一个组件，都加入到容器中；用他们来做自动配置； 3）、每一个自动配置类进行自动配置功能； 4）、以 HttpEncodingAutoConfiguration（Http 编码自动配置） 为例解释自动配置原理； 1234567891011121314151617181920212223242526272829@Configuration // 表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件 @EnableConfigurationProperties(HttpEncodingProperties.class) // 启动指定类的 ConfigurationProperties 功能；将配置文件中对应的值和 HttpEncodingProperties 绑定起来；并把 HttpEncodingProperties 加入到 ioc 容器中 @ConditionalOnWebApplication //Spring 底层 @Conditional 注解（Spring 注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效； 判断当前应用是否是 web 应用，如果是，当前配置类生效 @ConditionalOnClass(CharacterEncodingFilter.class) // 判断当前项目有没有这个类 CharacterEncodingFilter；SpringMVC 中进行乱码解决的过滤器；@ConditionalOnProperty(prefix = \"spring.http.encoding\", value = \"enabled\", matchIfMissing = true) // 判断配置文件中是否存在某个配置 spring.http.encoding.enabled；如果不存在，判断也是成立的 // 即使我们配置文件中不配置 pring.http.encoding.enabled=true，也是默认生效的；public class HttpEncodingAutoConfiguration &#123; // 他已经和 SpringBoot 的配置文件映射了 private final HttpEncodingProperties properties; // 只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean // 给容器中添加一个组件，这个组件的某些值需要从 properties 中获取 @ConditionalOnMissingBean(CharacterEncodingFilter.class) // 判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter (); filter.setEncoding (this.properties.getCharset ().name ()); filter.setForceRequestEncoding (this.properties.shouldForce (Type.REQUEST)); filter.setForceResponseEncoding (this.properties.shouldForce (Type.RESPONSE)); return filter; &#125; 根据当前不同的条件判断，决定这个配置类是否生效？ 一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的 properties 类中获取的，这些类里面的每一个属性又是和配置文件绑定的； 5）、所有在配置文件中能配置的属性都是在 xxxxProperties 类中封装着；配置文件能配置什么就可以参照某个功能对应的这个属性类 1234@ConfigurationProperties(prefix = \"spring.http.encoding\") // 从配置文件中获取指定的值和 bean 的属性进行绑定 public class HttpEncodingProperties &#123; public static final Charset DEFAULT_CHARSET = Charset.forName (\"UTF-8\"); ** 精髓：** ​ *1）、SpringBoot 启动会加载大量的自动配置类 * ​ 2）、我们看我们需要的功能有没有 SpringBoot 默认写好的自动配置类； ​ 3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了） ​ 4）、给容器中自动配置类添加组件的时候，会从 properties 类中获取某些属性。我们就可以在配置文件中指定这些属性的值； xxxxAutoConfigurartion：自动配置类； 给容器中添加组件 xxxxProperties: 封装配置文件中相关属性； 7.2. 细节@Conditional 派生注解（Spring 注解版原生的 @Conditional 作用） 作用：必须是 @Conditional 指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效； @Conditional 扩展注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的 java 版本是否符合要求 @ConditionalOnBean 容器中存在指定 Bean； @ConditionalOnMissingBean 容器中不存在指定 Bean； @ConditionalOnExpression 满足 SpEL 表达式指定 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissingClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的 Bean，或者这个 Bean 是首选 Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定资源文件 @ConditionalOnWebApplication 当前是 web 环境 @ConditionalOnNotWebApplication 当前不是 web 环境 @ConditionalOnJndi JNDI 存在指定项 ** 自动配置类必须在一定的条件下才能生效；** 我们怎么知道哪些自动配置类生效； ** 我们可以通过启用 debug=true 属性；来让控制台打印自动配置报告 **，这样我们就可以很方便的知道哪些自动配置类生效； 1234567891011121314151617181920212223=========================AUTO-CONFIGURATION REPORT=========================Positive matches:（自动配置类启用的）----------------- DispatcherServletAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition) Negative matches:（没有启动，没有匹配成功的自动配置类）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) AopAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition) 8. 最后​ 此 spring boot 部分，来自尚硅谷教学视频，本着学习所用的态度。","updated":"2020-03-22T15:55:29.104Z","link":"","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quietair.gitee.io/tags/SpringBoot/"}]},{"title":"Spring Boot 入门","date":"2020-02-29T12:24:00.000Z","path":"spring-boot-01/","text":"1.Spring Boot 简介 简化 Spring 应用开发的一个框架； 整个 Spring 技术栈的一个大整合； -J2EE 开发的一站式解决方案； 2. 微服务微服务：架构风格（服务微化） 一个应用应该是一组小型服务；可以通过 HTTP 的方式进行互通； 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 详细参照微服务文档 3. 环境准备环境约束: –jdk1.8：Spring Boot 推荐 jdk1.7 及以上； –maven3.x：maven 3.3 以上版本； –IntelliJIDEA：IntelliJ IDEA –SpringBoot 1.5.9.RELEASE：1.5.9； 3.1.MAVEN 设置给 maven 的 settings.xml 配置文件的 profiles 标签添加 (可以添加，也可以不用)； 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; 3.2.IDEA 设置首先对 maven 进行整合； 4.Spring Boot HelloWorld实现一个简单的功能： 浏览器发送 hello 请求，服务器接受请求并处理，响应 Hello World 字符串； 4.1. 创建一个 maven 工程（jar）4.2. 导入 spring boot 相关的依赖1234567891011&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 4.3. 编写一个主程序；启动 Spring Boot 应用123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个 Spring Boot 应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String [] args) &#123; // 把 Spring 应用启动起来 SpringApplication.run (HelloWorldMainApplication.class,args); &#125;&#125; 4.4. 编写相关的 Controller、Service123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 4.5. 运行主程序测试4.6. 简化部署123456789&lt;!-- 这个插件，可以将应用打包成一个可执行的 jar 包；--&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 将这个应用打成 jar 包，再 window 下或者 Linux 下直接使用 java -jar 的命令进行执行； 5.Hello World 探究5.1.POM 文件5.1.1 父项目1234567891011121314&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt; 上面的父项目是 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 它来真正管理 Spring Boot 应用里面的所有依赖版本； Spring Boot 的版本仲裁中心； 以后我们导入依赖默认是不需要写版本；（没有在 dependencies 里面管理的依赖自然需要声明版本号） 5.1.2 启动器1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter-web： ​ spring-boot-starter：spring-boot 场景启动器；帮我们导入了 web 模块正常运行所依赖的组件； 总结：Spring Boot 将所有的功能场景都抽取出来，做成一个个的 starters（启动器），只需要在项目里面引入这些 starter 相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器 5.2. 主程序类，主入口类123456789101112/** * @SpringBootApplication 来标注一个主程序类，说明这是一个 Spring Boot 应用 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String [] args) &#123; // Spring 应用启动起来 SpringApplication.run (HelloWorldMainApplication.class,args); &#125;&#125; @SpringBootApplication: Spring Boot 应用标注在某个类上说明这个类是 SpringBoot 的主配置类，SpringBoot 就应该运行这个类的 main 方法来启动 SpringBoot 应用； 12345678910@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; @SpringBootConfiguration:Spring Boot 的配置类； ​ 标注在某个类上，表示这是一个 Spring Boot 的配置类； ​ @Configuration: 配置类上来标注这个注解； ​ 配置类 —– 配置文件；配置类也是容器中的一个组件；@Component @EnableAutoConfiguration：开启自动配置功能； ​ 以前我们需要配置的东西，Spring Boot 帮我们自动配置；@EnableAutoConfiguration 告诉 SpringBoot 开启自动配置功能；这样自动配置才能生效； 123@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ​ @AutoConfigurationPackage：自动配置包 ​ @Import(AutoConfigurationPackages.Registrar.class)： ​ Spring 的底层注解 @Import，给容器中导入一个组件；导入的组件由 AutoConfigurationPackages.Registrar.class； 将主配置类（@SpringBootApplication 标注的类）的所在包及下面所有子包里面的所有组件扫描到 Spring 容器； ​ @Import(EnableAutoConfigurationImportSelector.class)； ​ 给容器中导入组件？ ​ EnableAutoConfigurationImportSelector：导入哪些组件的选择器； ​ 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中； ​ 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件； 有了自动配置类，免去了我们手动编写配置注入功能组件等的工作； ​ SpringFactoriesLoader.loadFactoryNames (EnableAutoConfiguration.class,classLoader)； 总结：Spring Boot 在启动的时候从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；== 以前我们需要自己配置的东西，自动配置类都帮我们； J2EE 的整体整合解决方案和自动配置都在 spring-boot-autoconfigure-1.5.9.RELEASE.jar； 6.IDEA：使用 Spring Initializer 快速创建 spring boot 项目IDE 都支持使用 Spring 的项目创建向导快速创建一个 Spring Boot 项目； 选择我们需要的模块；向导会联网创建 Spring Boot 项目； 默认生成的 Spring Boot 项目； 主程序已经生成好了，我们只需要我们自己的逻辑 resources 文件夹中目录结构 static：保存所有的静态资源； js css images； templates：保存所有的模板页面；（Spring Boot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot 应用的配置文件；可以修改一些默认设置； 7. 最后​ 此 spring boot 部分，来自尚硅谷教学视频，本着学习所用的态度。","updated":"2020-03-22T15:55:27.880Z","link":"","tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://quietair.gitee.io/tags/SpringBoot/"}]},{"title":"Java 核心 (二) 之集合","date":"2019-11-09T06:32:07.000Z","path":"Java_heart_list/","text":"1. 接口继承关系和实现集合类存放于 Java.util 包中，主要有 3 种：set (集）、list (列表包含 Queue）和 map (映射)。 Collection：Collection 是集合 List、Set、Queue 的最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的数据 Map：是映射表的基础接口 2.ListJava 的 List 是非常常用的数据类型。List 是有序的 Collection。Java List 一共三个实现类：分别是 ArrayList、Vector 和 LinkedList。 2.1. ArrayList（数组）ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，** 当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除 **。 2.2. Vector（数组实现、线程同步）Vector 与 ArrayList 一样，也是通过数组实现的，不同的是 ** 它支持线程的同步，即某一时刻只有一个线程能够写 Vector**，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 2.3. LinkList（链表）*LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除 *，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 3.SetSet 注重独一无二的性质，该体系集合用于存储无序 (存入和取出的顺序不一定相同) 元素，** 值不能重复 。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的， 如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法 **。 3.1.HashSet（Hash 表）哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的 hashcode 方法来获取的，HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较 equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。 哈希值相同 equals 为 false 的元素是怎么存储呢，就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；图 2 表示 hashCode 值相同，但 equals 不相同的情况。 HashSet 通过 hashCode 值来确定元素在内存中的位置。** 一个 hashCode 位置上可以存放多个元素 **。 3.2.TreeSet（二叉树） TreeSet () 是使用二叉树的原理对新 add () 的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，** 自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo () 函数 **，才可以正常使用。 在覆写 compare () 函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序 比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 3.3.LinkHashSet（HashSet+LinkedHashMap）对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。 LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 4.Map 4.1. HashMap（数组 + 链表 + 红黑树）HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。 HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。我们用下面这张图来介绍 HashMap 的结构。 4.1.1. JAVA7 实现 大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：*key, value, hash 值和用于单向链表 * 的 next。 capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。 loadFactor：负载因子，默认为 0.75。 threshold：扩容的阈值，等于 capacity * loadFactor 4.1.2. JAVA8 实现Java8 对 HashMap 进行了一些修改，** 最大的不同就是利用了红黑树，所以其由 数组 + 链表 + 红黑树组成 **。 根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，** 需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O (n)。为了降低这部分的开销，在 Java8 中， 当链表中的元素超过了 8 个以后，会将链表转换为红黑树 **，在这些位置进行查找的时候可以降低时间复杂度为 O (logN)。 4.2. ConcurrentHashMap4.2.1. Segment 段ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表” 部分 “或” 一段 “的意思，所以很多地方都会将其描述为分段锁。注意，行文中，我很多地方用了 “槽” 来代表一个 segment。 4.2.2. 线程安全 Segment 继承 ReentrantLock 加锁）简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 4.2.3. 并行度（默认 16）concurrencyLevel：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。 4.2.4. Java8 实现（引入了红黑树）Java8 对 ConcurrentHashMap 进行了比较大的改动，Java8 也引入了红黑树。 4.3. HashTable（线程安全）Hashtable 是遗留类，很多映射的常用功能与 HashMap 类似，不同的是它承自 Dictionary 类，并且是线程安全的，任一时间只有一个线程能写 Hashtable，并发性不如 ConcurrentHashMap，因为 ConcurrentHashMap 引入了分段锁。Hashtable 不建议在新代码中使用，不需要线程安全的场合可以用 HashMap 替换，需要线程安全的场合可以用 ConcurrentHashMap 替换。 4.4. TreeMap（可排序）TreeMap 实现 SortedMap 接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历 TreeMap 时，得到的记录是排过序的。 如果使用排序的映射，建议使用 TreeMap。 在使用 TreeMap 时，key 必须实现 Comparable 接口或者在构造 TreeMap 传入自定义的 Comparator，否则会在运行时抛出 java.lang.ClassCastException 类型的异常。 参考：https://www.ibm.com/developerworks/cn/java/j-lo-tree/index.html 4.5. LinkHashMap（记录插入顺序） LinkedHashMap 是 HashMap 的一个子类，保存了记录的插入顺序，在用 Iterator 遍历 LinkedHashMap 时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 参考 1 ： http://www.importnew.com/28263.html 参考 2 ： http://www.importnew.com/20386.html#comment-648123 5. 最后java 核心这部分，偶然所得的一份 pdf 文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。","updated":"2020-03-23T14:41:18.908Z","link":"","tags":[]},{"title":"Java 核心 (一) 之 JVM","date":"2019-10-24T07:24:00.000Z","path":"Java_heart_JVM/","text":"(1) 基本概念： ​ JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、 一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。 (2) 运行过程： ​ 我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件， 而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。也就是如下：​ ① Java 源文件 —-&gt; 编译器 —-&gt; 字节码文件​ ② 字节码文件 —-&gt;JVM—-&gt; 机器码​ 每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够 跨平台的原因了 ，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会 存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不 能共享。 1. 线程​ 这里所说的线程指程序执行过程中的一个线程实体。JVM 允许一个应用并发执行多个线程。 Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系 。** 当线程本地存储、缓 冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 Java 线程结束，原生线程随之被回收。操作系统负责调度所有线程，并把它们分配到任何可 用的 CPU 上。当原生线程初始化完毕，就会调用 Java 线程的 run () 方法。当线程结束时，会释放原生线程和 Java 线程的所有资源。** Hotspot JVM 后台运行的系统线程主要有下面几个： 名称 内容 虚拟机线程 （VM thread） 这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当 堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。 周期性任务线程 这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。 GC 线程 这些线程支持 JVM 中不同的垃圾回收活动。 编译器线程 这些线程在运行时将字节码动态编译成本地平台相关的机器码。 信号分发线程 这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。 2.JVM 内存区域 ​ JVM 内存区域主要分为线程私有区域【程序计数器、虚拟机栈、本地方法区】、线程共享区 域【JAVA 堆、方法区】、直接内存。​ ** 线程私有数据区域生命周期与线程相同，依赖用户线程的启动 / 结束 而 创建 / 销毁 (在 Hotspot VM 内，** 每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存 / 否跟随本地线程的 生 / 死对应)。 ​ ** 线程共享区域随虚拟机的启动 / 关闭而创建 / 销毁。**​ 直接内存并不是 JVM 运行时数据区的一部分，但也会被频繁的使用：在 JDK 1.4 引入的 NIO 提 供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作 (详见: Java I/O 扩展), 这样就避免了在 Java 堆和 Native 堆中来回复制数据，因此在一些场景中可以显著提高性能。 2.1. 程序计数器 (线程私有)​ 一块较小的内存空间，** 是当前线程所执行的字节码的行号指示器 **，每条线程都要有一个独立的 程序计数器，这类内存也称为 “线程私有” 的内存。​ 正在执行 java 方法的话，计数器记录的是虚拟机字节码指令的地址（当前指令的地址）。如 果还是 Native 方法，则为空。​ 这个内存区域是唯一一个在虚拟机中没有规定任何 OutOfMemoryError 情况的区域。 2.2. 虚拟机栈 (线程私有)​ 是描述 java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame） 用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 每一个方法从调用直至执行完成 的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。​ 栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接 (Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。 栈帧随着方法调用而创建，随着方法结束而销毁 —— 无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异 常）都算作方法结束。 2.3. 本地方法区 (线程私有)​ 本地方法区和 *Java Stack 作用类似 *, 区别是虚拟机栈为执行 Java 方法服务，而 ** 本地方法栈则为 Native 方法服务 **, 如果一个 VM 实现使用 C-linkage 模型来支持 Native 调用，那么该栈将会是一个 C 栈，但 HotSpot VM 直接就把本地方法栈和虚拟机栈合二为一。 2.4. 堆（Heap - 线程共享）运行时数据区​ 是被线程共享的一块内存区域，** 创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行 垃圾收集的最重要的内存区域 **。由于现代 VM 采用分代收集算法，因此 Java 堆从 GC 的角度还可以 细分为：新生代 ( Eden 区 、 From Survivor 区 和 To Survivor 区 ) 和老年代。 2.5. 方法区 / 永久代（线程共享）​ 即我们常说的 ** 永久代 (Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静 态变量、即时编译器编译后的代码 ** 等数据. HotSpot VM 把 GC 分代收集扩展至方法区，即使用 Java 堆的永久代来实现方法区，这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存，而不必为方法区开发专门的内存管理器 (永久带的内存回收的主要目标是针对常量池的回收和类型 的卸载，因此收益一般很小)。 ​ 运行时常量池 （Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版 本、字段、方法、接口等描述等信息外，还有一项信息是常量池 Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加 载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量 池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会 被虚拟机认可、装载和执行。 3. JVM 运行时内存​ Java 堆从 GC 的角度还可以细分为: 新生代 ( Eden 区 、 From Survivor 区 和 To Survivor 区 ) 和 &lt; u &gt; 老年代 。 3.1. 新生代​ 是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。 3.1.1. Eden 区​ *Java 新对象的出生地 *（如果新创建的对象占用内存很大，则直接分配到老 年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行 一次垃圾回收。 3.1.2. ServivorFrom​ 上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 3.1.3. ServivorTo​ 保留了一次 MinorGC 过程中的幸存者。 3.1.4. MinorGC 的过程（复制 -&gt; 清空 -&gt; 互换）​ MinorGC 采用 ** 复制算法 **。 1 ： eden 、 servicorFrom 复制到 ServicorTo ，年龄 + 1 ​ 首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年 龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄 + 1（如果 ServicorTo 不 够位置了就放到老年区）； 2 ： 清空 eden 、 servicorFrom ​ 然后，清空 Eden 和 ServicorFrom 中的对象； *3 ： ServicorTo 和 ServicorFrom 互换 * ​ 最后，ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom 区。 3.2. 老年代​ 主要存放应用程序中生命周期长的内存对象。​ 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行 了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足 够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。​ MajorGC 采用 ** 标记清除算法 **：首先扫描一次所有老年代，标记出存活的对象，然后回收没 有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减 少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的 时候，就会抛出 OOM（Out of Memory）异常。 3.3. 永久代​ 指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息，Class 在被加载的时候被 放入永久区域，它和和存放实例的区域不同，*GC 不会在主程序运行期对永久区域进行清理 *。所以这 也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常。 3.3.1. JAVA8 与元数据在 Java8 中， 永久代已经被移除，被一个称为 “元数据区”（元空间）的区域所取代 。元空间 的本质和永久代类似，元空间与永久代之间最大的区别在于：** 元空间并不在虚拟机中，而是使用 本地内存 。因此，默认情况下，元空间的大小仅受本地内存限制。 类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中 **，这样可以加载多少类的元数据就不再由 MaxPermSize 控制，而由系统的实际可用空间来控制。 4. 垃圾回收与算法 4.1. 如何确定垃圾4.1.1. 引用计数法​ 在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单 的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个 ** 对象如果没有任何与之关 联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。** 4.1.2. 可达性分析​ 为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列的 “GC roots” 对象作为起点搜索。如果 ** 在 “GC roots” 和一个对象之间没有可达路径，则称该对象是不可达的。** ​ 要注意的是，** 不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程 **。两次标记后仍然是可回收对象，则将面临回收。 4.2. 标记清除算法（Mark-Sweep）​ 最基础的垃圾回收算法，分为 ** 两个阶段，标注和清除 **。标记阶段标记出所有需要回收的对象，清 除阶段回收被标记的对象所占用的空间。如图: ​ 从图中我们就可以发现，该算法 ** 最大的问题是内存碎片化严重 **，后续可能发生大对象不能找到可 利用空间的问题。 4.3. 复制算法（copying）​ 为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小 的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用 的内存清掉，如图： ​ 这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原 本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。 4.4. 标记整理算法 (Mark-Compact)​ 结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清 理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图： 4.5. 分代收集算法​ 分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存 划分为不同的域，一般情况下将 GC 堆划分为老生代 (Tenured/Old Generation) 和新生代 (Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃 圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。 4.5.1. 新生代与复制算法​ 目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要 回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代 划分为一块较大的 Eden 空间和两个较小的 Survivor 空间 (From Space, To Space)，每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另 一块 Survivor 空间中。 4.5.2. 老年代与标记复制算法​ 而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。 JAVA 虚拟机提到过的处于 ** 方法区的永生代 (Permanet Generation)，它用来存储 class 类， 常量，方法描述 ** 等。对永生代的回收主要包括废弃常量和无用的类。 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space (Survivor 目 前存放对象的那一块)，少数情况会直接分配到老生代。 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。 当对象在 Survivor 区躲过一次 GC 后，其年龄就会 + 1。** 默认情况下年龄到达 15 的对象会被 移到老生代中。** 5.JAVA 四中引用类型5.1. 强引用​ 在 Java 中最常见的就是强引用，** 把一个对象赋给一个引用变量，这个引用变量就是一个强引 用。当一个对象被强引用变量引用时 **，它处于可达状态，它是不可能被垃圾回收机制回收的，即 使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之 一。 5.2. 软引用​ ** 软引用需要用 SoftReference 类来实现 **，对于只有软引用的对象来说，当系统内存足够时它 不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。 5.3. 弱引用​ 弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象 来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。 5.4. 虚引用​ 虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。** 虚引用的主要作用是跟踪对象被垃圾回收的状态 **。 6.GC 分代收集算法 VS 分区收集算法6.1. 分代收集算法​ 当前主流 VM 垃圾收集都采用” 分代收集”(Generational Collection) 算法，这种算法会根据 对象存活周期的不同将内存划分为几块，如 JVM 中的 新生代、老年代、永久代，这样就可以根据 各年代特点分别采用最适当的 GC 算法 6.1.1. 在新生代 - 复制算法​ 每次垃圾收集都能发现大批对象已死，只有少量存活。因此选用复制算法，只需要付出少量 存活对象的复制成本就可以完成收集. 6.1.2. 在老年代 - 标记整理算法​ 因为对象存活率高、没有额外空间对它进行分配担保，就必须采用 “标记 — 清理” 或 “标 记 — 整理” 算法来进行回收，不必进行内存复制，且直接腾出空闲内存. 6.2. 分区收集算法​ 分区算法则将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。这样做的 好处是可以控制一次回收多少个小区间，根据目标停顿时间，每次合理地回收若干个小区间 (而不是 整个堆), 从而减少一次 GC 所产生的停顿。 7. GC 垃圾收集器​ Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记 - 清除垃圾回收算法； 年老代主要使用标记 - 整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不 同的垃圾收集器，JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器如下： 7.1. Serial 垃圾收集器（单线程、复制算法）​ *Serial（英文连续）是最基本垃圾收集器，使用复制算法 *，曾经是 JDK1.3.1 之前新生代唯一的垃圾 收集器。Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工 作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。 Serial 垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程，但是它简单高效，对于限 定单个 CPU 环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率，因此 Serial 垃圾收集器依然是 *java 虚拟机运行在 Client 模式下默认的新生代垃圾收集器 *。 7.2. ParNew 垃圾收集器（Serial + 多线程）​ ParNew 垃圾收集器其实是 *Serial 收集器的多线程版本 *，也使用复制算法，除了使用多线程进行垃 圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也 要暂停所有其他的工作线程。 ​ ParNew 收集器默认开启和 CPU 数目相同的线程数，可以通过 - XX:ParallelGCThreads 参数来限 制垃圾收集器的线程数。【Parallel：平行的】 ParNew 虽然是除了多线程外和 Serial 收集器几乎完全一样，但是 ParNew 垃圾收集器是 ** 很多 java 虚拟机运行在 Server 模式下新生代的默认垃圾收集器 **。 7.3. Parallel Scavenge 收集器（多线程复制算法、高效）​ Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃 圾收集器，它 ** 重点关注的是程序达到一个可控制的吞吐量 **（Thoughput，CPU 用于运行用户代码 的时间 / CPU 总消耗时间，即吞吐量 = 运行用户代码时间 /(运行用户代码时间 + 垃圾收集时间)）， 高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而 不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个 重要区别。 7.4. Serial Old 收集器（单线程标记整理算法 ）​ *Serial Old 是 Serial 垃圾收集器年老代版本 *，它同样是个单线程的收集器，使用标记 - 整理算法， 这个收集器也主要是 ** 运行在 Client 默认的 java 虚拟机默认的年老代垃圾收集器 **。 在 Server 模式下，主要有两个用途： 在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。 作为年老代中使用 CMS 收集器的后备垃圾收集方案。 新生代 Serial 与年老代 Serial Old 搭配垃圾收集过程图： ​ 新生代 Parallel Scavenge 收集器与 ParNew 收集器工作原理类似，都是多线程的收集器，都使 用的是复制算法，在垃圾收集过程中都需要暂停所有的工作线程。新生代 Parallel Scavenge/ParNew 与年老代 Serial Old 搭配垃圾收集过程图： 7.5. Parallel Old 收集器（多线程标记整理算法）​ Parallel Old 收集器是 Parallel Scavenge 的年老代版本，使用多线程的标记 - 整理算法，在 JDK1.6 才开始提供。 ​ 在 JDK1.6 之前，新生代使用 ParallelScavenge 收集器只能搭配年老代的 Serial Old 收集器，只 能保证新生代的吞吐量优先，无法保证整体的吞吐量，*Parallel Old 正是为了在年老代同样提供吞 吐量优先的垃圾收集器 *，如果系统对吞吐量要求比较高，可以优先考虑新生代 Parallel Scavenge 和年老代 Parallel Old 收集器的搭配策略。 新生代 Parallel Scavenge 和年老代 Parallel Old 收集器搭配运行过程图： 7.6. CMS 收集器（多线程标记清除算法）​ Concurrent mark sweep (CMS) 收集器是一种年老代垃圾收集器，其最 ** 主要目标是获取最短垃圾回收停顿时间 **，和其他年老代使用标记 - 整理算法不同，它使用多线程的标记 - 清除算法。 最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。 CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段： 7.6.1. 初始标记​ 只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。 7.6.2. 并发标记​ 进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。 7.6.3. 重新标记​ 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记 记录，仍然需要暂停所有的工作线程。 7.6.4. 并发清除​ 清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并 发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以 ** 总体上来看 CMS 收集器的内存回收和用户线程是一起并发地执行 **。 CMS 收集器工作过程： 7.7. G1 收集器​ Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收 集器两个最突出的改进是： 基于标记 - 整理算法，不产生内存碎片。 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域 **，并且跟踪这些区域 的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间， 优先回收垃圾最多的区域 **。区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收 集效率。 8. JAVA IO/NIO8.1. 阻塞 IO 模型​ 最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内 核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用 户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read (); 如果数据没有就 绪，就会一直阻塞在 read 方法。 8.2. 非阻塞 IO 模型​ 当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备 好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。 所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下: 1234567while(true)&#123; data = socket.read (); if(data!= error)&#123; 处理数据 break; &#125; &#125; ​ 但是对于非阻塞 IO 就有一个非常严重的问题， 在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高 ，因此一般情况下很少使用 while 循环这种方式来读取数据。 8.3. 多路复用 IO 模型​ 多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO 模型中，** 会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真 正调用实际的 IO 读写操作 **。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通 过 selector.select () 去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这 种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当 socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连 接数比较多的情况。 ​ 另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态 时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效 率要比用户线程要高的多。 ​ 不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件 逐一进行响应。因此对于多路复用 IO 模型来说，** 一旦事件响应体很大，那么就会导致后续的事件 迟迟得不到处理，并且会影响新的事件轮询 **。 8.4. 信号驱动 IO 模型​ 在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函 数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到 信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。 8.5. 异步 IO 模型​ 异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就 可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后， 它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内 核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程 发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何 进行的，** 只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接 去使用数据了。** ​ 也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完 成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的 读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据 已经就绪，然后需要用户线程调用 IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号 表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。 ** 注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。**更多参考： http://www.importnew.com/19816.html 8.6. JAVA IO 包 8.7. JAVA NIO​ NIO 主要有三大核心部分：Channel (通道)，Buffer (缓冲区), Selector。传统 IO 基于字节流和字 符流进行操作，而 *NIO 基于 Channel 和 Buffer (缓冲区) 进行操作，数据总是从通道读取到缓冲区 中，或者从缓冲区写入到通道中 *。Selector (选择区) 用于监听多个通道的事件（比如：连接打开， 数据到达）。因此，单个线程可以监听多个数据通道。 ​ NIO 和传统 IO 之间第一个最大的区别是，*IO 是面向流的，NIO 是面向缓冲区的 *。 8.7.1. NIO 的缓冲区​ Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何 地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓 存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在 缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所 有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的 数据。 8.7.2. NIO 的非阻塞​ IO 的各种流是阻塞的。这意味着，当一个线程调用 read () 或 write () 时，该线程被阻塞，直到有 一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式， 使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可 用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以 继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它 完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上 执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 8.8. Channel​ 首先说一下 Channel，国内大多翻译成 “通道”。Channel 和 IO 中的 Stream (流) 是差不多一个 等级的。** 只不过 Stream 是单向的 **，譬如：InputStream, OutputStream，而 Channel 是双向 的，既可以用来进行读操作，又可以用来进行写操作。 NIO 中的 Channel 的主要实现有： ​ 1.FileChannel ​ 2.DatagramChannel ​ 3.SocketChannel ​ 4.ServerSocketChannel ​ 这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。 下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。 8.9. Buffer​ Buffer，故名思意，** 缓冲区，实际上是一个容器，是一个连续数组 **。Channel 提供从文件、 网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。 ​ 上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送 数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必 须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。 ​ 在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有： ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、 ShortBuffer 8.10. Selector​ Selector 类是 NIO 的核心类，*Selector 能够检测多个注册的通道上是否有事件发生，如果有事 件发生，便获取事件然后针对每个事件进行相应的响应处理 *。这样一来，只是用一个单线程就可 以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用 函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护 多个线程，并且避免了多线程之间的上下文切换导致的开销。 9. JVM 类加载机制9.1JVM 类加载​ JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化，下面我们就分别来看一下这 五个过程。 9.1.1. 加载​ 加载是类加载过程中的一个阶段，** 这个阶段会在内存中生成一个代表这个类 java.lang.Class 对象，作为方法区这个类的各种数据的入口 **。注意这里不一定非得要从一个 Class 文件获取，这里既 可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理）， 也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。 9.1.2. 验证​ 这一阶段的主要目的是为了 ** 确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求 **，并 且不会危害虚拟机自身的安全。 9.1.3. 准备​ 准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即 ** 在方法区中分配这些变量所使用的内存空间 **。注意这里所说的初始值概念，比如一个类变量定义为： 1public static int v = 8080; ​ ** 实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080，将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器 &lt; client &gt; 方法之中 **。 ​ 但是注意如果声明为： 1public static final int v = 8080; ​ 在编译阶段会为 v 生成 ConstantValue 属性，在 ** 准备阶段虚拟机会根据 ConstantValue 属性将 v 赋值为 8080。** 9.1.4. 解析​ 解析阶段是指 ** 虚拟机将常量池中的符号引用替换为直接引用的过程 **。符号引用就是 class 文件中 的： ​ 1.CONSTANT_Class_info ​ 2.CONSTANT_Field_info ​ 3.CONSTANT_Method_info 9.1.5. 符号引用​ 符号引用与虚拟机实现的布局无关，** 引用的目标并不一定要已经加载到内存中。各种虚拟 机实现的内存布局可以各不相同 **，但是它们能接受的符号引用必须是一致的，因为符号引 用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。 9.1.6. 直接引用​ 直接引用可以是 ** 指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄 *。如果有 了直接引用，那 * 引用的目标必定已经在内存中存在 **。 9.1.7. 初始化​ 初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载 器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 9.1.8. 类构造器 client​ ** 初始化阶段是执行类构造器 client 方法的过程 。client 方法是由编译器自动收集类中的类变 量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子 client 方法执行之前，父类 的 client 方法已经执行完毕， 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译 器可以不为这个类生成 client () 方法 **。 ​ 注意以下几种情况不会执行类初始化： 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触 发定义常量所在的类。 通过类名获取 Class 对象，不会触发类的初始化。 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初 始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 9.2. 类加载器​ 虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类，JVM 提 供了 3 种类加载器： 9.2.1. 启动类加载器 (Bootstrap ClassLoader)​ 1. 负责加载 JAVA_HOME\\lib 目录中的，或通过 - Xbootclasspath 参数指定路径中的，且被 虚拟机认可（按文件名识别，如 rt.jar）的类。 9.2.2. 扩展类加载器 (Extension ClassLoader)​ 2. 负责加载 JAVA_HOME\\lib\\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。 9.2.3. 应用程序类加载器 (Application ClassLoader)： 负责 ** 加载用户路径（classpath）上的类库 **。 JVM 通过双亲委派模型进行类的加载，当然我们也可以通过继承 java.lang.ClassLoader 实现自定义的类加载器。 9.3. 双亲委派​ ** 当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父 类去完成 ，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中， 只有当 ** 父类加载器反馈自己无法完成这个请求的时候 **（在它的加载路径下没有找到所需加载的 Class）， 子类加载器才会尝试自己去加载 **。 ​ 采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载 器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就 ** 保证了使用不同的类加载 器最终得到的都是同样一个 Object 对象 **。 9.4. OSGI（动态模型系统）​ OSGi (Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系 统的一系列规范。 9.4.1. 动态改变构造​ OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使 这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。 9.4.2. 模块化编程与热插拔​ OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以 ** 实现模块级的热插拔功能 **，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企 业级程序开发来说是非常具有诱惑力的特性。​ ​ OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时 也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大 功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。 10. 最后​ java 核心这部分，偶然所得的一份 pdf 文件，为不知名大佬所整理，在这表示感谢，本着学习所用的态度。","updated":"2020-03-23T14:23:47.097Z","link":"","tags":[]},{"title":"查看 ubuntu 是 32 位还是 64 位","date":"2019-10-17T07:56:33.000Z","path":"ubuntu-see-64or32bit/","text":"1. 查看操作系统是 32 位的还是 64 位的在控制台输入： 1$ sudo uname --m ** 回车后：**** 如果显示 i686, 则表示安装了 32 位操作系统 **** 如果显示 x86_64，则表示安装了 64 位操作系统 ** 2. 如果想知道更多信息可以试试如下命令：1234$ sudo uname --s # 显示内核名字 $ sudo uname --r # 显示内核版本 $ sudo uname --n # 显示网络主机名 $ sudo uname --p # 显示 cpu","updated":"2020-03-22T16:19:44.924Z","link":"","tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://quietair.gitee.io/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"https://quietair.gitee.io/tags/Linux/"}]},{"title":"jQuery.validator.addMethod 自定义验证规则","date":"2019-10-09T05:51:19.000Z","path":"jQuery-validator-addMethod/","text":"​ jQuery.validate 是一款非常不错的表单验证工具，简单易上手，而且能达到很好的体验效果 1. 用前必备​ 官方网站：http://bassistance.de/jquery-plugins/jquery-plugin-validation/（注意下载最新版）​ 需要 JQuery 版本：1.2.6+, 兼容 1.3.2 12&lt;script src=\"../js/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;script src=\"../js/jquery.validate.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 2. 默认校验规则1234567891011121314151617required:true # 必输字段 remote:\"check.php\" # 使用 ajax 方法调用 check.php 验证输入值 email:true # 必须输入正确格式的电子邮件 url:true # 必须输入正确格式的网址 date:true # 必须输入正确格式的日期 dateISO:true # 必须输入正确格式的日期 (ISO)，例如：2009-06-23，1998/01/22 只验证格式，不验证有效性 number:true # 必须输入合法的数字 (负数，小数)digits:true # 必须输入整数 creditcard: # 必须输入合法的信用卡号 equalTo:\"#field\" # 输入值必须和 #field 相同 accept: # 输入拥有合法后缀名的字符串（上传文件的后缀）maxlength:5 # 输入长度最多是 5 的字符串 (汉字算一个字符)minlength:10 # 输入长度最小是 10 的字符串 (汉字算一个字符)rangelength:[5,10] # 输入长度必须介于 5 和 10 之间的字符串 \")(汉字算一个字符)range:[5,10] # 输入值必须介于 5 和 10 之间 max:5 # 输入值不能大于 5min:10 # 输入值不能小于 10 3. 默认的提示123456789101112131415161718192021222324252627282930313233343536373839404142messages: &#123;required: \"This field is required.\",remote: \"Please fix this field.\",email: \"Please enter a valid email address.\",url: \"Please enter a valid URL.\",date: \"Please enter a valid date.\",dateISO: \"Please enter a valid date (ISO).\",dateDE: \"Bitte geben Sie ein g 眉 ltiges Datum ein.\",number: \"Please enter a valid number.\",numberDE: \"Bitte geben Sie eine Nummer ein.\",digits: \"Please enter only digits\",creditcard: \"Please enter a valid credit card number.\",equalTo: \"Please enter the same value again.\",accept: \"Please enter a value with a valid extension.\",maxlength: $.validator.format (\"Please enter no more than &#123;0&#125; characters.\"),minlength: $.validator.format (\"Please enter at least &#123;0&#125; characters.\"),rangelength: $.validator.format (\"Please enter a value between &#123;0&#125; and &#123;1&#125; characters long.\"),range: $.validator.format (\"Please enter a value between &#123;0&#125; and &#123;1&#125;.\"),max: $.validator.format (\"Please enter a value less than or equal to &#123;0&#125;.\"),min: $.validator.format (\"Please enter a value greater than or equal to &#123;0&#125;.\")&#125;, 如需要修改，可在 js 代码中加入：jQuery.extend (jQuery.validator.messages, &#123;required: \"必选字段\",remote: \"请修正该字段\",email: \"请输入正确格式的电子邮件\",url: \"请输入合法的网址\",date: \"请输入合法的日期\",dateISO: \"请输入合法的日期 (ISO).\",number: \"请输入合法的数字\",digits: \"只能输入整数\",creditcard: \"请输入合法的信用卡号\",equalTo: \"请再次输入相同的值\",accept: \"请输入拥有合法后缀名的字符串\",maxlength: jQuery.validator.format (\"请输入一个长度最多是 &#123;0&#125; 的字符串\"),minlength: jQuery.validator.format (\"请输入一个长度最少是 &#123;0&#125; 的字符串\"),rangelength: jQuery.validator.format (\"请输入一个长度介于 &#123;0&#125; 和 &#123;1&#125; 之间的字符串\"),range: jQuery.validator.format (\"请输入一个介于 &#123;0&#125; 和 &#123;1&#125; 之间的值\"),max: jQuery.validator.format (\"请输入一个最大为 &#123;0&#125; 的值\"),min: jQuery.validator.format (\"请输入一个最小为 &#123;0&#125; 的值\")&#125;);// 推荐做法，将此文件放入 messages_cn.js 中，在页面中引入 &lt;script src=\"../js/messages_cn.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 4. 使用方法html: 1234567891011121314151617181920212223//head 里需要加入 #&lt;script src=\"../js/jquery.js\" type=\"text/javascript\"&gt;&lt;/script&gt;#&lt;script src=\"../js/jquery.validate.js\" type=\"text/javascript\"&gt;&lt;/script&gt;#&lt;script src=\"./js/messages_cn.js\" type=\"text/javascript\"&gt;&lt;/script&gt;&lt;form action=\"\" method=\"post\" id=\"registerForm\" onsubmit=\"return toVaild ()\"&gt; &lt;div&gt; &lt;input type=\"text\" name=\"userName\" class=\"username\" placeholder=\" 您的用户名 \" autocomplete=\"off\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"password\" name=\"userPw\" class=\"password\" placeholder=\" 输入密码 \" oncontextmenu=\"return false\" onpaste=\"return false\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"password\" name=\"confirm_password\" class=\"confirm_password\" placeholder=\" 再次输入密码 \" oncontextmenu=\"return false\" onpaste=\"return false\" /&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"text\" name=\"userPhoneNum\" class=\"phone_number\" placeholder=\" 输入手机号码 \" autocomplete=\"off\" id=\"number\"/&gt; &lt;/div&gt; &lt;div&gt; &lt;input type=\"email\" name=\"userMail\" class=\"email\" placeholder=\" 输入邮箱地址 \" oncontextmenu=\"return false\" onpaste=\"return false\" /&gt; &lt;/div&gt; &lt;button id=\"submit\" type=\"submit\"&gt; 注 册 & lt;/button&gt;&lt;/form&gt; messages_cn.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677//jquery.validate 表单验证 $(document).ready (function()&#123; // 注册表单验证 $(\"#registerForm\").validate (&#123; rules:&#123; userName:&#123; required:true,// 必填 minlength:3, // 最少 3 个字符 maxlength:32,// 最多 20 个字符 uName:true,// 自定义的规则 /*remote:&#123; url:\"http://kouss.com/demo/Sharelink/remote.json\",// 用户名重复检查，别跨域调用 type:\"post\", &#125;,*/ &#125;, userPw:&#123; required:true, minlength:3, maxlength:32, &#125;, userMail:&#123; required:true, email:true, &#125;, confirm_password:&#123; required:true, minlength:3, equalTo:'.password' &#125;, userPhoneNum:&#123; required:true, userPhoneNum:true,// 自定义的规则 digits:true,// 整数 &#125; &#125;, // 错误信息提示 messages:&#123; userName:&#123; required:\"必须填写用户名\", minlength:\"用户名至少为 3 个字符\", maxlength:\"用户名至多为 32 个字符\", //remote: \"用户名已存在\", &#125;, userPw:&#123; required:\"必须填写密码\", minlength:\"密码至少为 3 个字符\", maxlength:\"密码至多为 32 个字符\", &#125;, userMail:&#123; required:\"请输入邮箱地址\", email: \"请输入正确的 email 地址\" &#125;, confirm_password:&#123; required: \"请再次输入密码\", minlength: \"确认密码不能少于 3 个字符\", equalTo: \"两次输入密码不一致\",// 与另一个元素相同 &#125;, userPhoneNum:&#123; required:\"请输入手机号码\", digits:\"请输入正确的手机号码\", &#125;, &#125;, &#125;); // 字母和数字的验证 jQuery.validator.addMethod (\"uName\", function(value, element) &#123; var uName = /^([a-zA-Z0-9]+)$/; return this.optional (element) || (uName.test (value)); &#125;, \"用户名仅支持非空，数字和英文\"); // 添加自定义验证规则 jQuery.validator.addMethod (\"userPhoneNum\", function(value, element) &#123; var length = value.length; var userPhoneNum = /^1 [3456789]\\d&#123;9&#125;$/ return this.optional (element) || (length == 11 &amp;&amp; userPhoneNum.test (value)); &#125;, \"手机号码格式错误\");&#125;); ** 方法：$.validator.addMethod (name,function (value,element){ return true||false },message)；** 参数： 第一个参数：用于 type 匹配的名称，自定义。 第二个参数：是一个 function 函数，决定了验证是否成功！里面是自定义验证。 第三个参数：当验证不成功时返回的提示错误信息。","updated":"2020-03-22T15:56:20.059Z","link":"","tags":[{"name":"JQuery","slug":"JQuery","permalink":"https://quietair.gitee.io/tags/JQuery/"},{"name":"Html","slug":"Html","permalink":"https://quietair.gitee.io/tags/Html/"},{"name":"Validate","slug":"Validate","permalink":"https://quietair.gitee.io/tags/Validate/"}]},{"title":"Ubuntu 配置 Tomcat80 端口","date":"2019-09-30T03:01:10.000Z","path":"ubuntu-tomcat/","text":"本地环境：*ubuntu 18.04 LTS*jdk 1.8.0_181*tomcat 9.0.26 ​ 使用 Ubuntu 18.04 环境部署 Java Web 应用，在配置 Tomcat 时，发现 8080 端口没问题，改为 80 端口后就报错，然后自己网上找了些资料改去改来，不是 [“http-nio-80”]，就 APR，要么就拒绝连接。明天前面都用得好好的！后来又网上看了很多，才发现问题，然后就写这篇记忆下。 ​ 具体问题为在 Linux 中对非 root 用户只能使用 1024 及以上的端口号，所以 80 端口对非 root 用户为禁用状态。第一种解决方法：使用 root 用户去配置并启动 Tomcat。这里讲的是第二种解决方法：使用 iptables 的转发功能，将 80 端口消息转发给 8080 端口。如果嫌麻烦，建议第一种。自己记住就行了。第二种教程如下： 1. 前期工作1.1. 系统是否安装防火墙：1$ whereis iptables 1.2. 安装则下面显示为：12$ iptables: $ /sbin/iptables/etc/iptables.rules/usr/share/iptables/usr/share/man/man8/iptables.8.gz 1.3. 反之，安装防火墙：1$ sudo apt-get install iptables 1.4. 查看防火墙信息：1$ iptables -L -n 2. 配置防火墙2.1. 创建 iptables.rules 文件：1$ vi /etc/iptables.rules 2.2. 按 i 进入编辑模式，添加以下规则：12345678910111213141516171819*filter:INPUT DROP [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]:syn-flood - [0:0]-A INPUT -i lo -j ACCEPT-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT-A INPUT -p tcp -m state --state NEW -m tcp --dport 8443 -j ACCEPT-A INPUT -p icmp -m limit --limit 100/sec --limit-burst 100 -j ACCEPT-A INPUT -p icmp -m limit --limit 1/s --limit-burst 10 -j ACCEPT-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j syn-flood-A INPUT -j REJECT --reject-with icmp-host-prohibited-A syn-flood -p tcp -m limit --limit 3/sec --limit-burst 6 -j RETURN-A syn-flood -j REJECT --reject-with icmp-port-unreachableCOMMIT 1234522 端口为 SSH 默认端口 80 端口为 HTTP 默认端口 443 端口为 HTTPS 默认端口 8080 端口为 Tomcat 默认的 HTTP 端口 8443 端口为 Tomcat 默认的 HTTPS 端口 2.3. 使防火墙规则生效：1$ iptables-restore &lt; /etc/iptables.rules 2.4. 配置防火墙规则开机启动： 创建 iptables 文件： 1$ vi /etc/network/if-pre-up.d/iptables 添加以下内容： 12$ !/bin/bash$ iptables-restore &lt; /etc/iptables.rules 2.5. 为 iptables 文件添加执行权限：1$ chmod +x /etc/network/if-pre-up.d/iptables 2.6. 查看规则是否生效：1$ iptables -L -n 123456789101112131415161718192021222324Chain INPUT (policy DROP)target prot opt source destination ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHEDACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:22ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:80ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:443ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:8080ACCEPT tcp -- 0.0.0.0/0 0.0.0.0/0 state NEW tcp dpt:8443ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 limit: avg 100/sec burst 100ACCEPT icmp -- 0.0.0.0/0 0.0.0.0/0 limit: avg 1/sec burst 10syn-flood tcp -- 0.0.0.0/0 0.0.0.0/0 tcp flags:0x17/0x02REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-host-prohibitedChain FORWARD (policy ACCEPT)target prot opt source destination Chain OUTPUT (policy ACCEPT)target prot opt source destination Chain syn-flood (1 references)target prot opt source destination RETURN tcp -- 0.0.0.0/0 0.0.0.0/0 limit: avg 3/sec burst 6REJECT all -- 0.0.0.0/0 0.0.0.0/0 reject-with icmp-port-unreachable 3. 新增转发规则3.1. 将 80 端口转发至 8080 端口1$ iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 3.2. 查看 80 端口相关的转发规则1$ iptables -t nat -L -n | grep 80 返回： 1$ REDIRECT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 redir ports 8080 3.3. 配置 Tomcat 服务端口为 8080 找到 Tomcat 安装目录下的 ../conf/server.xml 配置文件并且打开编辑如下内容，改为 8080 端口即可。 &lt;Connector port=”8080” protocol=”HTTP/1.1” 3.4. 重启 Tomcat 服务，试一下应该就可以进行正常访问 80 端口了。1$ service tomcat restart 4. 删除转发规则4.1. 将转发规则以数字序号排列显示:1$ iptables -t nat -L -n --line-numbers Chain PREROUTING (policy ACCEPT) num target prot opt source destination 1 REDIRECT tcp – 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 redir ports 8080 4.2. 删除 8080 端口对于的转发规则：1$ iptables -t nat -D PREROUTING 1 5. 相关问题​ 上述配置完成后，即可使用 IP 地址（或域名）+ 应用程序页面访问路径。如需直接使用 IP 地址（或域名）访问应用程序默认页面，应另外配置。另外，若参照上述配置时使用的是通过 域名 进行访问，则需要进行域名备案，同时需要指定访问的应用。当然可以暂且使用 域名：8080 进行访问，或是使用 https:// 域名 进行访问。 6. 文章参考Ubuntu 如何配置 Tomcat 访问 80 端口","updated":"2020-03-22T16:01:10.171Z","link":"","tags":[{"name":"Tomcat","slug":"Tomcat","permalink":"https://quietair.gitee.io/tags/Tomcat/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://quietair.gitee.io/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"https://quietair.gitee.io/tags/Linux/"}]}]